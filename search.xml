<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ECDSA</title>
    <url>/2023/08/18/ECDSA/</url>
    <content><![CDATA[<p>起一篇文章简单记录一下ECDSA的签名过程</p>
<span id="more"></span>



<p>椭圆曲线数字签名算法（ECDSA）是使用椭圆曲线密码（ECC）对数字签名算法（DSA）的模拟</p>
<h1 id="DSA数字签名"><a href="#DSA数字签名" class="headerlink" title="DSA数字签名"></a>DSA数字签名</h1><h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><ol>
<li>选择一个合适的哈希函数，一般选择SHA1</li>
<li>选择密钥的长度$L$和$N$，</li>
<li>选择$N$比特的素数$q$</li>
<li>选择$L$比特的素数$p$，使得$p-1$是$q$的倍数</li>
<li>选择满足$g^k \equiv 1 \mod p$的最小正整数$k$为$q$的g，就是在模$p$的前提下，$ord(g) &#x3D; q的g$</li>
<li>选择私钥$x \in (0,q)$，计算$y\equiv g^x \mod p$</li>
<li>公钥为$(p,q,g,y)$，私钥为$x$</li>
</ol>
<h2 id="签名过程"><a href="#签名过程" class="headerlink" title="签名过程"></a>签名过程</h2><ol>
<li>选择随机整数$k(0,q)$作为临时密钥</li>
<li>计算$r\equiv (g^k \mod p) \mod q$</li>
<li>计算$s \equiv k^{-1}(H(m)+xr) \mod q$</li>
</ol>
<p>公开$(r,s)$，$H(m)$指哈希后的明文</p>
<h2 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程</h2><ol>
<li>计算$\omega \equiv s^{-1} \mod q$</li>
<li>计算$\mu_1 \equiv H(m)×\omega \mod q$</li>
<li>计算$\mu_2 \equiv r×\omega \mod q$</li>
<li>计算$v \equiv (g^{\mu_1}y^{\mu_2}\mod p) \mod q$</li>
<li>如果$v &#x3D; r$则验证成功</li>
</ol>
<h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>如果两次签名用了同一个$k$，就可以进行攻击</p>
<p>当$k$一样时，两个$r$是一样的</p>
<p>则有</p>
<p>$s_1 \equiv k^{-1}(H(m_1)+xr) \mod q$</p>
<p>$s_2 \equiv k^{-1}(H(m_2)+xr) \mod q$</p>
<p>两式相减得</p>
<p>$(s_1-s_2) \equiv k^{-1}(H(m_1)-H(m_2)) \mod q$</p>
<p>$k \equiv (s_1-s_2)^{-1}(H(m_1)-H(m_2)) \mod q$</p>
<p>求出$k$后，根据$s \equiv k^{-1}(H(m)+xr) \longrightarrow ks \equiv H(m)+xr \longrightarrow x\equiv (ks - H(m))r^{-1}\mod q$</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="长城杯-2022-——known-phi"><a href="#长城杯-2022-——known-phi" class="headerlink" title="[长城杯 2022]——known_phi"></a>[长城杯 2022]——known_phi</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, bytes_to_long, inverse, long_to_bytes</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> DSA</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>(<span class="params">a</span>):</span><br><span class="line">    p = getPrime(a) </span><br><span class="line">    q = getPrime(a)</span><br><span class="line">    r = getPrime(a)</span><br><span class="line">    x = getPrime(a)</span><br><span class="line">    n = p*q*r*x</span><br><span class="line">    phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)*(r-<span class="number">1</span>)*(x-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n, phi, [p, q, r, x]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">m, k, x, p, q, g</span>):</span><br><span class="line">    hm = bytes_to_long(sha256(m).digest())</span><br><span class="line">    r = <span class="built_in">pow</span>(g, k, p) % q</span><br><span class="line">    s = (hm + x*r) * inverse(k, q) % q</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r,s</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">a = <span class="number">256</span></span><br><span class="line">x = bytes_to_long(flag)</span><br><span class="line"><span class="comment"># print(x)</span></span><br><span class="line"></span><br><span class="line">n, phi, n_factors = gen(a)</span><br><span class="line">n_factors = <span class="built_in">sorted</span>(n_factors)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;n = <span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;phi = <span class="subst">&#123;phi&#125;</span>&#x27;</span>)</span><br><span class="line">m1 = long_to_bytes(n_factors[<span class="number">0</span>] + n_factors[<span class="number">3</span>])</span><br><span class="line">m2 = long_to_bytes(n_factors[<span class="number">1</span>] + n_factors[<span class="number">2</span>])</span><br><span class="line"><span class="comment"># print(f&#x27;m1 = &#123;m1&#125;&#x27;)</span></span><br><span class="line"><span class="comment"># print(f&#x27;m2 = &#123;m2&#125;&#x27;)</span></span><br><span class="line"></span><br><span class="line">key = DSA.generate(<span class="built_in">int</span>(<span class="number">2048</span>))</span><br><span class="line">q = key.q</span><br><span class="line">p = key.p</span><br><span class="line">g = key.g</span><br><span class="line"><span class="keyword">assert</span> q &gt; x</span><br><span class="line">k = random.randint(<span class="number">1</span>, q-<span class="number">1</span>)</span><br><span class="line">r1, s1 = sign(m1, k, x, p, q, g)</span><br><span class="line">r2, s2 = sign(m2, k, x, p, q, g)</span><br><span class="line"><span class="comment"># print(f&#x27;k = &#123;k&#125;&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;q = <span class="subst">&#123;q&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;r1 = <span class="subst">&#123;r1&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;s1 = <span class="subst">&#123;s1&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;r2 = <span class="subst">&#123;r2&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;s2 = <span class="subst">&#123;s2&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n = 104228256293611313959676852310116852553951496121352860038971098657350022997841589403091722735802150153734050783858816709247647536393314564077002364012463220999962114186339228164032217361145009468516448617173972835797623658266515762201804936729547278758839604969469770650218191574897316410254695420895895051693</span></span><br><span class="line"><span class="string">phi = 104228256293611313959676852310116852553951496121352860038971098657350022997837434645707418205268240995284026522165519145773852565112344453740579163420312890001524537570675468046604347184376661743552799809753709321949095844960227307733389258381950812717245522599433727311919405966404418872873961877021696812800</span></span><br><span class="line"><span class="string">q = 24513014442114004234202354110477737650785387286781126308169912007819</span></span><br><span class="line"><span class="string">r1 = 8881880595434882344509893789458546908449907797285477983407324325035</span></span><br><span class="line"><span class="string">s1 = 764450933738974696530033347966845551587903750431946039815672438603</span></span><br><span class="line"><span class="string">r2 = 8881880595434882344509893789458546908449907797285477983407324325035</span></span><br><span class="line"><span class="string">s2 = 22099482232399385060035569388467035727015978742301259782677969649659</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>已知$n,phi$，网上找个脚本把n分解之后，可以得到$m_1,m_2$。</p>
<p>有了$m_1,m_2$即可求哈希后的值$h_1,h_2$</p>
<p>求得$k \equiv (s_1-s_2)^{-1}(h_1-h_2) \mod q$</p>
<p>最后求得$x\equiv (ks_1 - H_1)r_1^{-1}\mod q$</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = </span><br><span class="line">phi = </span><br><span class="line">q = <span class="number">24513014442114004234202354110477737650785387286781126308169912007819</span></span><br><span class="line">r1 = <span class="number">8881880595434882344509893789458546908449907797285477983407324325035</span></span><br><span class="line">s1 = <span class="number">764450933738974696530033347966845551587903750431946039815672438603</span></span><br><span class="line">r2 = <span class="number">8881880595434882344509893789458546908449907797285477983407324325035</span></span><br><span class="line">s2 = <span class="number">22099482232399385060035569388467035727015978742301259782677969649659</span></span><br><span class="line"></span><br><span class="line">primes = <span class="built_in">sorted</span>(factorize_multi_prime(n,phi))</span><br><span class="line"></span><br><span class="line">m1 = long_to_bytes(primes[<span class="number">0</span>]+primes[<span class="number">3</span>])</span><br><span class="line">m2 = long_to_bytes(primes[<span class="number">1</span>]+primes[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">h1 = bytes_to_long(sha256(m1).digest())</span><br><span class="line">h2 = bytes_to_long(sha256(m2).digest())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">k = gmpy2.invert((s1-s2),q)*(h1-h2) % q</span><br><span class="line">r_ = gmpy2.invert(r1,q)</span><br><span class="line"></span><br><span class="line">d = ((k * s1) - h1)*r_ % q</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(d)))</span><br></pre></td></tr></table></figure>





<h1 id="ECDSA"><a href="#ECDSA" class="headerlink" title="ECDSA"></a>ECDSA</h1><h2 id="签名过程-1"><a href="#签名过程-1" class="headerlink" title="签名过程"></a>签名过程</h2><ol>
<li>首先选择一条椭圆曲线$E_p(a,b)$，和基点$G$</li>
<li>选择私钥$d,(d&lt;n)$，$n$是基点$G$的阶</li>
<li>利用基点计算公钥$Q &#x3D; dG$，$Q$表示为$(Q_X,Q_Y$并公开$Q$</li>
<li>选择一个随机数$k,(k&lt;n)$，计算$R &#x3D; kG$，$R$表示为$(R_X,R_Y)$</li>
<li>计算$r \equiv R_X \mod n$，如果$r &#x3D; 0$，则选取另一个$k$并重新计算</li>
<li>计算明文$m$的哈希值，记为$H &#x3D; hash(m)$</li>
<li>计算$s \equiv k^{-1}(H+rd)\mod n$</li>
<li>如果$s&#x3D;0$，则选取另外一个$k$并重新计算</li>
<li>输出签名$(r,s)$</li>
</ol>
<h2 id="验证过程-1"><a href="#验证过程-1" class="headerlink" title="验证过程"></a>验证过程</h2><ol>
<li>计算整数$u_1 &#x3D; s^{-1}×H \mod n$</li>
<li>计算整数$u_2 &#x3D;s^{-1}×r \mod n$</li>
<li>计算点$R &#x3D; u_1G+u_2Q \mod n$</li>
</ol>
<p>证明验证过程的正确性</p>
<p>$\because R &#x3D; u_1G + u_2Q \mod n \longrightarrow R &#x3D; u_1G+u_2dG &#x3D; (u_1+u_2d) \mod n$</p>
<p>把$u_1,u_2$替换掉</p>
<p>$\therefore R &#x3D; (s^{-1}H+s^{-1}rd)G \mod n$</p>
<p>$\therefore R &#x3D; s^{-1}(H+rd)G \mod n$</p>
<p>结合$s \equiv k ^{-1}(H+rd) \mod n$，我们能得到$s^{-1} \equiv k(H+rd)^{-1} \mod n$</p>
<p>则$R &#x3D; k(H+rd)^{-1}×(H+rd) \mod n &#x3D; kG$</p>
<p>与签名过程的$R&#x3D;kG$一致</p>
<h2 id="攻击-1"><a href="#攻击-1" class="headerlink" title="攻击"></a>攻击</h2><p>如果使用同一个k，危险性很大，在此情况下，很容易反推出$d$</p>
<p>我们需要两个哈希值$H_1,H_2$，两组签名$(r_1,s_1),(r_2,s_2)$，还有椭圆曲线的参数</p>
<p>因为$R \equiv kG$，$r &#x3D; R_x \mod n$，如果$k$一样，则$r_1 &#x3D; r_2$</p>
<p>$\because s \equiv k^{-1}(H+rd)$，$\therefore (s_1-s_2) \equiv k^{-1}(H_1-H_2) \mod n$</p>
<p>两边同乘$k$得$k(s_1-s_2) \equiv H_1-H_2 \mod n$</p>
<p>$\therefore k \equiv (s_1-s_2)^{-1}(H_1-H_2) \mod n$</p>
<p>求出k之后，根据$s \equiv k^{-1}(H+rd) \longrightarrow ks \equiv H+rd \longrightarrow d \equiv (ks - H)r^{-1}\mod n$</p>
<p>例题</p>
]]></content>
      <tags>
        <tag>签名</tag>
      </tags>
  </entry>
  <entry>
    <title>AES</title>
    <url>/2023/07/23/AES/</url>
    <content><![CDATA[<p>浅浅学习一下AES加密的几种模式</p>
<span id="more"></span>



<p><strong>AES加密只能加密128bit的块，如果明文长度不足128bit，那就需要进行填充</strong></p>
<p><strong>CTR模式不需要填充</strong></p>
<h1 id="ECB模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h1><p><strong>电码本模式，ECB (Electronic Codebook Book)</strong></p>
<p>ECB模式加解密流程：</p>
<p><img src="/../images/AES/ECB.png"></p>
<p><strong>ECB模式首先要_把明文分块，然后用相同的加密方式和密钥进行加密，这就会导致同样的明文加密后得到的是同样的密文</strong><br>$$<br>设明文分块为x_i,密钥为key,加密函数为E_k,解密函数为D_k<br>$$</p>
<p>$$<br>\therefore 加密后的密文c_i &#x3D; E_k(x_i)<br>$$</p>
<p>$$<br>解密：<br>$$</p>
<p>$$<br>m_i &#x3D; D_k(c_i)<br>$$</p>
<p><strong>使用Cipher库里有加解密ECB的例子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">key = random.getrandbits(<span class="number">128</span>)</span><br><span class="line">key = long_to_bytes(key)</span><br><span class="line"></span><br><span class="line">aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">m = <span class="string">b&#x27;abcdefghijklmnop&#x27;</span></span><br><span class="line"></span><br><span class="line">c = aes.encrypt(m)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line">plaintext = aes.decrypt(c)</span><br><span class="line"><span class="built_in">print</span>(plaintext)</span><br></pre></td></tr></table></figure>

<p><strong>值得注意的是，明文m和密钥key的长度必须是16的倍数</strong></p>
<h1 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h1><p><strong>密码分组链接模式，CBC(Cipher Block Chaining)</strong></p>
<p><img src="/../images/AES/CBC.png"></p>
<p><strong>在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行ECB加密后得到密文分组。对于第一块明文，引入初始向量</strong><code>iv</code><strong>这个概念</strong></p>
<p><strong>每个明文块应该是128bit,或者128的倍数</strong></p>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密</span></span><br><span class="line">iv = random.getrandbits(<span class="number">128</span>)</span><br><span class="line">iv = long_to_bytes(iv)</span><br><span class="line">key = random.getrandbits(<span class="number">128</span>)</span><br><span class="line">key = long_to_bytes(key)</span><br><span class="line"><span class="built_in">print</span>(key,iv,sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">aes = AES.new(key,AES.MODE_CBC,iv)</span><br><span class="line">m = <span class="string">b&#x27;abcdefghijklmnop&#x27;</span></span><br><span class="line">c = aes.encrypt(m)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line">key = <span class="string">b&#x27;\xd4\xc5\x0f\xf3\x89\xd3[\x94\xbc\xde\xacds\xae\xf3\x1b&#x27;</span></span><br><span class="line">iv = <span class="string">b&#x27;\xf0\x90\xd1\x99\r\xb1\xa7\x81\xa8\xae\xbbQ\xec\xaa\xef\x10&#x27;</span></span><br><span class="line">c = <span class="string">b&#x27;\x95&#123;\x80\xffS\x14L^\x9e?\x08~y\nH1&#x27;</span></span><br><span class="line"></span><br><span class="line">decryption = AES.new(key,AES.MODE_CBC,iv)</span><br><span class="line">plaintext = decryption.decrypt(c)</span><br><span class="line"><span class="built_in">print</span>(plaintext)</span><br></pre></td></tr></table></figure>



<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Cipher import AES</span><br><span class="line">import os</span><br><span class="line">iv = os.urandom(16)</span><br><span class="line">key = os.urandom(16)</span><br><span class="line">my_aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">flag = open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;).read()</span><br><span class="line">flag += (16 - len(flag) % 16) * b&#x27;\x00&#x27;</span><br><span class="line">c = my_aes.encrypt(flag)</span><br><span class="line">print(list(c), list(iv), list(key))</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">[137, 163, 60, 145, 236, 127, 76, 5, 212, 171, 46, 211, 161, 172, 41, 198, 117, 247, 140, 226, 169, 248, 208, 245, 214, 44, 180, 9, 170, 59, 205, 234] [138, 237, 90, 59, 60, 190, 103, 179, 137, 128, 10, 206, 237, 10, 183, 174] [170, 90, 227, 119, 123, 155, 185, 38, 148, 37, 159, 42, 221, 36, 2, 57]</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>这里已经给出密文，初始向量，密钥。只需把他们先转成byte，然后再按流程解密</strong></p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">iv = [<span class="number">138</span>, <span class="number">237</span>, <span class="number">90</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">190</span>, <span class="number">103</span>, <span class="number">179</span>, <span class="number">137</span>, <span class="number">128</span>, <span class="number">10</span>, <span class="number">206</span>, <span class="number">237</span>, <span class="number">10</span>, <span class="number">183</span>, <span class="number">174</span>]</span><br><span class="line">key = [<span class="number">170</span>, <span class="number">90</span>, <span class="number">227</span>, <span class="number">119</span>, <span class="number">123</span>, <span class="number">155</span>, <span class="number">185</span>, <span class="number">38</span>, <span class="number">148</span>, <span class="number">37</span>, <span class="number">159</span>, <span class="number">42</span>, <span class="number">221</span>, <span class="number">36</span>, <span class="number">2</span>, <span class="number">57</span>]</span><br><span class="line">c = [<span class="number">137</span>, <span class="number">163</span>, <span class="number">60</span>, <span class="number">145</span>, <span class="number">236</span>, <span class="number">127</span>, <span class="number">76</span>, <span class="number">5</span>, <span class="number">212</span>, <span class="number">171</span>, <span class="number">46</span>, <span class="number">211</span>, <span class="number">161</span>, <span class="number">172</span>, <span class="number">41</span>, <span class="number">198</span>, <span class="number">117</span>, <span class="number">247</span>, <span class="number">140</span>, <span class="number">226</span>, <span class="number">169</span>, <span class="number">248</span>, <span class="number">208</span>, <span class="number">245</span>, <span class="number">214</span>, <span class="number">44</span>, <span class="number">180</span>, <span class="number">9</span>, <span class="number">170</span>, <span class="number">59</span>, <span class="number">205</span>, <span class="number">234</span>] </span><br><span class="line"></span><br><span class="line">Iv = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">Key = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">C = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> iv:</span><br><span class="line">    Iv += long_to_bytes(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> key:</span><br><span class="line">    Key += long_to_bytes(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">    C += long_to_bytes(i)</span><br><span class="line"></span><br><span class="line">DecryptKey = AES.new(Key,AES.MODE_CBC,Iv)</span><br><span class="line">flag = DecryptKey.decrypt(C)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<h2 id="HNCTF-2022-WEEK3-AES"><a href="#HNCTF-2022-WEEK3-AES" class="headerlink" title="[HNCTF 2022 WEEK3]AES"></a>[HNCTF 2022 WEEK3]AES</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad, unpad</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> urandom</span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cbc_encrypt</span>(<span class="params">msg: <span class="built_in">bytes</span></span>):</span><br><span class="line">    msg = pad(msg, <span class="number">16</span>)</span><br><span class="line">    msg = [msg[i:i+<span class="number">16</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(msg), <span class="number">16</span>)]</span><br><span class="line">    key = urandom(<span class="number">16</span>)</span><br><span class="line">    out = []</span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> msg:</span><br><span class="line">        cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">        <span class="built_in">next</span> = cipher.encrypt(block)</span><br><span class="line">        out.append(<span class="built_in">next</span>)</span><br><span class="line">        key = <span class="built_in">next</span></span><br><span class="line">    out = <span class="string">b&quot;&quot;</span>.join(out)</span><br><span class="line">    <span class="keyword">return</span> key, out</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    key, ct = cbc_encrypt(flag*<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># print(f&quot;flag = &#123;flag&#125;&quot;)</span></span><br><span class="line">    <span class="comment"># print(f&quot;key = &#123;key&#125;&quot;)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;ct = <span class="subst">&#123;ct&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">ct = b&#x27;\x179\xb8l\x97\xbew\xc2\xd5f~\x8e\xdc\xf2\x9b\xabR\xa9a\xd2\xf4\xde\xd6|\xd1\x9f\xe9q\x1d\xfcm\xfbj\xe9\x9e\xab\xf5fL\xb3\xb5_\xa5\x16\x8e\x7f\x9fV`\x8b\x16\xa1\xa6)\x08\x97\x91\xbd3\x1d\xeb\\\x86\xa2\xd6\x94&gt;\xf3\xfdt\xd9\x14\xf3\xfc\xe2\x02\xd6\xc4\xcfq&quot;\x1a\x14~2]4\x9f\xc9\x88\xf8\x12\xb6\xa2\xd7\xec\x0b\x7f\xd4d\xdc\xc6\xb4]\x10u\xc6f\x97m\xccA\x82\x02\xa5gh\x85\x85Wz\xd9.\xff\x9bx\x99J\x0e\x86\x16\x90\xad\x1e\x17\x86\x95\xb8S\x17\xea\x93v\xd0&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>msg = pad(msg, 16)</code>，将msg填充为16的倍数</p>
<p><code>msg = [msg[i:i+16] for i in range(0, len(msg), 16)]</code>，将msg分为每组16字节</p>
<p><code>    key = urandom(16)</code>，随机生成一个16字节的加密密钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for block in msg:</span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    next = cipher.encrypt(block)</span><br><span class="line">    out.append(next)</span><br><span class="line">    key = next</span><br><span class="line">out = b&quot;&quot;.join(out)</span><br><span class="line">return key, out</span><br></pre></td></tr></table></figure>

<p>对每组明文进行ECB加密，并且将加密后的密文作为下一组加密的密钥。我们除了第一组密文无法解密，其他密文都可以解出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">ct = <span class="string">b&#x27;\x179\xb8l\x97\xbew\xc2\xd5f~\x8e\xdc\xf2\x9b\xabR\xa9a\xd2\xf4\xde\xd6|\xd1\x9f\xe9q\x1d\xfcm\xfbj\xe9\x9e\xab\xf5fL\xb3\xb5_\xa5\x16\x8e\x7f\x9fV`\x8b\x16\xa1\xa6)\x08\x97\x91\xbd3\x1d\xeb\\\x86\xa2\xd6\x94&gt;\xf3\xfdt\xd9\x14\xf3\xfc\xe2\x02\xd6\xc4\xcfq&quot;\x1a\x14~2]4\x9f\xc9\x88\xf8\x12\xb6\xa2\xd7\xec\x0b\x7f\xd4d\xdc\xc6\xb4]\x10u\xc6f\x97m\xccA\x82\x02\xa5gh\x85\x85Wz\xd9.\xff\x9bx\x99J\x0e\x86\x16\x90\xad\x1e\x17\x86\x95\xb8S\x17\xea\x93v\xd0&#x27;</span></span><br><span class="line">ct = [ct[i:i+<span class="number">16</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(ct), <span class="number">16</span>)]</span><br><span class="line"></span><br><span class="line">plain = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(ct)):</span><br><span class="line">    cipher = AES.new(ct[i-<span class="number">1</span>], AES.MODE_ECB)</span><br><span class="line">    plain += cipher.decrypt(ct[i])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(plain)</span><br></pre></td></tr></table></figure>

<h2 id="安洵杯-2020-easyaes"><a href="#安洵杯-2020-easyaes" class="headerlink" title="[安洵杯 2020]easyaes"></a>[安洵杯 2020]easyaes</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> key <span class="keyword">import</span> key</span><br><span class="line"></span><br><span class="line">iv = flag.strip(<span class="string">b&#x27;d0g3&#123;&#x27;</span>).strip(<span class="string">b&#x27;&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">LENGTH = <span class="built_in">len</span>(key)</span><br><span class="line"><span class="keyword">assert</span> LENGTH == <span class="number">16</span></span><br><span class="line"></span><br><span class="line">hint = os.urandom(<span class="number">4</span>) * <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(bytes_to_long(hint)^bytes_to_long(key))</span><br><span class="line"></span><br><span class="line">msg = <span class="string">b&#x27;Welcome to this competition, I hope you can have fun today!!!!!!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypto</span>(<span class="params">message</span>):</span><br><span class="line">    aes = AES.new(key,AES.MODE_CBC,iv)</span><br><span class="line">    <span class="keyword">return</span> aes.encrypt(message)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(binascii.hexlify(encrypto(msg))[-<span class="number">32</span>:])</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">56631233292325412205528754798133970783633216936302049893130220461139160682777</span></span><br><span class="line"><span class="string">b&#x27;3c976c92aff4095a23e885b195077b66&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>求初始向量</p>
<p>首先注意到$key$和$hint$的长度不符，所以给的$hint$中有一半是原来<code>os.urandom(4)</code>的值。</p>
<p>可以通过这一特点恢复$key$</p>
<p>然后依次求前一块密文，最后求得iv</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.strxor <span class="keyword">import</span> strxor <span class="keyword">as</span> xor</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> unhexlify</span><br><span class="line"></span><br><span class="line">tmp = <span class="number">56631233292325412205528754798133970783633216936302049893130220461139160682777</span></span><br><span class="line"><span class="comment">#print(long_to_bytes(tmp))</span></span><br><span class="line">hint = <span class="string">b&#x27;&#125;4$d&#x27;</span>*<span class="number">8</span></span><br><span class="line"></span><br><span class="line">key = long_to_bytes(tmp^bytes_to_long(hint))</span><br><span class="line"></span><br><span class="line">msg = <span class="string">b&#x27;Welcome to this competition, I hope you can have fun today!!!!!!&#x27;</span></span><br><span class="line">cipher = <span class="string">&#x27;3c976c92aff4095a23e885b195077b66&#x27;</span></span><br><span class="line">c4 = <span class="built_in">bytes</span>.fromhex(cipher)</span><br><span class="line"></span><br><span class="line">msgblock = [msg[i*<span class="number">16</span>:(i+<span class="number">1</span>)*<span class="number">16</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(msg)//<span class="number">16</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">c</span>):</span><br><span class="line">    aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> aes.decrypt(c)</span><br><span class="line"></span><br><span class="line">c3 = xor(decrypt(c4),msgblock[<span class="number">3</span>])</span><br><span class="line">c2 = xor(decrypt(c3),msgblock[<span class="number">2</span>])</span><br><span class="line">c1 = xor(decrypt(c2),msgblock[<span class="number">1</span>])</span><br><span class="line">flag = <span class="string">b&#x27;NSSCTF&#123;&#x27;</span> + xor(decrypt(c1),msgblock[<span class="number">0</span>]) + <span class="string">b&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>



<h1 id="CTR模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h1><p><strong>计算器模式，CTR（Counter）</strong></p>
<p><img src="/../images/AES/CTR.png"></p>
<p><strong>在CTR模式中</strong><code>COUNTER</code><strong>是整个CTR模式的核心所在。它是由IV经过一定的规则之后生成的一段数据，长度与数据块的长度相等</strong></p>
<p><code>COUNTER</code><strong>通过ECB加密后得到一个</strong><code>COUNTER</code><strong>的密文，再和明文1进行异或得到密文1。在加密结束后</strong><code>COUNTER</code><strong>的值加1，然后再次用ECB加密，依次加密</strong></p>
<p>加密example：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Random <span class="keyword">import</span> get_random_bytes</span><br><span class="line"></span><br><span class="line">data = <span class="string">b&quot;secret&quot;</span></span><br><span class="line">key = get_random_bytes(<span class="number">16</span>)</span><br><span class="line">cipher = AES.new(key, AES.MODE_CTR)</span><br><span class="line">ct_bytes = cipher.encrypt(data)</span><br><span class="line">nonce = b64encode(cipher.nonce).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">ct = b64encode(ct_bytes).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">result = json.dumps(&#123;<span class="string">&#x27;nonce&#x27;</span>:nonce, <span class="string">&#x27;ciphertext&#x27;</span>:ct&#125;)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">&#123;<span class="string">&quot;nonce&quot;</span>: <span class="string">&quot;XqP8WbylRt0=&quot;</span>, <span class="string">&quot;ciphertext&quot;</span>: <span class="string">&quot;Mie5lqje&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>解密:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="comment"># We assume that the key was securely shared beforehand</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    b64 = json.loads(json_input)</span><br><span class="line">    nonce = b64decode(b64[<span class="string">&#x27;nonce&#x27;</span>])</span><br><span class="line">    ct = b64decode(b64[<span class="string">&#x27;ciphertext&#x27;</span>])</span><br><span class="line">    cipher = AES.new(key, AES.MODE_CTR, nonce=nonce)</span><br><span class="line">    pt = cipher.decrypt(ct)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The message was: &quot;</span>, pt)</span><br><span class="line"><span class="keyword">except</span> (ValueError, KeyError):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Incorrect decryption&quot;</span>)</span><br></pre></td></tr></table></figure>



<p><strong>这里给道ECB和CTR结合的题目</strong></p>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">from Crypto.Util import Counter</span><br><span class="line">from hashlib import sha256</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def padding(msg):</span><br><span class="line">    return msg + os.urandom(16 - len(msg) % 16)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">msg = b&quot;where is the flag? Key in my Heart/Counter!!!!&quot;</span><br><span class="line">key = b&quot;I w0nder how????&quot;</span><br><span class="line"></span><br><span class="line">assert len(msg) == 46</span><br><span class="line">assert len(key) == 16</span><br><span class="line"></span><br><span class="line">enc_key = os.urandom(16)</span><br><span class="line">initial_value = bytes_to_long(enc_key)</span><br><span class="line">hash = sha256(str(initial_value).encode()).hexdigest()</span><br><span class="line"></span><br><span class="line">aes = AES.new(enc_key, AES.MODE_ECB)</span><br><span class="line">enc_flag = aes.encrypt(padding(flag))</span><br><span class="line"></span><br><span class="line">ctr = Counter.new(AES.block_size * 8, initial_value=initial_value)</span><br><span class="line">aes = AES.new(key, counter=ctr, mode=AES.MODE_CTR)</span><br><span class="line">enc = aes.encrypt(msg)</span><br><span class="line"></span><br><span class="line">print(&quot;enc = &#123;&#125;&quot;.format(enc[-16:]))</span><br><span class="line">print(&quot;enc_flag = &#123;&#125;&quot;.format(enc_flag))</span><br><span class="line">print(&quot;hash = &#123;&#125;&quot;.format(hash))</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">enc = b&#x27;\xbe\x9bd\xc6\xd4=\x8c\xe4\x95bi\xbc\xe01\x0e\xb8&#x27;</span><br><span class="line">enc_flag = b&#x27;\xb2\x97\x83\x1dB\x13\x9b\xc2\x97\x9a\xa6+M\x19\xd74\xd2-\xc0\xb6\xba\xe8ZE\x0b:\x14\xed\xec!\xa1\x92\xdfZ\xb0\xbd\xb4M\xb1\x14\xea\xd8\xee\xbf\x83\x16g\xfa&#x27;</span><br><span class="line">hash = efb07225b3f1993113e104757210261083c79de50f577b3f0564368ee7b25eeb</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p><code>flag</code><strong>是用</strong><code>enc_key</code><strong>再用ECB模式加密的，我们的目的就是求出</strong><code>enc_key</code></p>
<p><strong>而</strong><code>enc_key</code><strong>和</strong><code>counter</code><strong>有关，所以我们需要求出</strong><code>counter</code><strong>的末值，再往前倒</strong></p>
<p><strong>先把msg分组，msg的长度是46，分为16，16，14三组</strong></p>
<p><strong>通过msg的后14位和enc的后14位进行异或得到加密后的</strong><code>enc_counter</code></p>
<p>这里需要注意的是：<strong>counter是通过ECB加密的</strong>，<strong>解出</strong><code>counter</code> <strong>之后，减去2就是初始的</strong><code>counter</code><strong>也就是</strong><code>initial_value</code></p>
<p><strong>解</strong><code>enc_counter</code><strong>的时候要填充，因为他只有14字节，要填充为16字节</strong></p>
<p><strong>得到</strong><code>initila_value</code><strong>之后就有了加密flag的</strong><code>enc_key</code><strong>，然后就是解ECB得到flag</strong></p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.strxor <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">key = <span class="string">b&quot;I w0nder how????&quot;</span></span><br><span class="line">msg = <span class="string">b&quot;where is the flag? Key in my Heart/Counter!!!!&quot;</span></span><br><span class="line">enc = <span class="string">b&#x27;\xbe\x9bd\xc6\xd4=\x8c\xe4\x95bi\xbc\xe01\x0e\xb8&#x27;</span></span><br><span class="line">enc_flag = <span class="string">b&#x27;\xb2\x97\x83\x1dB\x13\x9b\xc2\x97\x9a\xa6+M\x19\xd74\xd2-\xc0\xb6\xba\xe8ZE\x0b:\x14\xed\xec!\xa1\x92\xdfZ\xb0\xbd\xb4M\xb1\x14\xea\xd8\xee\xbf\x83\x16g\xfa&#x27;</span></span><br><span class="line"><span class="built_in">hash</span> = <span class="string">&#x27;efb07225b3f1993113e104757210261083c79de50f577b3f0564368ee7b25eeb&#x27;</span></span><br><span class="line"></span><br><span class="line">enc_counter = strxor(msg[-<span class="number">14</span>:],enc[-<span class="number">14</span>:])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> trange(<span class="number">2</span>**<span class="number">8</span>,<span class="number">2</span>**<span class="number">16</span>):         <span class="comment">#因为差了2个字节，就是2的8次方到2的16次方之间</span></span><br><span class="line">    pad = long_to_bytes(i)</span><br><span class="line">    Enc_counter = enc_counter + pad     <span class="comment">#填充之后再解</span></span><br><span class="line"></span><br><span class="line">    aes_ecb = AES.new(key,AES.MODE_ECB)</span><br><span class="line">    counter = aes_ecb.decrypt(Enc_counter)</span><br><span class="line">    initial_counter = bytes_to_long(counter) - <span class="number">2</span></span><br><span class="line">    hash_counter = sha256(<span class="built_in">str</span>(initial_counter).encode()).hexdigest()</span><br><span class="line">    <span class="keyword">if</span> hash_counter == <span class="built_in">hash</span>:</span><br><span class="line">        enc_key = long_to_bytes(initial_counter)</span><br><span class="line">        ECB = AES.new(enc_key,AES.MODE_ECB)</span><br><span class="line">        flag = ECB.decrypt(enc_flag)</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>现代密码-块密码</category>
      </categories>
      <tags>
        <tag>AES</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习</title>
    <url>/2023/08/09/Linux%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>每天学一点点</p>
<span id="more"></span>

<h1 id="Linux系统的文件"><a href="#Linux系统的文件" class="headerlink" title="Linux系统的文件"></a>Linux系统的文件</h1><h2 id="Linux系统的文件目录结构"><a href="#Linux系统的文件目录结构" class="headerlink" title="Linux系统的文件目录结构"></a>Linux系统的文件目录结构</h2><p><img src="/../images/Linux/0.png"></p>
<p><strong>bin</strong>：该目录中存储的是一些二进制文件，文件都是可以被运行的</p>
<p><strong>dev</strong>：该目录中存放的都是一些外接设备，例如盘，其他的光盘等。在其中的外接设备是不能直接被使用的，需要<strong>挂载(类似windows下的分配盘符)</strong></p>
<p><strong>etc</strong>：存储一些配置文件</p>
<p><strong>home</strong>：表示除了<strong>root用户以外其他用户的目录</strong>，类似于windows下的User目录</p>
<p><strong>proc</strong>：process，表示进程，该目录中存储的是Linux运行时候的进程。</p>
<p><strong>root</strong>：该目录是root用户自己的家目录</p>
<p><strong>sbin：</strong>全称super binary，该目录也是存储一些可以被执行的二进制文件，但是必须得有super权限的用户才能执行。</p>
<p><strong>tmp：</strong>表示“临时”的，当系统运行时候产生的临时文件会在这个目录存着。</p>
<p><strong>usr：</strong>存放的是用户自己安装的软件。类似于windows下的program files。</p>
<p><strong>var：</strong>存放的程序&#x2F;系统的日志文件的目录。 </p>
<p><strong>Mnt</strong>：当外接设备需要挂载的时候，就需要挂载到mnt目录下。</p>
<h2 id="Linux的文件类型"><a href="#Linux的文件类型" class="headerlink" title="Linux的文件类型"></a>Linux的文件类型</h2><h3 id="1-普通文件"><a href="#1-普通文件" class="headerlink" title="1.普通文件"></a>1.普通文件</h3><p>Linux中最多的一种文件类型, 包括 纯文本文件(ASCII)，二进制文件(binary)，数据格式的文件(data)，各种压缩文件。第一个属性为 [-]</p>
<h3 id="2-目录文件"><a href="#2-目录文件" class="headerlink" title="2.目录文件"></a>2.目录文件</h3><p>就是目录， 能用 cd 命令进入的。第一个属性为 [d]，例如 [drwxrwxrw]</p>
<h3 id="3-块设备文件"><a href="#3-块设备文件" class="headerlink" title="3.块设备文件"></a>3.块设备文件</h3><p>就是存储数据以供系统存取的接口设备，简单而言就是硬盘。例如一号硬盘的代码是 &#x2F;dev&#x2F;hda1等文件。第一个属性为 [b]</p>
<h3 id="4-字符设备"><a href="#4-字符设备" class="headerlink" title="4.字符设备"></a>4.字符设备</h3><p>字符设备文件：即串行端口的接口设备，例如键盘、鼠标等等。第一个属性为 [c]</p>
<h3 id="5-套接字文件"><a href="#5-套接字文件" class="headerlink" title="5.套接字文件"></a>5.套接字文件</h3><p>这类文件通常用在网络数据连接。可以启动一个程序来监听客户端的要求，客户端就可以通过套接字来进行数据通信。第一个属性为 [s]，最常在 &#x2F;var&#x2F;run目录中看到这种文件类型.</p>
<h3 id="6-管道文件"><a href="#6-管道文件" class="headerlink" title="6.管道文件"></a>6.管道文件</h3><p>FIFO也是一种特殊的文件类型，它主要的目的是，解决多个程序同时存取一个文件所造成的错误。FIFO是first-in-first-out(先进先出)的缩写。第一个属性为 [p]</p>
<h3 id="7-链接文件"><a href="#7-链接文件" class="headerlink" title="7.链接文件"></a>7.链接文件</h3><p>类似Windows下面的快捷方式。第一个属性为 [l]，例如 [lrwxrwxrw]</p>
]]></content>
  </entry>
  <entry>
    <title>Paillier算法</title>
    <url>/2023/08/23/Paillier%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>刷题过程中偶然涉及到Paillier算法</p>
<p>用博客的形式把他记录下来</p>
<span id="more"></span>

<p>Paillier算法属于半同态加密算法</p>
<h1 id="什么是同态加密-HE-？"><a href="#什么是同态加密-HE-？" class="headerlink" title="什么是同态加密(HE)？"></a>什么是同态加密(HE)？</h1><p>同态加密是一种特殊的加密方法，它允许直接对加密数据执行计算，如加法和乘法，而计算过程不会泄露原文的任何信息。计算的结果仍然是加密的，拥有密钥的用户对处理过的密文数据进行解密后，得到的正好是处理后原文的结果。</p>
<p>根据支持的计算类型和支持程度，同态加密可以分为以下三种类型：<strong>半同态加密</strong>，<strong>部分同态加密</strong>，<strong>全同态加密</strong></p>
<h2 id="半同态加密"><a href="#半同态加密" class="headerlink" title="半同态加密"></a>半同态加密</h2><p><strong>半同态加密</strong>(Partially Homomorphic Encryption, <strong>PHE</strong>)：只支持加法或乘法中的一种运算。其中，只支持加法运算的又叫加法同态加密（Additive Homomorphic Encryption, AHE），常见的有<strong>RSA</strong>，<strong>Elgamal</strong>，<strong>Paillier</strong></p>
<h2 id="部分同态加密"><a href="#部分同态加密" class="headerlink" title="部分同态加密"></a>部分同态加密</h2><p><strong>部分同态加密</strong>(Somewhat Homomorphic Encryption, <strong>SWHE</strong>)：可同时支持加法和乘法运算，但支持的计算次数有限</p>
<h2 id="全同态加密"><a href="#全同态加密" class="headerlink" title="全同态加密"></a>全同态加密</h2><p><strong>全同态加密</strong>(Fully Homomorphic Encryption, <strong>FHE</strong>)：支持任意次的加法和乘法运算</p>
<p>第一个满足加法和乘法同态的同态加密方法直到2009年才由Craig Gentry提出。目前来说，全同态加密算法性能较差，应用较少。比较常用的是半同态加密算法。</p>
<h1 id="Paillier算法"><a href="#Paillier算法" class="headerlink" title="Paillier算法"></a>Paillier算法</h1><h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><ol>
<li><p>随机选两个大素数$p,q$，满足$gcd(pq,(p-1)(q-1)) &#x3D; 1$，且$p,q$长度相同（安全性高一点）</p>
</li>
<li><p>计算$n &#x3D; pq$，以及$\lambda &#x3D; lcm(p-1,q-1)$，即$\lambda$是$p-1$和$q-1$的最小公倍数</p>
</li>
<li><p>随机选择$g \in Z_{n^2}^*$，表示$g$为$(0,n^2)$中的正整数，g还需满足$gcd(L(g^{\lambda} \mod n^2),n) &#x3D; 1$。后面发现$g &#x3D; n+1$满足条件，可以直接取$g &#x3D; n+1$</p>
</li>
<li><p>定义$L$函数：$L(x) &#x3D; \frac{x-1}{n}$，计算$\mu &#x3D; (L(g^{\lambda}\mod n^2))^{-1} \mod n$</p>
</li>
<li><p>公钥为$(n,g)$，私钥为$(\lambda,\mu)$</p>
</li>
</ol>
<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><ol>
<li><p>明文$m$，满足$m \in Z_n$</p>
</li>
<li><p>选择随机数$r$，满足$r \in Z_n^*$</p>
</li>
<li><p>计算密文$c &#x3D; g^mr^n \mod n^2$</p>
</li>
</ol>
<h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p>$m &#x3D; L(c^\lambda \mod n^2)×\mu \mod n$即$m &#x3D; \frac{L(c^\lambda \mod n^2)}{L(g^\lambda \mod n^2)} \mod n$</p>
<h2 id="解密的正确性"><a href="#解密的正确性" class="headerlink" title="解密的正确性"></a>解密的正确性</h2><p>根据二项式定理</p>
<p><img src="/../images/paper/2.png"></p>
<p>$\because g &#x3D; n+1,\therefore L(g^\lambda \mod n^2) &#x3D; \lambda$</p>
<p>$\therefore \mu &#x3D; (L(g^\lambda \mod n^2))^{-1} \mod n &#x3D; \lambda^{-1} \mod n$</p>
<p>$m&#x3D;L(c^\lambda \mod n^2)×\mu \mod n&#x3D; L((g^mr^n)^\lambda \mod n^2)× \lambda^{-1} \mod n$</p>
<p>又$\because L((g^mr^n)^\lambda \mod n^2) &#x3D; L(g^{\lambda m}r^{\lambda n} \mod n^2)$</p>
<p>而这个$\lambda n &#x3D; \frac{(p-1)(q-1)}{k}×pq$，其实就是$\frac{\phi(n^2)}{k}$</p>
<p>$\therefore L((g^mr^n)^\lambda \mod n^2) &#x3D; L(g^{\lambda m}r^{\lambda n} \mod n^2) &#x3D; \lambda m \mod n^2$</p>
<p>$\therefore m&#x3D;L(c^\lambda \mod n^2)×\mu \mod n&#x3D; L((g^mr^n)^\lambda \mod n^2)× \lambda^{-1} \mod n &#x3D; \lambda m ×\lambda^{-1} \mod n &#x3D; m$</p>
<h2 id="同态加法的性质"><a href="#同态加法的性质" class="headerlink" title="同态加法的性质"></a>同态加法的性质</h2><p>对于任意$m_1,m_2 \in Z_n$和任意$r_1,r_2 \in Z_n^*$</p>
<p>对应密文$c_1 &#x3D; E(m_1,r_1) &#x3D; g^{m_1}r_1^n$，$c_2 &#x3D; E(m_2,r_2) &#x3D; g^{m_2}r_2^{n}$</p>
<p>把密文作乘法$c &#x3D; c_1×c_2 &#x3D; g^{m_1+m_2}(r_1×r_2)^n \mod n^2$</p>
<p>把密文c解密得到的是$m_1+m_2$</p>
<p>即我们得到了：$c_1 × c_2 &#x3D; m_1 + m_2$，即密文乘等于明文加。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="NISACTF-2022-public"><a href="#NISACTF-2022-public" class="headerlink" title="[NISACTF 2022]public"></a>[NISACTF 2022]public</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">flag=<span class="string">b&quot;NSSCTF&#123;xxxxxxxxxxxxxxxxxxx&#125;&quot;</span></span><br><span class="line">p = getPrime(<span class="number">2048</span>)</span><br><span class="line">q = getPrime(<span class="number">2048</span>)</span><br><span class="line">n = p*q</span><br><span class="line">g = n+<span class="number">1</span></span><br><span class="line">flag = flag + os.urandom(<span class="number">256</span>)</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"><span class="keyword">assert</span> m &lt; n</span><br><span class="line">c=(<span class="built_in">pow</span>(g,p,n*n)*<span class="built_in">pow</span>(m,n,n*n))%(n*n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c=<span class="subst">&#123;<span class="built_in">str</span>(c)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n=<span class="subst">&#123;<span class="built_in">str</span>(n)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;hint=<span class="subst">&#123;<span class="built_in">str</span>(<span class="built_in">pow</span>(m,n,n*n))&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># c=</span></span><br><span class="line"><span class="comment"># n=</span></span><br><span class="line"><span class="comment"># hint=</span></span><br></pre></td></tr></table></figure>

<p>给出$hint \equiv m^n \mod n^2$</p>
<p>$\because c \equiv (g^p \mod n^2)×(m^n \mod n^2) \mod n^2$</p>
<p>可计算出$g^p \mod n^2$</p>
<p>$\because g &#x3D; n+1$</p>
<p>$\therefore g^p &#x3D; (n+1)^p &#x3D; n^p + n^{p-1} +… +n +1$</p>
<p>则$g^p \equiv \sum n^{奇数} + 1$ </p>
<p>则$g^p -1 &#x3D; (pq)^x +…+pq$，把它除去$n$以后（否则求出的公因数是n）再和$n$，求公因数得到p</p>
<p>又$\because hint \equiv m^n \mod n^2$</p>
<p>当作一个加密指数为$n$的RSA解密</p>
<p>解密指数$d$，应满足$nd \equiv 1 \mod n(p-1)(q-1)$</p>
<p>但这样求逆元是不存在的，我们转而求$nd \equiv 1 \mod (p-1)(q-1)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">c=<span class="number">218076151021560547051903316719541222512040541728274127251955864973204319200312422995983092104505370830336341646283643290975865810979693431665790610118752578450560322701464606111124759353729454729357651736630354926734261137232304018105525402480409214739463624926019853406667257471858400554068936984966255122726345392299611192889869061539625603262461395069803838256649227551122691722958477064737646079234633593322257264277828874899605785719884582898801922036376706945214557655573105936069927519342707813584133447394527727777145289236041783964596526172298751923527410923728437653793368452092818162677292173126395038239746952564824349029187021070624008127312777783389153721156471730690460245726539173442219919067086198412985379251064006364545842890512676104195964096685904104471607447579133813262242889948684214615216415152003486684332654021763372875688811108164167029372542655680239691864011325001804416649090546652965592245015233937378914902555020997254559783431091213187054225512285704706127222748135840936979571164239968858574619878355623067035562073147836429462588372618500946665592533980646179287203705864082701267348885216165672773119373427706470575290690902668785242467233967870570261108990892859880739698792351646244754952340844420919259404502699266393058426943569348443212550646905609608670176752388829848639990144513783071090027192962534454341704209113094332822171724354423757760205937173503650126923081671379294681026909824698111163520911268295889474804858820122835834292711776643387277793548733641809948674628119693459864760337483163877679917119388740268787073315582536101385769332216844206772200893152057186765390268976281904057200764887141067277637744939424349347335952574178492737111320884889894593413406720620482887249419382551684677812936351975305964980443771310389160311391859989139144435489943187361252326617436405569045786172471146825826484820533463066934499480104433398977611810330276369147938097117995654985458513989302241106332776904067311803420489090552556891879767682415265560743407340298578130798877648570926192953127574474259716781135801273211777116319348356510073635809816358623224620898024473581877733194648312939500788032519396047197931401057492369464362250728505049498537131676040902419082386902837490490020207391112191256297932073021141841637862479797419191517126847743253818063471644376196087415026020405982443713386674133996026381008967344619818015476575693412862275373303754013892689230528546297224836909468991043799205998787941893011</span></span><br><span class="line">n=<span class="number">508649864931677614732467390772427961758931524996950943172348989353779413500135745017318030372818346445171787306774776609051270954621980771071637593801560166625137373096310055034937710873339570248386417692379532713565448110999149898224125057983565314582568870217037082321220190178702247284057805478222196862321877126877541221804916630403210745798454726695767965708773814502024042373335280648703042654755304969849832318086242798067639199224298659205981289856966590499810461072473369452077687615913217546268362501813809748922922532657782215807173319693469430751556310985767810712372068465527832726893651833030643914873945580271625080157996808574695857605733101549978621472016493582602814890278818563043847095493265778824174731054566468708287724290549925230267719117266452407869862605078436659020887227224470196270187491398217001451889275579626459491632506953638949085966203707446055610214983015428316166700670710716910016807567113694397559364621848368518820842900845963635710936101678917277407976769668789284143702572735353391307624460327339616496606065042109014043456540221432729574605562610831787594345569772727113605355252600129915926507232161710531913156415953128254338208741867773085355435238760994755555830964013004019492562245961</span></span><br><span class="line">hint=<span class="number">218453179086923289943807203202770838925178689627774745147232020515098516891161432630028304346664762962142685215503546042472463188085210756898964960254583869432945520650866749585786670220495127010275938757711518963512690357966318771229029024139860779906436335668507703089169058834533472932888386221671186182247869434699020350251916212956639268455849140594527951127570312231046210122761381292092058171708887595484453711631828228850043342993869671675498781490707220852504338423236844200845629493885003815571053367960570828719514793961666314203716137708394529735950110878173175859966298104855781891314256393660478947857997049309347664916363312769426872393903240797057291513182057786294193463281179876929436423970304992964378978343703058273610599094670858299390115880959442514513002687898361714995376183382702580310860520166550246905769724461107221385567718477106980293610194354260662299313387637029454859051754049141731708862005007657254777005078937290648653252057172789665484106225904252249322285164277069353595858401391763857781471982430400812430485462777863701578165740021651239264400111602346875691919587562776319002092593590043298682899772829734368041057265219520645505796166918571599787733464916168997021422429642875880015201743138557239246816614645961943942384226721696842364578221142494114967457346538723563534281835490913459152865031135512888020156712332950698315471031328945767161582387501768383019764191345069522790270253976284543970378444427727423121536104008553289510510497088596599741651012409020454471902200942494893254608355219933431097693790764370965829619433976045850073467615077879096698409574487772631069225578624386542659818683559823001358916184145187794138636007200677181455572920942709512649217555102476437241677652845050079961562071604521307752725300453167225947534296744839161286409625003203181858982730609149419917332043428767843293277924022007390853988328511663307394805322715579362345649842431371200748639996476587970393904239732072852670279076966635546790856059886353247283187091483814130965265452117641315707359747672993447721009270939662160468115475733881984431822454194850017395548046798675473636140217840418467588166347095543815767317284635513061287105795015042775738353765062476084211922890124244419037796630154403434882572164730631883001098922170198642065216541425903144234820480236095640278292837060194123091442480170728800340689332104613912950234195039809087610879082689821270573215009809335626725761798981628604037461376378712686098</span></span><br><span class="line"></span><br><span class="line">inv_hint = gmpy2.invert(hint,n**<span class="number">2</span>)</span><br><span class="line">temp = c * inv_hint % n**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">p = gmpy2.gcd(n,(temp-<span class="number">1</span>)//n)</span><br><span class="line"></span><br><span class="line">q = n // p</span><br><span class="line">d = gmpy2.invert(n,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(hint,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>RSA3</title>
    <url>/2023/07/09/RSA3/</url>
    <content><![CDATA[<p><strong>少年的书桌上没有虚度的光阴</strong></p>
<span id="more"></span>

<p><strong>记录笔者RSA学习过程，继上篇</strong></p>
<h1 id="二十九、费马分解法"><a href="#二十九、费马分解法" class="headerlink" title="二十九、费马分解法"></a>二十九、费马分解法</h1><p><img src="/../images/RSA/35.png"></p>
<p><strong>eg:</strong></p>
<p><img src="/../images/RSA/36.png"></p>
<h2 id="1-n-p×p1×q×q1"><a href="#1-n-p×p1×q×q1" class="headerlink" title="1.n &#x3D; p×p1×q×q1"></a>1.n &#x3D; p×p1×q×q1</h2><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import uuid</span><br><span class="line">flag = &#x27;flag&#123;&#x27;+str(uuid.uuid4())+&quot;&#125;&quot;</span><br><span class="line">flag=flag.encode()</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">p = getPrime(512)</span><br><span class="line">p1 = gmpy2.next_prime(p)</span><br><span class="line">q= getPrime(512)</span><br><span class="line">q1= gmpy2.next_prime(q)</span><br><span class="line"></span><br><span class="line">n = p*q*p1*q1</span><br><span class="line">e = 0x10001</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = pow(m,e,n)</span><br><span class="line">print(&quot;c=&quot;,c)</span><br><span class="line">print(&quot;n=&quot;,n)</span><br><span class="line">c= 9949542934673249601822379710110536682375274333294212429688584989332571435120688962792756767799023906332576991820877786082142174075762351091472858450420524999000438499038246804892307015253501997557003507879115010365751701766309706931191167213901685725286428926861333201965004869326873632404052661985741631906479109023390455968199954361183959446992180809970004376995201084933073767278979855530735756096072840384641334181432769063314242300512881491103946010394543208395998872730145780806025267971492301568490427293141120807461902093932052106811061648537600125019831876736538658644780471805555396705702634885360657660235</span><br><span class="line">n= 14775235844515544576473611382698284004133861994231391972299917039113871334718108546717938305388267655285590882177982603418940337565701637106925368292676630781520319110700106306029357476649553934570683454139537943486518666101218072140043084858740684805876092240053196287287330188619164273915005792335974297620475140547828827559062269649682393716241864595363863867012095487700403514116433664086346056485373014640655316422588972338531776150881686013955605480910803097642414475309381073364181798620439167561641939844350252283317699576359402716770493658380425200603092475286870303441165147435503582004675788584686434009043</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">c= <span class="number">9949542934673249601822379710110536682375274333294212429688584989332571435120688962792756767799023906332576991820877786082142174075762351091472858450420524999000438499038246804892307015253501997557003507879115010365751701766309706931191167213901685725286428926861333201965004869326873632404052661985741631906479109023390455968199954361183959446992180809970004376995201084933073767278979855530735756096072840384641334181432769063314242300512881491103946010394543208395998872730145780806025267971492301568490427293141120807461902093932052106811061648537600125019831876736538658644780471805555396705702634885360657660235</span></span><br><span class="line">n= <span class="number">14775235844515544576473611382698284004133861994231391972299917039113871334718108546717938305388267655285590882177982603418940337565701637106925368292676630781520319110700106306029357476649553934570683454139537943486518666101218072140043084858740684805876092240053196287287330188619164273915005792335974297620475140547828827559062269649682393716241864595363863867012095487700403514116433664086346056485373014640655316422588972338531776150881686013955605480910803097642414475309381073364181798620439167561641939844350252283317699576359402716770493658380425200603092475286870303441165147435503582004675788584686434009043</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"></span><br><span class="line">a=gmpy2.iroot(n,<span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">lt=[]</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    a+=<span class="number">1</span></span><br><span class="line">    b2=<span class="built_in">pow</span>(a,<span class="number">2</span>)-n</span><br><span class="line">    <span class="keyword">if</span> gmpy2.is_square(b2):</span><br><span class="line">        tmp=[]</span><br><span class="line">        b=gmpy2.iroot(b2,<span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">        x1=a-b</span><br><span class="line">        x2=a+b</span><br><span class="line">        tmp.append(<span class="built_in">int</span>(x1))</span><br><span class="line">        tmp.append(<span class="built_in">int</span>(x2))</span><br><span class="line">        lt.append(tmp)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lt)&gt;=<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(lt)</span><br><span class="line"><span class="keyword">assert</span> lt[<span class="number">0</span>][<span class="number">1</span>]*lt[<span class="number">0</span>][<span class="number">0</span>]==n</span><br><span class="line"><span class="keyword">assert</span> lt[<span class="number">1</span>][<span class="number">1</span>]*lt[<span class="number">1</span>][<span class="number">0</span>]==n</span><br><span class="line">p=libnum.gcd(lt[<span class="number">0</span>][<span class="number">0</span>],lt[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="built_in">print</span>(gmpy2.is_prime(p))</span><br><span class="line">p1=gmpy2.next_prime(p)</span><br><span class="line"><span class="built_in">print</span>(p1)</span><br><span class="line">q=libnum.gcd(lt[<span class="number">0</span>][<span class="number">1</span>],lt[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(q)</span><br><span class="line"><span class="built_in">print</span>(gmpy2.is_prime(q))</span><br><span class="line">q1=gmpy2.next_prime(q)</span><br><span class="line"><span class="built_in">print</span>(q1)</span><br><span class="line"><span class="built_in">print</span>(n==p*p1*q*q1)</span><br><span class="line">phi=(p-<span class="number">1</span>)</span><br><span class="line">d=libnum.invmod(e,phi)</span><br><span class="line">m=<span class="built_in">pow</span>(c,d,p)</span><br><span class="line"><span class="built_in">print</span>(libnum.n2s(<span class="built_in">int</span>(m)))</span><br></pre></td></tr></table></figure>

<p><strong>遍历求出的x1是p,q,p1,q1任意两个数的积，因此后面需要用到gcd</strong></p>
<p><strong>最后phi &#x3D; (p-1)我不大理解</strong></p>
<h2 id="2-yafu无法分解"><a href="#2-yafu无法分解" class="headerlink" title="2.yafu无法分解"></a>2.yafu无法分解</h2><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import uuid</span><br><span class="line">flag = &#x27;flag&#123;&#x27;+str(uuid.uuid4())+&quot;&#125;&quot;</span><br><span class="line">flag=flag.encode()</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">p = getPrime(2048)</span><br><span class="line">q = gmpy2.next_prime(p)</span><br><span class="line">for i in range(3600):</span><br><span class="line">    if i%100 ==0:</span><br><span class="line">        print(i)</span><br><span class="line">        q = gmpy2.next_prime(q)</span><br><span class="line"></span><br><span class="line">n = p * q</span><br><span class="line">e = 0x10001</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = pow(m,e,n)</span><br><span class="line">print(&quot;c=&quot;,c)</span><br><span class="line">print(&quot;n=&quot;,n)</span><br><span class="line"></span><br><span class="line">c= 672211618947965669743140453815925311571913536792006320455451623329504768032653294195423386000169883889423130760702613901378226812991253672513808102582219125394975375184975680670477893616071731840578283372003364948041569480819988957797304000908767353945393438677325246806404776535366574244075168385686413998057429677446479345637389931707590541292174569539214514406772616679574446429577154994658300264395963743399028585579405127133850937684035755385536903177249615680095525438385801267848518932540742850864828339907387436386589615141301315094268048540705754105909152114279580297245086066527476038499949395262133426884691004953583259542925926790804058362169131721101062567084072161757158556850613589003126629288335943625835227353239228779420777075183829735033060565964497198340990191457681711972006273381600852029426480042505732976038791175365941723190939561137761147915067500934001302644947570092730510410631121938241136026914524548262047531029183007578603005500736114268512900086177419819102734670936080786880709408049475188517563383396936699006425388577265810859020768191320288121742321413664684223757832512232195144286087827718142083017087556701405737637649721698260338198824299502881114161665693663517201464044647997804424204974158</span><br><span class="line">n= 720239742676276892125180297266754203107040753393792061819109788620051632698640388878164710563582551395398417339060158866293057237682628696160289176629921331485290769277668335946098043360398735897380648863281934217401247716885835600015902679721336644611726200751169780657177537142181503044265719975692160293076414714427014863104317576606190229434103615882007838099640939570363751985038883738622768287033043747426059699658000045440922380571398371705698665874788485742224933932126886052739997477581453575568873105033061557099207861338425715849944147722082093066073450898210944979122392845654525731562948599513722685350626329020621203929679566003766926450933409172107168029480058053562850582746440505733686649603099598891890233020681944859657534362524449703843503708875743380789764830334189231182948902486001101574574542624002055351308194659501208428214278013747062791484983332159726081847473539435746845527406013789541657402799211822281010775911725885529125479685615597338584834382753602860489834851310346307067835494249861848527198787408591551265511901573927692939919503175252790601381174213220684859419625471536435635703766410175026305548524401754345447084444023478365533640647989603192253820896160603674343007718854266899300948742261</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>用费马分解法求出p</strong></p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">c= <span class="number">672211618947965669743140453815925311571913536792006320455451623329504768032653294195423386000169883889423130760702613901378226812991253672513808102582219125394975375184975680670477893616071731840578283372003364948041569480819988957797304000908767353945393438677325246806404776535366574244075168385686413998057429677446479345637389931707590541292174569539214514406772616679574446429577154994658300264395963743399028585579405127133850937684035755385536903177249615680095525438385801267848518932540742850864828339907387436386589615141301315094268048540705754105909152114279580297245086066527476038499949395262133426884691004953583259542925926790804058362169131721101062567084072161757158556850613589003126629288335943625835227353239228779420777075183829735033060565964497198340990191457681711972006273381600852029426480042505732976038791175365941723190939561137761147915067500934001302644947570092730510410631121938241136026914524548262047531029183007578603005500736114268512900086177419819102734670936080786880709408049475188517563383396936699006425388577265810859020768191320288121742321413664684223757832512232195144286087827718142083017087556701405737637649721698260338198824299502881114161665693663517201464044647997804424204974158</span></span><br><span class="line">n= <span class="number">720239742676276892125180297266754203107040753393792061819109788620051632698640388878164710563582551395398417339060158866293057237682628696160289176629921331485290769277668335946098043360398735897380648863281934217401247716885835600015902679721336644611726200751169780657177537142181503044265719975692160293076414714427014863104317576606190229434103615882007838099640939570363751985038883738622768287033043747426059699658000045440922380571398371705698665874788485742224933932126886052739997477581453575568873105033061557099207861338425715849944147722082093066073450898210944979122392845654525731562948599513722685350626329020621203929679566003766926450933409172107168029480058053562850582746440505733686649603099598891890233020681944859657534362524449703843503708875743380789764830334189231182948902486001101574574542624002055351308194659501208428214278013747062791484983332159726081847473539435746845527406013789541657402799211822281010775911725885529125479685615597338584834382753602860489834851310346307067835494249861848527198787408591551265511901573927692939919503175252790601381174213220684859419625471536435635703766410175026305548524401754345447084444023478365533640647989603192253820896160603674343007718854266899300948742261</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">a = gmpy2.iroot(n,<span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line">    b2 = <span class="built_in">pow</span>(a,<span class="number">2</span>)-n</span><br><span class="line">    <span class="keyword">if</span> gmpy2.is_square(b2):</span><br><span class="line">        b = gmpy2.iroot(b2,<span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">        p = a+b</span><br><span class="line">        q = n // p</span><br><span class="line">        d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">        m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line">        </span><br><span class="line"><span class="comment">#b&#x27;flag&#123;e45a7d01-2639-4d21-830d-4fe00c5d69d9&#125;&#x27;</span></span><br></pre></td></tr></table></figure>



<h1 id="三十、pow-m-p-n-和pow-m-q-n"><a href="#三十、pow-m-p-n-和pow-m-q-n" class="headerlink" title="三十、pow(m,p,n)和pow(m,q,n)"></a>三十、pow(m,p,n)和pow(m,q,n)</h1><h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m=libnum.s2n(flag)</span><br><span class="line">p=libnum.generate_prime(512)</span><br><span class="line">q=libnum.generate_prime(512)</span><br><span class="line">n=p*q</span><br><span class="line">x=pow(m,p,n)</span><br><span class="line">y=pow(m,q,n)</span><br><span class="line">print(&quot;n=&quot;,n)</span><br><span class="line">print(&quot;x=&quot;,x)</span><br><span class="line">print(&quot;y=&quot;,y)</span><br><span class="line">n= 49134891668897345591333219711303339144007670596441894829337290952093400283298630665826095289165809681961208520996265436195389904640720636719133734406693433810554096598929737422594980883724481297143537076662178576926253446582535294294231165454562659420944920445437433494540727083960515996626310138062984512331</span><br><span class="line">x= 24898114380189083075249478644617176345363769858290571489415603903447660857572376734333314388004344067870622511211551400003900882292855408080408530612898712604821849194436116203045876702326786310101264912258598823736415425063797050123512802647807994402065186878212852202204820369988512984137386942003350601013</span><br><span class="line">y= 16329839654620902472571665649919967371160409036961382290481165859731193710305989211665714814452109039568075053785039634104665516076749524765980529291699849764465433749870986860914147427598112865371747917109336808548762214669827404524571735460653099723747061723390924856171469660835909151652929700638010039801</span><br></pre></td></tr></table></figure>

<h3 id="推导1"><a href="#推导1" class="headerlink" title="推导1"></a>推导1</h3><p><img src="/../images/RSA/37.png"></p>
<p><strong>求公因数得到p</strong></p>
<p><strong>留意一下密文是x和加密密钥是p或者y和q</strong></p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n= <span class="number">49134891668897345591333219711303339144007670596441894829337290952093400283298630665826095289165809681961208520996265436195389904640720636719133734406693433810554096598929737422594980883724481297143537076662178576926253446582535294294231165454562659420944920445437433494540727083960515996626310138062984512331</span></span><br><span class="line">x= <span class="number">24898114380189083075249478644617176345363769858290571489415603903447660857572376734333314388004344067870622511211551400003900882292855408080408530612898712604821849194436116203045876702326786310101264912258598823736415425063797050123512802647807994402065186878212852202204820369988512984137386942003350601013</span></span><br><span class="line">y= <span class="number">16329839654620902472571665649919967371160409036961382290481165859731193710305989211665714814452109039568075053785039634104665516076749524765980529291699849764465433749870986860914147427598112865371747917109336808548762214669827404524571735460653099723747061723390924856171469660835909151652929700638010039801</span></span><br><span class="line"></span><br><span class="line">tmp = <span class="built_in">pow</span>(x,n,n)-y</span><br><span class="line">p = gmpy2.gcd(tmp,n)</span><br><span class="line">q = n // p</span><br><span class="line">d1 = gmpy2.invert(p,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m1 = <span class="built_in">pow</span>(x,d1,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m1))</span><br><span class="line"></span><br><span class="line">d2 = gmpy2.invert(q,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m2 = <span class="built_in">pow</span>(y,d2,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m2))</span><br></pre></td></tr></table></figure>

<h3 id="推导2"><a href="#推导2" class="headerlink" title="推导2"></a>推导2</h3><p><img src="/../images/RSA/38.png"></p>
<p><strong>根据最后一个式子解方程即可</strong></p>
<p><strong>exp:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">n= 49134891668897345591333219711303339144007670596441894829337290952093400283298630665826095289165809681961208520996265436195389904640720636719133734406693433810554096598929737422594980883724481297143537076662178576926253446582535294294231165454562659420944920445437433494540727083960515996626310138062984512331</span><br><span class="line">x= 24898114380189083075249478644617176345363769858290571489415603903447660857572376734333314388004344067870622511211551400003900882292855408080408530612898712604821849194436116203045876702326786310101264912258598823736415425063797050123512802647807994402065186878212852202204820369988512984137386942003350601013</span><br><span class="line">y= 16329839654620902472571665649919967371160409036961382290481165859731193710305989211665714814452109039568075053785039634104665516076749524765980529291699849764465433749870986860914147427598112865371747917109336808548762214669827404524571735460653099723747061723390924856171469660835909151652929700638010039801</span><br><span class="line"></span><br><span class="line">R.&lt;m&gt; = PolynomialRing(Zmod(n))</span><br><span class="line"></span><br><span class="line">f = m**2 + x*y -(x+y)*m</span><br><span class="line">f = f.monic()</span><br><span class="line">root = f.small_roots(X=2^430)</span><br><span class="line">if root:</span><br><span class="line">    print(long_to_bytes(int(root[0])))</span><br><span class="line">else:</span><br><span class="line">    print(0)</span><br></pre></td></tr></table></figure>

<p><strong>不太明白这个上界为什么取的2^430</strong></p>
<h1 id="三十一、leak-n-p-q-1"><a href="#三十一、leak-n-p-q-1" class="headerlink" title="三十一、leak &#x3D; (n+p) % (q-1)"></a>三十一、leak &#x3D; (n+p) % (q-1)</h1><h2 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m=libnum.s2n(flag)</span><br><span class="line">p=libnum.generate_prime(512)</span><br><span class="line">q=libnum.generate_prime(512)</span><br><span class="line">if p &lt;= q:</span><br><span class="line">    p, q = q, p</span><br><span class="line">e = 0x10001</span><br><span class="line">n = p * q</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">leak = (n + p) % (q-1)</span><br><span class="line">print(f&#x27;&#123;e = &#125;&#x27;)</span><br><span class="line">print(f&#x27;&#123;c = &#125;&#x27;)</span><br><span class="line">print(f&#x27;&#123;n = &#125;&#x27;)</span><br><span class="line">print(f&#x27;&#123;leak = &#125;&#x27;)</span><br><span class="line"></span><br><span class="line">#e = 65537</span><br><span class="line">#c = 846622880180923496523897101093587388412673197929101816777894080453907929979417582433675846206418833989406082027835614960931951892393700870678469052366477889491688459558189367255658278968722099012534045477993924284003153851171132420751750724394405070269223797513951991873714156884423926582172189394011114952</span><br><span class="line">#n = 159452716285492879108396025652299064897348745847754101475050126796260046052685162344131542880739092630022413124977374334652652450809186959288635651980201026825896903174847709657312399801033678426271413442323084354665643010763178857967804623680894444913369256168333223214048037661178587978535722147091129404833</span><br><span class="line">#leak = 2669103705669857828725305123419482758456336465207378766363532584323475128597302561377245054918781031448710846825859151788151496659511563529987056456136018</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../images/RSA/39.png"></p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> solve,symbols</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">846622880180923496523897101093587388412673197929101816777894080453907929979417582433675846206418833989406082027835614960931951892393700870678469052366477889491688459558189367255658278968722099012534045477993924284003153851171132420751750724394405070269223797513951991873714156884423926582172189394011114952</span></span><br><span class="line">n = <span class="number">159452716285492879108396025652299064897348745847754101475050126796260046052685162344131542880739092630022413124977374334652652450809186959288635651980201026825896903174847709657312399801033678426271413442323084354665643010763178857967804623680894444913369256168333223214048037661178587978535722147091129404833</span></span><br><span class="line">leak = <span class="number">2669103705669857828725305123419482758456336465207378766363532584323475128597302561377245054918781031448710846825859151788151496659511563529987056456136018</span></span><br><span class="line"></span><br><span class="line">p = symbols(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">q = symbols(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line"></span><br><span class="line">eq1 = <span class="number">2</span>*(p-q+<span class="number">1</span>) - leak</span><br><span class="line">eq2 = p*q - n</span><br><span class="line"></span><br><span class="line">solution = solve((eq1,eq2),(p,q))</span><br><span class="line"><span class="built_in">print</span>(solution)</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">int</span>(solution[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">q = <span class="built_in">int</span>(solution[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>

<h1 id="三十二、leak-d-p-q"><a href="#三十二、leak-d-p-q" class="headerlink" title="三十二、leak &#x3D; d+p+q"></a>三十二、leak &#x3D; d+p+q</h1><h2 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m=libnum.s2n(flag)</span><br><span class="line">p=libnum.generate_prime(512)</span><br><span class="line">q=libnum.generate_prime(512)</span><br><span class="line"></span><br><span class="line">e = 0x10001</span><br><span class="line">n = p * q</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">d=libnum.invmod(e,(p-1)*(q-1))</span><br><span class="line">leak = d+p+q</span><br><span class="line">print(f&#x27;&#123;e = &#125;&#x27;)</span><br><span class="line">print(f&#x27;&#123;c = &#125;&#x27;)</span><br><span class="line">print(f&#x27;&#123;n = &#125;&#x27;)</span><br><span class="line">print(f&#x27;&#123;leak = &#125;&#x27;)</span><br><span class="line"></span><br><span class="line">#e = 65537</span><br><span class="line">#c = 65194823373091792824101730983124740337276083358867621564067880339279446092377567969207237986613196892737474455781661885696122256698478429450971196633786693648866129636737262041654769618993094832127875251068775632567036646408374963058703320605733921797230106462440860984746880466416824674570639694481298708147</span><br><span class="line">#n = 101929257180069933443442160085713121307068880188090652033345240568607589666231813199686824369361640378636124324844158355533056421197926269617986872835671463371353540696806173813019752742218460997272803573114119876536384486655117245296360474103378827486280279523273344156760793016731778663058274770626116861407</span><br><span class="line">#leak = 87007773233816810147344015772388866522443114032719766646343787373996588014373656496789294836431302130125588646180886383013958151442324020038131736683796464202667423644714259545194662934238144990354387370533656134036753530002005551694211595695927699196016268145816389892292091218491443784193805171731592693841</span><br></pre></td></tr></table></figure>

<p><img src="/../images/RSA/40.png"></p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">65194823373091792824101730983124740337276083358867621564067880339279446092377567969207237986613196892737474455781661885696122256698478429450971196633786693648866129636737262041654769618993094832127875251068775632567036646408374963058703320605733921797230106462440860984746880466416824674570639694481298708147</span></span><br><span class="line">n = <span class="number">101929257180069933443442160085713121307068880188090652033345240568607589666231813199686824369361640378636124324844158355533056421197926269617986872835671463371353540696806173813019752742218460997272803573114119876536384486655117245296360474103378827486280279523273344156760793016731778663058274770626116861407</span></span><br><span class="line">leak = <span class="number">87007773233816810147344015772388866522443114032719766646343787373996588014373656496789294836431302130125588646180886383013958151442324020038131736683796464202667423644714259545194662934238144990354387370533656134036753530002005551694211595695927699196016268145816389892292091218491443784193805171731592693841</span></span><br><span class="line"></span><br><span class="line">m = <span class="built_in">pow</span>(c,leak-n-<span class="number">1</span>,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>



<h1 id="三十三、leak-pow-p-q-n-pow-q-p-n-n"><a href="#三十三、leak-pow-p-q-n-pow-q-p-n-n" class="headerlink" title="三十三、leak &#x3D; pow(p,q,n)+pow(q,p,n)%n"></a>三十三、leak &#x3D; pow(p,q,n)+pow(q,p,n)%n</h1><h2 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h2><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m=libnum.s2n(flag)</span><br><span class="line">p=libnum.generate_prime(512)</span><br><span class="line">q=libnum.generate_prime(512)</span><br><span class="line"></span><br><span class="line">e = 0x10001</span><br><span class="line">n = p * q</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">leak = (pow(p, q, n) + pow(q, p, n)) % n</span><br><span class="line">print(f&#x27;&#123;e = &#125;&#x27;)</span><br><span class="line">print(f&#x27;&#123;c = &#125;&#x27;)</span><br><span class="line">print(f&#x27;&#123;n = &#125;&#x27;)</span><br><span class="line">print(f&#x27;&#123;leak = &#125;&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="/../images/RSA/42.png"></p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> symbols,solve</span><br><span class="line"></span><br><span class="line">p = symbols(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">q = symbols(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">59662555342583061013008608133060203475725526601468647442902301335538953096485921516133656618941085620436784211565880744663573927593670579237831797055934897166262528476227281479029026508166848256301828084036716500159067642101104810756620735383857351274773983199968924981397675373272878756685629789497697821620</span></span><br><span class="line">n = <span class="number">83332115751539889489689110273690067288993797655970253065863170986174973047785854940017477990345318506407680986257706329521142524295434171889087917406552261883625775754882538291980506944585738241124811588555071095223782766762626040473256423491630224616140407276984106458673447870374272906086783555489477673207</span></span><br><span class="line">leak = <span class="number">18881487897809480964326513919135880296801378921812225600834164247018332292886076618571738627353925482046410714540439662613766662197119044934743578662330528</span></span><br><span class="line"></span><br><span class="line">eq1 = p + q - leak</span><br><span class="line">eq2 = p * q - n</span><br><span class="line"></span><br><span class="line">solution = solve((eq1,eq2),(p,q))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> solution:</span><br><span class="line">    p,q = <span class="built_in">int</span>(i[<span class="number">0</span>]),<span class="built_in">int</span>(i[<span class="number">1</span>])</span><br><span class="line">    d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">    m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>



<p><strong>考点三十一，三十二，三十三来自2023 数据安全产业人才能力挑战赛—math_exam</strong></p>
<h2 id="2023数据安全产业人才能力挑战赛——math-exam"><a href="#2023数据安全产业人才能力挑战赛——math-exam" class="headerlink" title="2023数据安全产业人才能力挑战赛——math_exam"></a>2023数据安全产业人才能力挑战赛——math_exam</h2><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">bits = 512</span><br><span class="line"></span><br><span class="line">def pad(msg, length):</span><br><span class="line">    pad_length = length - len(msg) - 1</span><br><span class="line">    pad_data = os.urandom(pad_length)</span><br><span class="line">    return msg + b&#x27;\x00&#x27; + pad_data</span><br><span class="line"></span><br><span class="line">def unpad(msg):</span><br><span class="line">    return msg.split(b&quot;\x00&quot;)[0]</span><br><span class="line"></span><br><span class="line">def challenge1(m):</span><br><span class="line">    p, q = [getPrime(bits) for i in range(2)]</span><br><span class="line">    if p &lt;= q:</span><br><span class="line">        p, q = q, p</span><br><span class="line">    e = 0x10001</span><br><span class="line">    n = p * q</span><br><span class="line">    c = pow(m, e, n)</span><br><span class="line">    leak = (n + p) % (q-1)</span><br><span class="line">    print(&#x27;-------- challenge 1 --------&#x27;)</span><br><span class="line">    print(f&#x27;&#123;e = &#125;&#x27;)</span><br><span class="line">    print(f&#x27;&#123;c = &#125;&#x27;)</span><br><span class="line">    print(f&#x27;&#123;n = &#125;&#x27;)</span><br><span class="line">    print(f&#x27;&#123;leak = &#125;&#x27;)</span><br><span class="line"></span><br><span class="line">def challenge2(m):</span><br><span class="line">    p, q = [getPrime(bits) for i in range(2)]</span><br><span class="line">    e = 0x10001</span><br><span class="line">    n = p * q</span><br><span class="line">    d = inverse(e, (p-1)*(q-1))</span><br><span class="line">    c = pow(m, e, n)</span><br><span class="line">    leak = d + p + q</span><br><span class="line">    print(&#x27;-------- challenge 2 --------&#x27;)</span><br><span class="line">    print(f&#x27;&#123;e = &#125;&#x27;)</span><br><span class="line">    print(f&#x27;&#123;c = &#125;&#x27;)</span><br><span class="line">    print(f&#x27;&#123;n = &#125;&#x27;)</span><br><span class="line">    print(f&#x27;&#123;leak = &#125;&#x27;)</span><br><span class="line"></span><br><span class="line">def challenge3(m):</span><br><span class="line">    p, q = [getPrime(bits) for i in range(2)]</span><br><span class="line">    e = 0x10001</span><br><span class="line">    n = p * q</span><br><span class="line">    c = pow(m, e, n)</span><br><span class="line">    leak = (pow(p, q, n) + pow(q, p, n)) % n</span><br><span class="line">    print(&#x27;-------- challenge 3 --------&#x27;)</span><br><span class="line">    print(f&#x27;&#123;e = &#125;&#x27;)</span><br><span class="line">    print(f&#x27;&#123;c = &#125;&#x27;)</span><br><span class="line">    print(f&#x27;&#123;n = &#125;&#x27;)</span><br><span class="line">    print(f&#x27;&#123;leak = &#125;&#x27;)</span><br><span class="line"></span><br><span class="line">assert len(flag) == 42</span><br><span class="line">ms = []</span><br><span class="line">for i in range(0, 42, 14):</span><br><span class="line">    ms.append(bytes_to_long(pad(flag[i:i+14], bits//4-1)))</span><br><span class="line"></span><br><span class="line">m1, m2, m3 = ms</span><br><span class="line">challenge1(m1)</span><br><span class="line">challenge2(m2)</span><br><span class="line">challenge3(m3)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">-------- challenge 1 --------</span><br><span class="line">e = 65537</span><br><span class="line">c = 112742443814287255411540092433156061065388404049949520959549377871297566383025041892192679147481155020865118811016470498351633875090973546567374001852295013083192495299811476604405637385307524194793969533646755764136014187430115618114840780368311166911900457224593131166970676797547489278410997707815915932756</span><br><span class="line">n = 121127425328043404860413278637978444801342472819958112597540188142689720655042880213001676368390521140660355813910726809125567752172921410143437643574528335234973793653775043030021036875866776532570781661875022102733555943967261003246543180935987772711036868216508554536086688819118597075508026787867088355603</span><br><span class="line">leak = 216638862637129382765636503118049146067015523924032194492700294200289728064297722088882791754351329407138196573832392846467607399504585045028165699421278</span><br><span class="line">-------- challenge 2 --------</span><br><span class="line">e = 65537</span><br><span class="line">c = 7964477910021153997178145480752641882728907630831216554750778499596527781702830885213467912351097301767341858663701574005489585561370961723264247818377063081744522471774208105250855114831033452448184392499682147532404562876275189577321587660597603848038824026981539659156304028998137796242331160312370913038</span><br><span class="line">n = 140571013522095816880929287025269553867630639381779595547026503691829940612178900269986625350464874598461222087427155791855120339533208468121389480964471710028253589422629569889402475311387750348466199387760629889238062977271925350490110043385800605640905324122017637306715108727700910035925728362455954862209</span><br><span class="line">leak = 58442382248753295429370894053397615609981110383986887405127350139482893508400422595729520437678203735054593866306478994471465948872565590901376309380029015549809468112086393107585011072503638322671608471684607214064187044372418770555236721845694224676090744181562673509234801011420696349507624867568099759003</span><br><span class="line">-------- challenge 3 --------</span><br><span class="line">e = 65537</span><br><span class="line">c = 54161995127842474543974770981473422085334044100057089719350274921419091368361244533281599379235907845996678762379778310924192757650322930707785543132446159092950451255660204858292974657119337026589911330412367633761103944916751660957776230135927005700707688661350641600954072696774954805514477330339449799540</span><br><span class="line">n = 88207747624007183083381863279444163105330473097729276113333026679597864128605555600000789783468271680476780366740448641311570797876037993255307716167149079618302706650018518487351604778857406170722209469765782625409279109832638886179654096975665134276856272488090272822541461702907181545730309689190333058151</span><br><span class="line">leak = 19596671928335648228117128090384865424885102632642665068992144783391306491716530155291726644158221224616817878768426330717188403310818678195631582453246848</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> symbols,solve</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c1 = <span class="number">112742443814287255411540092433156061065388404049949520959549377871297566383025041892192679147481155020865118811016470498351633875090973546567374001852295013083192495299811476604405637385307524194793969533646755764136014187430115618114840780368311166911900457224593131166970676797547489278410997707815915932756</span></span><br><span class="line">n1 = <span class="number">121127425328043404860413278637978444801342472819958112597540188142689720655042880213001676368390521140660355813910726809125567752172921410143437643574528335234973793653775043030021036875866776532570781661875022102733555943967261003246543180935987772711036868216508554536086688819118597075508026787867088355603</span></span><br><span class="line">leak1 = <span class="number">216638862637129382765636503118049146067015523924032194492700294200289728064297722088882791754351329407138196573832392846467607399504585045028165699421278</span></span><br><span class="line"></span><br><span class="line">p1 = symbols(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">q1 = symbols(<span class="string">&#x27;q1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">eq1 = <span class="number">2</span>*(p1-q1+<span class="number">1</span>)-leak1</span><br><span class="line">eq2 = p1 * q1- n1</span><br><span class="line"></span><br><span class="line">solution1 = solve((eq1,eq2),(p1,q1))</span><br><span class="line"></span><br><span class="line">p1,q1 = <span class="built_in">int</span>(solution1[<span class="number">1</span>][<span class="number">0</span>]),<span class="built_in">int</span>(solution1[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">d1 = gmpy2.invert(e,(p1-<span class="number">1</span>)*(q1-<span class="number">1</span>))</span><br><span class="line">m1 = <span class="built_in">pow</span>(c1,d1,n1)</span><br><span class="line">flag1 = long_to_bytes(m1)[:<span class="number">14</span>]</span><br><span class="line"></span><br><span class="line">c2 = <span class="number">7964477910021153997178145480752641882728907630831216554750778499596527781702830885213467912351097301767341858663701574005489585561370961723264247818377063081744522471774208105250855114831033452448184392499682147532404562876275189577321587660597603848038824026981539659156304028998137796242331160312370913038</span></span><br><span class="line">n2 = <span class="number">140571013522095816880929287025269553867630639381779595547026503691829940612178900269986625350464874598461222087427155791855120339533208468121389480964471710028253589422629569889402475311387750348466199387760629889238062977271925350490110043385800605640905324122017637306715108727700910035925728362455954862209</span></span><br><span class="line">leak2 = <span class="number">58442382248753295429370894053397615609981110383986887405127350139482893508400422595729520437678203735054593866306478994471465948872565590901376309380029015549809468112086393107585011072503638322671608471684607214064187044372418770555236721845694224676090744181562673509234801011420696349507624867568099759003</span></span><br><span class="line"></span><br><span class="line">tmp = leak2 - n2 -<span class="number">1</span></span><br><span class="line">m2 = <span class="built_in">pow</span>(c2,tmp,n2)</span><br><span class="line">flag2 = long_to_bytes(m2)[:<span class="number">14</span>]</span><br><span class="line"></span><br><span class="line">c3 = <span class="number">54161995127842474543974770981473422085334044100057089719350274921419091368361244533281599379235907845996678762379778310924192757650322930707785543132446159092950451255660204858292974657119337026589911330412367633761103944916751660957776230135927005700707688661350641600954072696774954805514477330339449799540</span></span><br><span class="line">n3 = <span class="number">88207747624007183083381863279444163105330473097729276113333026679597864128605555600000789783468271680476780366740448641311570797876037993255307716167149079618302706650018518487351604778857406170722209469765782625409279109832638886179654096975665134276856272488090272822541461702907181545730309689190333058151</span></span><br><span class="line">leak3 = <span class="number">19596671928335648228117128090384865424885102632642665068992144783391306491716530155291726644158221224616817878768426330717188403310818678195631582453246848</span></span><br><span class="line"></span><br><span class="line">p3 = symbols(<span class="string">&#x27;p3&#x27;</span>)</span><br><span class="line">q3 = symbols(<span class="string">&#x27;q3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">eq3 = p3 + q3 - leak3</span><br><span class="line">eq4 = p3 * q3 - n3</span><br><span class="line"></span><br><span class="line">solution3 = solve((eq3,eq4),(p3,q3))</span><br><span class="line"></span><br><span class="line">p3,q3 = <span class="built_in">int</span>(solution3[<span class="number">0</span>][<span class="number">0</span>]),<span class="built_in">int</span>(solution3[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">d3 = gmpy2.invert(e,(p3-<span class="number">1</span>)*(q3-<span class="number">1</span>))</span><br><span class="line">m3 = <span class="built_in">pow</span>(c3,d3,n3)</span><br><span class="line">flag3 = long_to_bytes(m3)[:<span class="number">14</span>]</span><br><span class="line"></span><br><span class="line">flag = flag1 + flag2 + flag3</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>



<h1 id="三十四、扩展欧几里得求逆元d1-d2"><a href="#三十四、扩展欧几里得求逆元d1-d2" class="headerlink" title="三十四、扩展欧几里得求逆元d1-d2"></a>三十四、扩展欧几里得求逆元d1-d2</h1><h2 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">import uuid</span><br><span class="line">flag = &#x27;flag&#123;&#x27;+str(uuid.uuid4())+&quot;&#125;&quot;</span><br><span class="line">print(flag)</span><br><span class="line">flag1=flag[:21]</span><br><span class="line">flag2=flag[21:]</span><br><span class="line">m1=libnum.s2n(flag1)</span><br><span class="line">m2=libnum.s2n(flag2)</span><br><span class="line"></span><br><span class="line">p = getPrime(1024)</span><br><span class="line">q= getPrime(1024)</span><br><span class="line">n=p*q</span><br><span class="line">phi=(p-1)*(q-1)</span><br><span class="line">e1 =  getPrime(16)</span><br><span class="line">e2 =  getPrime(16)</span><br><span class="line">d1 =libnum.invmod(e1,phi)</span><br><span class="line">d2 =libnum.invmod(e2,phi)</span><br><span class="line">dd=d2-d1</span><br><span class="line"></span><br><span class="line">c1=pow(m1,e1,n)</span><br><span class="line">c2=pow(m2,e2,n)</span><br><span class="line">print(&quot;c1=&quot;,c1)</span><br><span class="line">print(&quot;c2=&quot;,c2)</span><br><span class="line">print(&quot;n=&quot;,n)</span><br><span class="line">print(&quot;e1=&quot;,e1)</span><br><span class="line">print(&quot;e2=&quot;,e2)</span><br><span class="line">print(&quot;dd=&quot;,dd)</span><br><span class="line">c1= 6733838789459931199058149670308727260843741096811449715444872676794872013183754622858142358860953409090471275056663852093255382831595445093389027611418533073251542228105122098655672243201566013269049673257545950265921334769453660794260369460626145929789420379373117970169521395700109883829930832864801056074877674941597582088285235646759637909087476295147786527873676567410566717421523346422950182870668646809884825822209501435038703929387996244766422894277224634645939878481756200099084364167558964681594043169720137522542692333678325260048812579899748925536673077066928758276593208971988942663469169538691035047694</span><br><span class="line">c2= 8366277709764400685046974874556048480052496413928056769515579166359481224673400489772756573250767790594839615839083763898307048126689342195264524356874243599245090238779605753249119610170611143039424214272370993787185091949643348010978753622976256276642743234789172453774761354256683433570844983636116313586831018168267526012235746840937969827190549583438830654378812487809058974682282579118375227701868159940746116268326846677193441199872518360781657796776416813543201068186698175639943920727192924592723876352818832499607933389909348997360827293372712297925074254469038243598148632369617179529428124887418815513980</span><br><span class="line">n= 18817594671090743657272253762944576150137162885923542977286206265757425414985090758109410978146720356103998948718214270184508716827830409430441234706995168712344420950028012950634922410416769515072316211057242302962478172436850591043456595538065256499508407496097561437670387166881800267145313078814265201339439524924036116421018006462379533497424347501070705658003620710859122307390256199828928801036473297236708659050799043830928526868538891939761670420670258518198985039020439020541730747119429222464031076670255708095414432621713513727172536335364200547007022393362808026249379896670380908869775413898849075996507</span><br><span class="line">e1= 41981</span><br><span class="line">e2= 36209</span><br><span class="line">dd= 1053704841024395437174966126533190981616292415576606812740918909121096916949302531783101209289389200245384407349748603292561596667558819619086001066677101374394170513370717808658925536480708691940905153090874424365353443644389110969859064875481674601586495481715770875127506827571256652900931272013627123620403523296244399421027877414684962334619785788986710188422499709843593365835744664902744928748656403821851709598285463439355756235533416138015740467498790254173390459329436575772984367497189565361716119512393162905231586789553789322178062842452918483776810036444979996001994632844167024771563150952249751416556</span><br></pre></td></tr></table></figure>

<p><img src="/../images/RSA/43.png"></p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">c1= <span class="number">6733838789459931199058149670308727260843741096811449715444872676794872013183754622858142358860953409090471275056663852093255382831595445093389027611418533073251542228105122098655672243201566013269049673257545950265921334769453660794260369460626145929789420379373117970169521395700109883829930832864801056074877674941597582088285235646759637909087476295147786527873676567410566717421523346422950182870668646809884825822209501435038703929387996244766422894277224634645939878481756200099084364167558964681594043169720137522542692333678325260048812579899748925536673077066928758276593208971988942663469169538691035047694</span></span><br><span class="line">c2= <span class="number">8366277709764400685046974874556048480052496413928056769515579166359481224673400489772756573250767790594839615839083763898307048126689342195264524356874243599245090238779605753249119610170611143039424214272370993787185091949643348010978753622976256276642743234789172453774761354256683433570844983636116313586831018168267526012235746840937969827190549583438830654378812487809058974682282579118375227701868159940746116268326846677193441199872518360781657796776416813543201068186698175639943920727192924592723876352818832499607933389909348997360827293372712297925074254469038243598148632369617179529428124887418815513980</span></span><br><span class="line">n= <span class="number">18817594671090743657272253762944576150137162885923542977286206265757425414985090758109410978146720356103998948718214270184508716827830409430441234706995168712344420950028012950634922410416769515072316211057242302962478172436850591043456595538065256499508407496097561437670387166881800267145313078814265201339439524924036116421018006462379533497424347501070705658003620710859122307390256199828928801036473297236708659050799043830928526868538891939761670420670258518198985039020439020541730747119429222464031076670255708095414432621713513727172536335364200547007022393362808026249379896670380908869775413898849075996507</span></span><br><span class="line">e1= <span class="number">41981</span></span><br><span class="line">e2= <span class="number">36209</span></span><br><span class="line">dd= <span class="number">1053704841024395437174966126533190981616292415576606812740918909121096916949302531783101209289389200245384407349748603292561596667558819619086001066677101374394170513370717808658925536480708691940905153090874424365353443644389110969859064875481674601586495481715770875127506827571256652900931272013627123620403523296244399421027877414684962334619785788986710188422499709843593365835744664902744928748656403821851709598285463439355756235533416138015740467498790254173390459329436575772984367497189565361716119512393162905231586789553789322178062842452918483776810036444979996001994632844167024771563150952249751416556</span></span><br><span class="line"></span><br><span class="line">kphi = dd*e1*e2 + (e2-e1)</span><br><span class="line"></span><br><span class="line">d1 = gmpy2.invert(e1,kphi)</span><br><span class="line">d2 = gmpy2.invert(e2,kphi)</span><br><span class="line"></span><br><span class="line"><span class="comment">#r,d1,_ = gmpy2.gcdext(e1,kphi)			用扩展欧几里得算法求逆元也可</span></span><br><span class="line"><span class="comment">#r,d2,_ = gmpy2.gcdext(e2,kphi)</span></span><br><span class="line"></span><br><span class="line">m1 = <span class="built_in">pow</span>(c1,d1,n)</span><br><span class="line">m2 = <span class="built_in">pow</span>(c2,d2,n)</span><br><span class="line">flag = long_to_bytes(m1) + long_to_bytes(m2)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>



<h1 id="三十五"><a href="#三十五" class="headerlink" title="三十五"></a>三十五</h1><h1 id="三十六、离散对数c-pow-m-flag-n"><a href="#三十六、离散对数c-pow-m-flag-n" class="headerlink" title="三十六、离散对数c &#x3D; pow(m,flag,n)"></a>三十六、离散对数c &#x3D; pow(m,flag,n)</h1><p>先了解一下什么是离散对数</p>
<h2 id="离散对数的定义"><a href="#离散对数的定义" class="headerlink" title="离散对数的定义"></a>离散对数的定义</h2><p>$$<br>当模n有原根时，设l为模n的一个原根，则当x\equiv l^k(mod \quad n)时:<br>$$</p>
<p>$$<br>Ind_lx \equiv k (mod \quad n),Ind_lx是整数l为底，x为真数，模n的离散对数值<br>$$</p>
<p>我的理解是，离散对数就是求解这个x的值，不过是在整数中求解，而不是在实数中<br>$$<br>a^x \equiv b(mod \quad n)<br>$$<br>详细的看这篇文章：<a href="https://zh.wikipedia.org/zh-hans/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0">离散对数 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><p>$$<br>对于互素的整数a,m<br>$$</p>
<p>$$<br>假设存在x使得a^x \equiv 1(mod \quad m),且这个x是所有解中最小的，而且x&#x3D;\phi(m)<br>$$</p>
<p>$$<br>此时称a为模m的原根<br>$$</p>
<p>详细的看这篇文章：<a href="https://zh.wikipedia.org/zh-hans/%E5%8E%9F%E6%A0%B9">原根 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<h2 id="怎么求解离散对数"><a href="#怎么求解离散对数" class="headerlink" title="怎么求解离散对数"></a>怎么求解离散对数</h2><p><strong>据我了解到</strong><code>sympy.discrete_log(n,a,b)</code><strong>能求解下式的x</strong><br>$$<br>b^x \equiv a(mod \quad n)<br>$$<br>其源码：<a href="https://github.com/sympy/sympy/blob/d2be7bacd2604e98a642f74028e8f0d7d6084f78/sympy/ntheory/residue_ntheory.py#L1357-L1402">sympy&#x2F;sympy&#x2F;ntheory&#x2F;residue_ntheory.py at d2be7bacd2604e98a642f74028e8f0d7d6084f78 · sympy&#x2F;sympy (github.com)</a></p>
<p><strong>以下是求解普通对数的函数</strong></p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">numpy.log(x)</td>
<td align="center">以e为底的对数</td>
</tr>
<tr>
<td align="center">numpy.log10(x)</td>
<td align="center">以10为底的对数</td>
</tr>
<tr>
<td align="center">numpy.log2(x)</td>
<td align="center">以2为底的对数</td>
</tr>
<tr>
<td align="center">numpy.log1p(x)</td>
<td align="center">相当于numpy.log(x+1)</td>
</tr>
<tr>
<td align="center">math.log(x)</td>
<td align="center">以e为底的对数</td>
</tr>
<tr>
<td align="center">math.log10(x)</td>
<td align="center">以10为底的对数</td>
</tr>
<tr>
<td align="center">math.log2(x)</td>
<td align="center">以2为底的对数</td>
</tr>
<tr>
<td align="center">math.log1p(x)</td>
<td align="center">相当于math.log(x+1)</td>
</tr>
</tbody></table>
<p><code>math.log(x,n)</code>：计算以n为底，x为真数的值</p>
<h2 id="例题-7"><a href="#例题-7" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line">import random</span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">print(flag)</span><br><span class="line">e= libnum.s2n(flag)</span><br><span class="line">n=2**512</span><br><span class="line">m = random.randint(2, n-1) | 1</span><br><span class="line">c=pow(m,e,n)</span><br><span class="line">print(&quot;m=&quot;,m)</span><br><span class="line">print(&quot;c=&quot;,c)</span><br><span class="line">m= 159288671018830898156155351952186977642819454341811868237859009749383960869982923115380878290375192847504545108933927464025163205891819917678534983817309</span><br><span class="line">c= 12714803532028941243809606974437987862326521262004726834999494702689747253925210908627215296516631899337657950072189903034513687791841244487330214554784973</span><br></pre></td></tr></table></figure>

<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">m= <span class="number">159288671018830898156155351952186977642819454341811868237859009749383960869982923115380878290375192847504545108933927464025163205891819917678534983817309</span></span><br><span class="line">c= <span class="number">12714803532028941243809606974437987862326521262004726834999494702689747253925210908627215296516631899337657950072189903034513687791841244487330214554784973</span></span><br><span class="line">n = <span class="number">2</span>**<span class="number">512</span></span><br><span class="line"></span><br><span class="line">flag = sympy.discrete_log(n,c,m)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(flag))</span><br></pre></td></tr></table></figure>



<h1 id="三十七、m-n"><a href="#三十七、m-n" class="headerlink" title="三十七、m &gt; n"></a>三十七、m &gt; n</h1><h2 id="例题-8"><a href="#例题-8" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2 as gp</span><br><span class="line">from secert import flag</span><br><span class="line">assert len(flag)==42</span><br><span class="line">e=0x10001</span><br><span class="line">m=bytes_to_long(flag)</span><br><span class="line">p=getPrime(160)</span><br><span class="line">q=gp.next_prime(p)</span><br><span class="line">n=p*q</span><br><span class="line">c=pow(m,e,n)</span><br><span class="line">print(&#x27;n=&#x27;,n)</span><br><span class="line">print(&#x27;c=&#x27;,c)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">n= 1938198674432811161450690669878250944830265839396906617662062291196152960227589796372087441130963</span><br><span class="line">c= 90170164274936424192415483102025065297184726282389841586708984518420677588910796600189918035116</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/RSA/44.png"></p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n= <span class="number">1938198674432811161450690669878250944830265839396906617662062291196152960227589796372087441130963</span></span><br><span class="line">c= <span class="number">90170164274936424192415483102025065297184726282389841586708984518420677588910796600189918035116</span></span><br><span class="line">e=<span class="number">0x10001</span></span><br><span class="line"></span><br><span class="line">t = gmpy2.iroot(n,<span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">p = gmpy2.next_prime(t)</span><br><span class="line">q = n // p</span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m1 = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">16</span>,<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">    m = m1 + k*n</span><br><span class="line">    flag = long_to_bytes(m)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;flag&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>



<h1 id="三十八、ppp和ppq"><a href="#三十八、ppp和ppq" class="headerlink" title="三十八、ppp和ppq"></a>三十八、ppp和ppq</h1><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from gmpy2 import *</span><br><span class="line">from Crypto.Util.number import getPrime, long_to_bytes, bytes_to_long</span><br><span class="line"></span><br><span class="line">flag = b&quot;flag&#123;xxxxxx&#125;&quot;</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getPrime(1024)</span><br><span class="line">q = getPrime(1024)</span><br><span class="line">e = 65537</span><br><span class="line">n = p*p*q</span><br><span class="line">t = p*p*p</span><br><span class="line">c = powmod(m, e, n)</span><br><span class="line">print(c)</span><br><span class="line">print(n)</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line"># 695811613220508521533410410135903763704380792345313822348335925535019364085287973391006658091756337941388790850576390425798691514904654108730064898721482454942897809486946732327567166790987988769649339266791907850313832700513155194190805272799105846921535231183458026312210254181900390502309417588847104213793231394168583827484833346266655392107254900891316034825295594615584454126662183967495486871019315836843964142146438253642093949267821928660254775556448682535996878217802620757735862588509198138308229216540912203307177130148261480033848867147610177292359480179993393430101548639801133574244188591918478576785400355882470444135385837723688465703459098247158590332167802098779963168624783522306380012451430590453130321881597629274617390265737278952430391455292129197120724233266227673065462001473529262207830010588159156853973215615518415224386700532070174251781750417203041543631328597659473610199473825400069638203715</span><br><span class="line"># 1103142672269025650462929198164640404493425942265040323371207998377200145961695641048087337404972402560194267711668479433180851107371884950953570911657090487495216386781924343363213345312692741516666557796484628501590914827387171553761258413087800091632213720047678961681727564158606220008125433169164157150198004730103285226539823741065685538894369776994256049396334124080247371292445543852118777801692107831636409684364527162627188519199064013189168290873007156380530155343171815296016451575866508168728518236121071519646489851701773457562537221387306293985011019040423572239157745630631563892081210964602524396761067561161422635793249097955070576281428534742447903449072401000345617064665752070967341863838984791405144869303448662169933201623421080650216122814985967041163663854812030159367202820911939914186148267664571396203542821594364250609009816872825447917845472311564561269905225280796615586133341770795940714518373</span><br><span class="line"># 1352157133681616199949626085859887520183044653936717410198546937928330648087119395184417755928058157424764679366526294873446661771336360719004981235527982326342186212780230888122434477779310176780131887691097470115061291877918798366484343129280364265571974776435297187299058517674913907506344826320352532394679559865918025267583173757096064690288877037701829014463065076789753953054738098985305066307636180043889030783678919407771611169741555877144593927382649961986384716532446388338376466150688150609936293316903617335385558920141250240529204636396228961938978325120385146208552506658553610353813640686759609897131817533377973931149277140553678119548578402674858651748611808600372129132750796909828079961432457264127651812438564831345298563698676305419952826466259729378236885089128224289161328570151277873778313473830713469181909893871432564345696475759124658962121070495959528237764331872929513704863754771030741820729657</span><br></pre></td></tr></table></figure>

<p><strong>把t开根号就能得到p，然后就是解RSA</strong></p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">c = <span class="number">695811613220508521533410410135903763704380792345313822348335925535019364085287973391006658091756337941388790850576390425798691514904654108730064898721482454942897809486946732327567166790987988769649339266791907850313832700513155194190805272799105846921535231183458026312210254181900390502309417588847104213793231394168583827484833346266655392107254900891316034825295594615584454126662183967495486871019315836843964142146438253642093949267821928660254775556448682535996878217802620757735862588509198138308229216540912203307177130148261480033848867147610177292359480179993393430101548639801133574244188591918478576785400355882470444135385837723688465703459098247158590332167802098779963168624783522306380012451430590453130321881597629274617390265737278952430391455292129197120724233266227673065462001473529262207830010588159156853973215615518415224386700532070174251781750417203041543631328597659473610199473825400069638203715</span></span><br><span class="line">n = <span class="number">1103142672269025650462929198164640404493425942265040323371207998377200145961695641048087337404972402560194267711668479433180851107371884950953570911657090487495216386781924343363213345312692741516666557796484628501590914827387171553761258413087800091632213720047678961681727564158606220008125433169164157150198004730103285226539823741065685538894369776994256049396334124080247371292445543852118777801692107831636409684364527162627188519199064013189168290873007156380530155343171815296016451575866508168728518236121071519646489851701773457562537221387306293985011019040423572239157745630631563892081210964602524396761067561161422635793249097955070576281428534742447903449072401000345617064665752070967341863838984791405144869303448662169933201623421080650216122814985967041163663854812030159367202820911939914186148267664571396203542821594364250609009816872825447917845472311564561269905225280796615586133341770795940714518373</span></span><br><span class="line">t = <span class="number">1352157133681616199949626085859887520183044653936717410198546937928330648087119395184417755928058157424764679366526294873446661771336360719004981235527982326342186212780230888122434477779310176780131887691097470115061291877918798366484343129280364265571974776435297187299058517674913907506344826320352532394679559865918025267583173757096064690288877037701829014463065076789753953054738098985305066307636180043889030783678919407771611169741555877144593927382649961986384716532446388338376466150688150609936293316903617335385558920141250240529204636396228961938978325120385146208552506658553610353813640686759609897131817533377973931149277140553678119548578402674858651748611808600372129132750796909828079961432457264127651812438564831345298563698676305419952826466259729378236885089128224289161328570151277873778313473830713469181909893871432564345696475759124658962121070495959528237764331872929513704863754771030741820729657</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">p = gmpy2.iroot(t,<span class="number">3</span>)[<span class="number">0</span>]</span><br><span class="line">q = n // p**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">phi = (p**<span class="number">2</span>-p)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,(phi))</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"><span class="comment">#b&#x27;flag&#123;Now_u_kn0w_GCD_and_s1mpl3_RSA&#125;&#x27;</span></span><br></pre></td></tr></table></figure>



<h1 id="三十九、扩展中国剩余定理"><a href="#三十九、扩展中国剩余定理" class="headerlink" title="三十九、扩展中国剩余定理"></a>三十九、扩展中国剩余定理</h1><h2 id="1-求d"><a href="#1-求d" class="headerlink" title="1.求d"></a>1.求d</h2><h3 id="例题-9"><a href="#例题-9" class="headerlink" title="例题"></a>例题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">r = getPrime(512)</span><br><span class="line">e = getPrime(32)</span><br><span class="line">print(e)</span><br><span class="line">n = p*q*r</span><br><span class="line">phi = (p-1)*(q-1)*(r-1)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">dp = d%((q-1)*(r-1))</span><br><span class="line">dq = d%((p-1)*(r-1))</span><br><span class="line">dr = d%((p-1)*(q-1))</span><br><span class="line">flag = &#x27;flag&#123;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&#125;&#x27;</span><br><span class="line">m = bytes_to_long(flag.encode())</span><br><span class="line">c = pow(m,e,n)</span><br><span class="line"></span><br><span class="line">print(p)</span><br><span class="line">print(q)</span><br><span class="line">print(r)</span><br><span class="line">print(dp)</span><br><span class="line">print(dq)</span><br><span class="line">print(dr)</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">p=12922128058767029848676385650461975663483632970994721128398090402671357430399910236576943902580268365115559040908171487273491136108931171215963673857907721</span><br><span class="line">q=10395910293559541454979782434227114401257890224810826672485874938639616819909368963527556812339196570118998080877100587760101646884011742783881592586607483</span><br><span class="line">r=8104533688439480164488403019957173637520526666352540480766865791142556044817828133446063428255474375204188144310967625626318466189746446739697284656837499</span><br><span class="line">dp=73360412924315743410612858109886169233122608813546859531995431159702281180116580962235297605024326120716590757069707814371806343766956894408106019058184354279568525768909190843389534908163730972765221403797428735591146943727032277163147380538250142612444372315262195455266292156566943804557623319253942627829</span><br><span class="line">dq=40011003982913118920477233564329052389422276107266243287367766124357736739027781899850422097218506350119257015460291153483339485727984512959771805645640899525080850525273304988145509506962755664208407488807873672040970416096459662677968243781070751482234692575943914243633982505045357475070019527351586080273</span><br><span class="line">dr=21504040939112983125383942214187695383459556831904800061168077060846983552476434854825475457749096404504088696171780970907072305495623953811379179449789142049817703543458498244186699984858401903729236362439659600561895931051597248170420055792553353578915848063216831827095100173180270649367917678965552672673</span><br><span class="line">c=220428832901130282093087304800127910055992783874826238869471313726515822196746908777026147887315019800546695346099376727742597231512404648514329911088048902389321230640565683145565701498095660019604419213310866468276943241155853029934366950674139215056682438149221374543291202295130547776549069333898123270448986380025937093195496539532193583979030254746589985556996040224572481200667498253900563663950531345601763949337787268884688982469744380006435119997310653</span><br></pre></td></tr></table></figure>

<p>$$<br>用中国剩余定理解\<br>\left{\begin{matrix}<br>dp \equiv d \mod (q-1)(r-1)\<br>dq \equiv d \mod (p-1)(r-1)\<br>dr \equiv d \mod (p-1)(q-1)<br>\end{matrix}\right.<br>$$</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sympy.ntheory.modular <span class="keyword">import</span> crt</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">p=<span class="number">12922128058767029848676385650461975663483632970994721128398090402671357430399910236576943902580268365115559040908171487273491136108931171215963673857907721</span></span><br><span class="line">q=<span class="number">10395910293559541454979782434227114401257890224810826672485874938639616819909368963527556812339196570118998080877100587760101646884011742783881592586607483</span></span><br><span class="line">r=<span class="number">8104533688439480164488403019957173637520526666352540480766865791142556044817828133446063428255474375204188144310967625626318466189746446739697284656837499</span></span><br><span class="line">dp=<span class="number">73360412924315743410612858109886169233122608813546859531995431159702281180116580962235297605024326120716590757069707814371806343766956894408106019058184354279568525768909190843389534908163730972765221403797428735591146943727032277163147380538250142612444372315262195455266292156566943804557623319253942627829</span></span><br><span class="line">dq=<span class="number">40011003982913118920477233564329052389422276107266243287367766124357736739027781899850422097218506350119257015460291153483339485727984512959771805645640899525080850525273304988145509506962755664208407488807873672040970416096459662677968243781070751482234692575943914243633982505045357475070019527351586080273</span></span><br><span class="line">dr=<span class="number">21504040939112983125383942214187695383459556831904800061168077060846983552476434854825475457749096404504088696171780970907072305495623953811379179449789142049817703543458498244186699984858401903729236362439659600561895931051597248170420055792553353578915848063216831827095100173180270649367917678965552672673</span></span><br><span class="line">c=<span class="number">220428832901130282093087304800127910055992783874826238869471313726515822196746908777026147887315019800546695346099376727742597231512404648514329911088048902389321230640565683145565701498095660019604419213310866468276943241155853029934366950674139215056682438149221374543291202295130547776549069333898123270448986380025937093195496539532193583979030254746589985556996040224572481200667498253900563663950531345601763949337787268884688982469744380006435119997310653</span></span><br><span class="line"></span><br><span class="line">b1 = (q-<span class="number">1</span>)*(r-<span class="number">1</span>)</span><br><span class="line">b2 = (p-<span class="number">1</span>)*(r-<span class="number">1</span>)</span><br><span class="line">b3 = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">d = crt([b1,b2,b3],[dp,dq,dr])	<span class="comment">#crt([模],[余数])</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(d)):</span><br><span class="line">    m = <span class="built_in">pow</span>(c,d[i],p*q*r)</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"><span class="comment">#DASCTF&#123;8ec820e5251db6e7a1758543a1123824&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="2-求c"><a href="#2-求c" class="headerlink" title="2.求c"></a>2.求c</h2><h3 id="例题-10"><a href="#例题-10" class="headerlink" title="例题"></a>例题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">import random</span><br><span class="line"># from secret import flag</span><br><span class="line">flag=&#x27;&#x27;</span><br><span class="line">table=&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span><br><span class="line">pad=100-len(flag)</span><br><span class="line">for i in range(pad):</span><br><span class="line">    flag+=random.choice(table).encode()</span><br><span class="line">e=343284449</span><br><span class="line">m=bytes_to_long(flag)</span><br><span class="line">assert m&gt;(1&lt;&lt;512)</span><br><span class="line">assert m&lt;(1&lt;&lt;1024)</span><br><span class="line">p=getPrime(512)</span><br><span class="line">q=getPrime(512)</span><br><span class="line">r=getPrime(512)</span><br><span class="line">print(&#x27;p=&#x27;,p)</span><br><span class="line">print(&#x27;q=&#x27;,q)</span><br><span class="line">print(&#x27;r=&#x27;,r)</span><br><span class="line">n1=p*q</span><br><span class="line">n2=q*r</span><br><span class="line">c1=pow(m,e,n1)</span><br><span class="line">c2=pow(m,e,n2)</span><br><span class="line">print(&#x27;c1=&#x27;,c1)</span><br><span class="line">print(&#x27;c2=&#x27;,c2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p= 11820891196647569262137841192985418014377132106496147254821784946481523526822939129065042819464351666077658751406165276121125571355594004514547517855730743</span><br><span class="line">q= 10450390015864176713581330969519712299844487112687677452105216477861582967322473997670559995588440097951786576039009337782247912476227937589298529580432797</span><br><span class="line">r= 9484954066160968219229920429258150817546418633451929876581842443665029377287119340232501682142185708534413073877473741393278935479791561681402673403009771</span><br><span class="line"></span><br><span class="line">c1= 69574855207460025252857869494766338442370688922127811393280455950372371842144946699073877876005649281006116543528211809466226185922844601714337317797534664683681334132261584497953105754257846471069875622054326463757746293958069752489458646460121725019594141157667480846709081917530190233900184428943585065316</span><br><span class="line">c2= 66183492015178047844987766781469734325646160179923242098082430373061510938987908656007752256556018402101435698352339429316390909525615464024332856855411414576031970267795270882896721069952171988506477519737923165566896609181813523905810373359029413963666924039857159685161563252396502381297700252749204993228</span><br></pre></td></tr></table></figure>

<p>$$<br>先用中国剩余定理解出c\<br>得到的这个c是满足c \equiv m^e \mod lcm(n_1,n_2)\<br>即c \equiv m^e \mod pqr\<br>推出c \equiv m^e \mod pr<br>$$</p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sympy.ntheory.modular <span class="keyword">import</span> crt</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">p= <span class="number">11820891196647569262137841192985418014377132106496147254821784946481523526822939129065042819464351666077658751406165276121125571355594004514547517855730743</span></span><br><span class="line">q= <span class="number">10450390015864176713581330969519712299844487112687677452105216477861582967322473997670559995588440097951786576039009337782247912476227937589298529580432797</span></span><br><span class="line">r= <span class="number">9484954066160968219229920429258150817546418633451929876581842443665029377287119340232501682142185708534413073877473741393278935479791561681402673403009771</span></span><br><span class="line">e= <span class="number">343284449</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c1= <span class="number">69574855207460025252857869494766338442370688922127811393280455950372371842144946699073877876005649281006116543528211809466226185922844601714337317797534664683681334132261584497953105754257846471069875622054326463757746293958069752489458646460121725019594141157667480846709081917530190233900184428943585065316</span></span><br><span class="line">c2= <span class="number">66183492015178047844987766781469734325646160179923242098082430373061510938987908656007752256556018402101435698352339429316390909525615464024332856855411414576031970267795270882896721069952171988506477519737923165566896609181813523905810373359029413963666924039857159685161563252396502381297700252749204993228</span></span><br><span class="line"></span><br><span class="line">n1 = p*q</span><br><span class="line">n2 = q*r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = crt([n1,n2],[c1,c2])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(c)):</span><br><span class="line">    n = p*r</span><br><span class="line">    d = gmpy2.invert(e,(p-<span class="number">1</span>)*(r-<span class="number">1</span>))</span><br><span class="line">    m = <span class="built_in">pow</span>(c[i],d,n)</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>

<p><strong>解密的时候适当化简一下？</strong></p>
<h1 id="四十、e和phi不互素，用中国剩余定理"><a href="#四十、e和phi不互素，用中国剩余定理" class="headerlink" title="四十、e和phi不互素，用中国剩余定理"></a>四十、e和phi不互素，用中国剩余定理</h1>]]></content>
      <categories>
        <category>现代密码-非对称加密</category>
      </categories>
      <tags>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA2</title>
    <url>/2023/07/09/RSA2/</url>
    <content><![CDATA[<p><strong>每个黎明都是崭新的开始</strong></p>
<span id="more"></span>

<p><strong>记录笔者RSA学习过程，继上篇</strong></p>
<h1 id="十五、m高位泄露"><a href="#十五、m高位泄露" class="headerlink" title="十五、m高位泄露"></a>十五、m高位泄露</h1><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line">flag = <span class="string">&quot;flag&#123;&quot;</span> + <span class="built_in">str</span>(uuid.uuid4()) + <span class="string">&quot;&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">p = libnum.generate_prime(<span class="number">512</span>)</span><br><span class="line">q = libnum.generate_prime(<span class="number">512</span>)</span><br><span class="line">n = p * q</span><br><span class="line">m1 = ((m &gt;&gt; <span class="number">12</span>) &lt;&lt; <span class="number">12</span>)</span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&quot;</span>, c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e=&quot;</span>, e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;m1=&quot;</span>, m1)</span><br></pre></td></tr></table></figure>

<p>直接用小明文攻击就能解决</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">c = <span class="number">175676150266417004297584173166433352018610464097263332979457040860199735122833311628588245224087655808166100611110577476473768211724924905653808872550861589950953763432355842437271483012029579464732704952936714503937167618229688691848715162564826927771471544937668578504504217271902336934966580193607269</span></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(gmpy2.iroot(c,<span class="number">3</span>)[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<p>$$<br>已知m高位m_h，则m &#x3D; m_h + x<br>$$</p>
<p>$$<br>所以m^e \equiv c (mod \quad n)<br>$$</p>
<p>$$<br>&#x3D;&gt; (m_h+x)^e \equiv c(mod \quad n)<br>$$</p>
<p>$$<br>\therefore 构造f &#x3D; (m_h+x)^e-c<br>$$</p>
<p><strong>SageMath exp:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line"></span><br><span class="line">n= 151960946972702081117093360145150451962009606399284283949493014851527184623949643832244795119390951664496262788801113061738745471705109651801469941245713981102683597278171804859002235073409069064532316371103411496330579589757997270705141792018944994603558174557515947534514865010671376327712345796006705526541</span><br><span class="line">c= 175676150266417004297584173166433352018610464097263332979457040860199735122833311628588245224087655808166100611110577476473768211724924905653808872550861589950953763432355842437271483012029579464732704952936714503937167618229688691848715162564826927771471544937668578504504217271902336934966580193607269</span><br><span class="line">e= 3</span><br><span class="line">m_high= 56006392793406045855300363310507945362344210576887867606743770445705804994335695867672312071808311296</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">m = m_high + x</span><br><span class="line">f = m^e - c</span><br><span class="line">x = f.small_roots(X = 2^12,beta = 0.4)</span><br><span class="line">if x:</span><br><span class="line">	m = m_high + x[0]</span><br><span class="line">	print(long_to_bytes(int(m))</span><br></pre></td></tr></table></figure>

<h1 id="十六、p高位泄露"><a href="#十六、p高位泄露" class="headerlink" title="十六、p高位泄露"></a>十六、p高位泄露</h1><p><strong>p的高位泄露一般是通过右移和左移操作来实现</strong></p>
<p><strong>一个数右移n位相当于除2的n次方，左移是乘上2的n次方</strong></p>
<p>eg:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">11111111右移3位后得到的是 00011111再左移3位 得到的是 11111000</span><br></pre></td></tr></table></figure>

<p>这样会导致低位的一些值丢失</p>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;flag&#123;&quot;</span> + <span class="built_in">str</span>(uuid.uuid4()) + <span class="string">&quot;&#125;&quot;</span></span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">p = libnum.generate_prime(<span class="number">1024</span>)</span><br><span class="line">q = libnum.generate_prime(<span class="number">1024</span>)</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">p1 = ((p &gt;&gt; <span class="number">256</span>) &lt;&lt; <span class="number">256</span>)</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&quot;</span>, c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e=&quot;</span>, e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p1=&quot;</span>, p1)</span><br></pre></td></tr></table></figure>

<p><strong>exp:</strong> 这是sagemath脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">n = 13825843519571710873428859414579672354315071659439820628244472999485866649052110805457869338590187514116602837815124140432484262117371676976267721436244227104792863856722306533085878006249426437815405943285837409223882200429650139498565410193518318609186404321541002818447049590702693207093178119976930306188313389812258040902404991392273477524090663507230185854302508398487606160947861933574298409247029121725657976002346558116475950788745748638760678901488207720494815927253554983917627634826826305748104732049673766438361103134678640861807396808490547480920918122602522866517282598354247700246018620827186407222291</span><br><span class="line">c = 8069176849119953284725698979637300857649466313773809113683642222085416457809259502704557882469560357376639733126836429991182536164084894508162647211766121557706947090701813794460382373772210944822854491223080171468124365453829931994686613388386398672952889685840411999135073540598959537338763755743580187011320135902778073983544957246842281172553032459418474893043913045926987625022043858637785478142565769241237336503137679001977264793413893322859182579535729775068010748011003277877267258462798570180414065271758061734676359804300115257687481351307213343011733330342628658103765597956044989311340712232509671201918</span><br><span class="line">e = 65537</span><br><span class="line">high_p = 109808212971964883545767217899164260396892558575747412957992952622503445366463665637485518479176308697194263286931473866511191437500214960131113514969332424915850812713465121027047280080223105730986925447033745115390014601545111178800361343308690136190170861353596131750311275899169955729432487964244199866368</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = high_p + x</span><br><span class="line">x = f.small_roots(X = 2^256,beta = 0.4)</span><br><span class="line">if x:</span><br><span class="line">    p = high_p + int(x[0])</span><br><span class="line">    q = n // p</span><br><span class="line">    d = gmpy2.invert(e,(p-1)*(q-1))</span><br><span class="line">    m = pow(c,d,n)</span><br><span class="line">    print(long_to_bytes(int(m)))</span><br></pre></td></tr></table></figure>

<p>解释一些函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">PolynomialRing函数</span><br><span class="line">它用于定义一个多项式环。在这个例子中，多项式环R的系数来自于整数环Zmod(n)，即在模n下的整数形成的环</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x = f.small_roots(X = 2^256,beta = 0.4)</span><br><span class="line">函数本来的样子</span><br><span class="line">small.roots(f, bound, beta=None, epsilon=0, max_steps=20, verbose=False)</span><br><span class="line">f：一个多项式或多项式列表，其中每个多项式都是SageMath中的Polynomial对象。</span><br><span class="line">bound：一个正整数，表示要查找的根的绝对值的上限。</span><br><span class="line">beta：一个正实数，表示算法中用于控制根的精度的参数。默认值为None，表示使用一个根据f的度数和bound自动确定的值。</span><br><span class="line">epsilon：一个非负实数，表示算法中用于控制根的精度的参数。默认值为0，表示使用一个根据f的度数和bound自动确定的值。</span><br><span class="line">max_steps：一个正整数，表示算法中用于控制迭代次数的参数。默认值为20，表示最多进行20次迭代。</span><br><span class="line">verbose：一个布尔值，表示是否在算法运行时输出详细信息。默认值为False，表示不输出详细信息。</span><br><span class="line"></span><br><span class="line">常常只用两个参数</span><br></pre></td></tr></table></figure>



<h2 id="例题2-2021CISCN-初赛rsa"><a href="#例题2-2021CISCN-初赛rsa" class="headerlink" title="例题2 2021CISCN 初赛rsa"></a>例题2 2021CISCN 初赛rsa</h2><p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> text,flag</span><br><span class="line"><span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes,bytes_to_long,getPrime</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> md5.new(text).hexdigest() == flag[<span class="number">6</span>:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">msg1 = text[:xx]</span><br><span class="line">msg2 = text[xx:yy]</span><br><span class="line">msg3 = text[yy:]</span><br><span class="line"></span><br><span class="line">msg1 = bytes_to_long(msg1)</span><br><span class="line">msg2 = bytes_to_long(msg2)</span><br><span class="line">msg3 = bytes_to_long(msg3)</span><br><span class="line"></span><br><span class="line">p1 = getPrime(<span class="number">512</span>)</span><br><span class="line">q1 = getPrime(<span class="number">512</span>)</span><br><span class="line">N1 = p1*q1</span><br><span class="line">e1 = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">pow</span>(msg1,e1,N1)</span><br><span class="line"><span class="built_in">print</span> (e1,N1)</span><br><span class="line"></span><br><span class="line">p2 = getPrime(<span class="number">512</span>)</span><br><span class="line">q2 = getPrime(<span class="number">512</span>)</span><br><span class="line">N2 = p2*q2</span><br><span class="line">e2 = <span class="number">17</span></span><br><span class="line">e3 = <span class="number">65537</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">pow</span>(msg2,e2,N2)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">pow</span>(msg2,e3,N2)</span><br><span class="line"><span class="built_in">print</span> (e2,N2)</span><br><span class="line"><span class="built_in">print</span> (e3,N2)</span><br><span class="line"></span><br><span class="line">p3 = getPrime(<span class="number">512</span>)</span><br><span class="line">q3 = getPrime(<span class="number">512</span>)</span><br><span class="line">N3 = p3*q3</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">pow</span>(msg3,e3,N3)</span><br><span class="line"><span class="built_in">print</span> (e3,N3)</span><br><span class="line"><span class="built_in">print</span> p3&gt;&gt;<span class="number">200</span></span><br></pre></td></tr></table></figure>

<p><strong>part 1 小明文攻击，part 2 共模攻击，part3 p高位泄露</strong></p>
<p><strong>exp:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">c1 = 19105765285510667553313898813498220212421177527647187802549913914263968945493144633390670605116251064550364704789358830072133349108808799075021540479815182657667763617178044110939458834654922540704196330451979349353031578518479199454480458137984734402248011464467312753683234543319955893</span><br><span class="line">m1 = gmpy2.iroot(c1,3)[0]</span><br><span class="line">print(long_to_bytes(m1))</span><br><span class="line"></span><br><span class="line">c2 = 54995751387258798791895413216172284653407054079765769704170763023830130981480272943338445245689293729308200574217959018462512790523622252479258419498858307898118907076773470253533344877959508766285730509067829684427375759345623701605997067135659404296663877453758701010726561824951602615501078818914410959610</span><br><span class="line">c3 =91290935267458356541959327381220067466104890455391103989639822855753797805354139741959957951983943146108552762756444475545250343766798220348240377590112854890482375744876016191773471853704014735936608436210153669829454288199838827646402742554134017280213707222338496271289894681312606239512924842845268366950</span><br><span class="line">n2 =111381961169589927896512557754289420474877632607334685306667977794938824018345795836303161492076539375959731633270626091498843936401996648820451019811592594528673182109109991384472979198906744569181673282663323892346854520052840694924830064546269187849702880332522636682366270177489467478933966884097824069977</span><br><span class="line">e2 =17</span><br><span class="line">e3 = 65537</span><br><span class="line">r,x,y = gmpy2.gcdext(e2,e3)</span><br><span class="line">m2 = (pow(c2,x,n2)*pow(c3,y,n2))%n2</span><br><span class="line">print(long_to_bytes(int(m2)))</span><br><span class="line"></span><br><span class="line">c4 =59213696442373765895948702611659756779813897653022080905635545636905434038306468935283962686059037461940227618715695875589055593696352594630107082714757036815875497138523738695066811985036315624927897081153190329636864005133757096991035607918106529151451834369442313673849563635248465014289409374291381429646</span><br><span class="line">e4 = 65537</span><br><span class="line">n3 =113432930155033263769270712825121761080813952100666693606866355917116416984149165507231925180593860836255402950358327422447359200689537217528547623691586008952619063846801829802637448874451228957635707553980210685985215887107300416969549087293746310593988908287181025770739538992559714587375763131132963783147</span><br><span class="line">p0 = 7117286695925472918001071846973900342640107770214858928188419765628151478620236042882657992902</span><br><span class="line">p0 = p0&lt;&lt;200</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(n3))</span><br><span class="line">f = p0 + x</span><br><span class="line">x = f.small_roots(X = 2^200,beta = 0.4)</span><br><span class="line">if x:</span><br><span class="line">	p = p0+x[0]</span><br><span class="line">	q = n3 // p</span><br><span class="line">	d = gmpy2.invert(e4,(p-1)*(q-1))</span><br><span class="line">	m3 = pow(c4,d,n3)</span><br><span class="line">	print(long_to_bytes(m3))</span><br><span class="line">	txt = long_to_bytes(m1)+long_to_bytes(m2)+long_to_bytes(m3)</span><br><span class="line">	flag = hashlib.md5(txt).hexdigest()</span><br><span class="line">	print(flag)</span><br></pre></td></tr></table></figure>



<h1 id="十七、d低位泄露"><a href="#十七、d低位泄露" class="headerlink" title="十七、d低位泄露"></a>十七、d低位泄露</h1><p>条件：e较小,且已知d的低位</p>
<p>推导：</p>
<p>$$<br>\because e×d \equiv 1(mod \quad (p-1)(q-1))<br>$$</p>
<p>$$<br>&#x3D;&gt; e×d &#x3D; k×(p-1)(q-1) + 1<br>$$</p>
<p>$$<br>&#x3D;&gt;e×d &#x3D; k×(n-p-q+1)+1<br>$$</p>
<p>$$<br>设d的低位为d_0,与n^{\frac{1}{2}}约一个bit长度(这没理解)<br>$$</p>
<p>$$<br>设n的bit长度为L,由e×d&#x3D;k×(n-p-q+1)+1,我们对左右两个式子模2^{\frac{L}{2}}得到:<br>$$</p>
<p>$$<br>e×d_0 \equiv k×(n-p-q+1)+1(mod \quad 2^{\frac{L}{2}}),这里我的理解是d(mod \quad 2^{\frac{L}{2}})就是d_0<br>$$</p>
<p>$$<br>把上式e×d_0 \equiv k×(n-p-q+1)+1(mod \quad 2^{\frac{L}{2}})<br>$$</p>
<p>$$<br>用q &#x3D; \frac{n}{p}代换得到：<br>$$</p>
<p>$$<br>ed_0p \equiv kpn-kp^2-kn+kp+p(mod \quad 2^{\frac{L}{2}})<br>$$</p>
<p>$$<br>用sagemath中的函数解这个同余式就能得到p的低位<br>$$</p>
<p>$$<br>关于k的取值：<br>$$</p>
<p>$$<br>由e×d &#x3D; k×\phi(n) + 1<br>$$</p>
<p>$$<br>\because d&lt;\phi(n),\therefore e&gt;k<br>$$</p>
<p>$$<br>一般e不会太大，爆破k就可以<br>$$</p>
<p><strong>SageMath中解同余式的函数如下：</strong></p>
<p><strong><code>solve_mod(eqs,mods)</code></strong></p>
<p>对于这个例子，则用下式<br>$$<br>X &#x3D; var(‘X’)，定义一个变量<br>$$</p>
<p><img src="/../images/RSA/34.png"></p>
<h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">while True:</span><br><span class="line">    p = libnum.generate_prime(512)</span><br><span class="line">    q = libnum.generate_prime(512)</span><br><span class="line">    n = p * q</span><br><span class="line">    phi_n = (p - 1) * (q - 1)</span><br><span class="line">    e = 3</span><br><span class="line">    if gmpy2.gcd(e, phi_n) == 1:</span><br><span class="line">        break</span><br><span class="line">d = gmpy2.invert(e, phi_n)</span><br><span class="line">d1 = d &amp; ((1 &lt;&lt; 486) - 1)</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(&quot;n=&quot;, n)</span><br><span class="line">print(&quot;e=&quot;, e)</span><br><span class="line">print(&quot;c=&quot;, c)</span><br><span class="line">print(&quot;d1=&quot;, d)</span><br></pre></td></tr></table></figure>

<p><strong>这题也可以利用小明文攻击</strong></p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">c = <span class="number">175676150266403937224898870626869248307097859453341599800113943191154294552011908698393750389195590199207971365632903719917006078351629939912360175671032635640354766675409868021903917260597989036476083685690139071290022752606720020238530580507331902326179201548484337939338062870542095137303322195300197</span></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(gmpy2.iroot(c,<span class="number">3</span>)[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<p><strong>SageMath</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getFullP(low_p, n):</span><br><span class="line">    R.&lt;x&gt; = PolynomialRing(Zmod(n), implementation=&#x27;NTL&#x27;)</span><br><span class="line">    p = x * 2 ^ bit + low_p</span><br><span class="line">    root = (p - n).monic().small_roots(X=2 ^ 128, beta=0.4)</span><br><span class="line">    if root:</span><br><span class="line">        return p(root[0])</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def phase4(low_d,n,c,e):</span><br><span class="line">    maybe_p = []</span><br><span class="line">    for k in range(1, 4):</span><br><span class="line">        p = var(&#x27;p&#x27;)</span><br><span class="line">        p0 = solve_mod([3 * p * low_d == p + k * (n * p - p ^ 2 - n + p)], 2 ^ bit)</span><br><span class="line">        maybe_p += [int(x[0]) for x in p0]</span><br><span class="line">    # print(maybe_p)</span><br><span class="line"></span><br><span class="line">    for x in maybe_p:</span><br><span class="line">        P = getFullP(x, n)</span><br><span class="line">        if P: break</span><br><span class="line"></span><br><span class="line">    P = int(P)</span><br><span class="line">    Q = n // P</span><br><span class="line"></span><br><span class="line">    assert P * Q == n</span><br><span class="line">    print(&quot;P = &quot;,P)</span><br><span class="line">    print(&quot;Q = &quot;,Q)</span><br><span class="line"></span><br><span class="line">    d = inverse_mod(3, (P - 1) * (Q - 1))</span><br><span class="line">    m = pow(c,d,n)</span><br><span class="line">    print(long_to_bytes(int(m)))</span><br><span class="line"></span><br><span class="line">low_d = 66155515334397587206334262409257611903325992908874597061630420749714627092070043054020890948099263820078299031372758328060568322822359627510248831960548842374360111368587702677016263988651746874367056185352095585037936034196599496577057035033718066207964292781685419156037246789689219471468151618592221802699</span><br><span class="line">bit = low_d.nbits()</span><br><span class="line">n = 99233273001596380809501393613886417854988989363311895592445631124571940638105064581031336422148895730117448547059137492090852484233539441265373247940823283633017582469362503632785297924194187912199716752955609363457416190782142095008241313065484612071705711161086869849047664563205898255359661312582650481473</span><br><span class="line">e = 3</span><br><span class="line">c = 175676150266403937224898870626869248307097859453341599800113943191154294552011908698393750389195590199207971365632903719917006078351629939912360175671032635640354766675409868021903917260597989036476083685690139071290022752606720020238530580507331902326179201548484337939338062870542095137303322195300197</span><br><span class="line"></span><br><span class="line">phase4(low_d,n,c,e)</span><br></pre></td></tr></table></figure>

<p>对于<code> root = (p - n).monic().small_roots(X=2 ^ 128, beta=0.4)</code><strong>，</strong><code>monic()</code>的作用是把p的系数变成1</p>
<p>这里的n应该不是我们给的n值</p>
<p>这串代码换成<code> root = p.monic().small_roots(X=2 ^ 128, beta=0.4)</code>，不会影响求解</p>
<h3 id="关于已知p的低位如何恢复p，以下是我的理解："><a href="#关于已知p的低位如何恢复p，以下是我的理解：" class="headerlink" title="关于已知p的低位如何恢复p，以下是我的理解："></a>关于已知p的低位如何恢复p，以下是我的理解：</h3><p>$$<br>设p的低位为p_0,假设p是一个512位的数<br>$$</p>
<p>$$<br>那p&#x3D;x×2^b+p_0，b＜512<br>$$</p>
<p>$$<br>然后因为x的系数不是1，所以需要p.monic()把x的系数变成1<br>$$</p>
<p><strong>如果存在错误，请大佬指出</strong></p>
<h1 id="十八、Franklin-Reiter-相关消息攻击"><a href="#十八、Franklin-Reiter-相关消息攻击" class="headerlink" title="十八、Franklin-Reiter 相关消息攻击"></a>十八、Franklin-Reiter 相关消息攻击</h1><p>将明文加上一个数，然后用同样的e和n加密成一个新的密文,e为3</p>
<p>这样题目一般长这样：</p>
<p><img src="/../images/RSA/23.png"></p>
<h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p><img src="/../images/RSA/24.png"></p>
<p><img src="/../images/RSA/25.png"></p>
<p><strong>Python实现</strong>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getM2</span>(<span class="params">a,b,c1,c2,n</span>):</span><br><span class="line">    a3 = <span class="built_in">pow</span>(a,<span class="number">3</span>,n)</span><br><span class="line">    b3 = <span class="built_in">pow</span>(b,<span class="number">3</span>,n)</span><br><span class="line">    first = c1-a3*c2+<span class="number">2</span>*b3</span><br><span class="line">    first = first % n</span><br><span class="line">    second = <span class="number">3</span>*b*(a3*c2-b3)</span><br><span class="line">    second = second % n</span><br><span class="line">    third = second*gmpy2.invert(first,n)</span><br><span class="line">    third = third % n</span><br><span class="line">    fourth = (third+b)*gmpy2.invert(a,n)</span><br><span class="line">    <span class="keyword">return</span> fourth % n</span><br></pre></td></tr></table></figure>

<h2 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">p = libnum.generate_prime(1024)</span><br><span class="line">q = libnum.generate_prime(1024)</span><br><span class="line">n = p * q</span><br><span class="line">e = 3</span><br><span class="line">c1=pow(m,e,n)</span><br><span class="line">c2=pow(m+23,e,n)</span><br><span class="line">print(&quot;n=&quot;,n)</span><br><span class="line">print(&quot;c1=&quot;,c1)</span><br><span class="line">print(&quot;c2=&quot;,c2)</span><br></pre></td></tr></table></figure>

<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getM2</span>(<span class="params">a,b,c1,c2,n</span>):</span><br><span class="line">    a3 = <span class="built_in">pow</span>(a,<span class="number">3</span>,n)</span><br><span class="line">    b3 = <span class="built_in">pow</span>(b,<span class="number">3</span>,n)</span><br><span class="line">    first = c1-a3*c2+<span class="number">2</span>*b3</span><br><span class="line">    first = first % n</span><br><span class="line">    second = <span class="number">3</span>*b*(a3*c2-b3)</span><br><span class="line">    second = second % n</span><br><span class="line">    third = second*gmpy2.invert(first,n)</span><br><span class="line">    third = third % n</span><br><span class="line">    fourth = (third+b)*gmpy2.invert(a,n)</span><br><span class="line">    <span class="keyword">return</span> fourth % n</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = -<span class="number">23</span>  <span class="comment">#这里padding1 = 0,padding2 = 23,所以b=-23</span></span><br><span class="line">c1 = <span class="number">175676150266641711916444091445781139277779003156556056759990312014697871894446590460729449316298376008489849677065205914793458959388232066629206406667357155787745931037869574771399224859869367943670440218253278560317330520488399820186869405944311596980008194439252102301970756589691462498043634547537253</span></span><br><span class="line">c2 = <span class="number">175676150266641711916444091445781139277779003156556056759990312014697871894446590460729449316298376224923256004570408208514033791620884417984796834735275720367596862370848324295530654005254716452155315511101075351067155901490533428950707819290823018393253109305648196157485509642713358863483579848456000</span></span><br><span class="line">n = <span class="number">9707282140608521534597213563664893782715260149781186731553485375967064221954996829298350139968314798018284178381942220275007118714479405726997513958731781270336969570682984804304509289064604490389662873420811943298401346416863405802733285090007438244315477659519649397202552302359138760555930108515441728335367340137429696475675969560470475825268961509793587655446220632264103246117705882070495699964049531607741206990087970869961102891452578255653506178059604251931305312230652370649515170079034023689675250251084053161308943618517038440570295690711731360323639242469371943498556697872269814453467858940956177847263</span></span><br><span class="line"></span><br><span class="line">M2 = getM2(a,b,c1,c2,n)</span><br><span class="line">m = M2 - <span class="number">23</span></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>

<h2 id="推导2"><a href="#推导2" class="headerlink" title="推导2"></a>推导2</h2><p><img src="/../images/RSA/26.png"></p>
<p><strong>那么一定有：</strong><br>$$<br>s(x) &#x3D; x^3 -c_2<br>$$</p>
<p>$$<br>t(x) &#x3D; f(x)^3 -c_1<br>$$</p>
<p><strong>可以被写成:</strong><br>$$<br>s(x)\equiv (x-M_2)×k_1(mod \quad n)<br>$$</p>
<p>$$<br>t(x)\equiv (x-M_2)×k_2(mod \quad n)<br>$$</p>
<p>$$<br>k_1和k_2是多项式<br>$$</p>
<p><strong>这里没有理解</strong></p>
<p>只要<br>$$<br>gcd(k_1,k_2)&#x3D;1,则<br>$$</p>
<p>$$<br>gcd(s(x),t(x))&#x3D;x-M_2,则<br>$$</p>
<p>$$<br>M_2 &#x3D; x-gcd(s(x),t(x))<br>$$</p>
<p>$$<br>由s(x)和t(x)的单调性可知有唯一解，因此k_1和k_2不可再因式分解，所以k_1,k_2互素<br>$$</p>
<p>$$<br>\therefore M_2是唯一的<br>$$</p>
<h1 id="十九、Boneh-Durfee-攻击"><a href="#十九、Boneh-Durfee-攻击" class="headerlink" title="十九、Boneh Durfee 攻击"></a>十九、Boneh Durfee 攻击</h1><h2 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h2><p>$$<br>当d \le n^{0.292}时，可以使用Boneh Durfee攻击<br>$$</p>
<p>不大理解原理</p>
<p>记个脚本：<a href="https://github.com/Gao-Chuan/RSA-and-LLL-attacks/blob/master/boneh_durfee.sage">Boneh Durfee.sage</a></p>
<p>笔者有进行微小的改动:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">############################################</span><br><span class="line"># Config</span><br><span class="line">##########################################</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Setting debug to true will display more informations</span><br><span class="line">about the lattice, the bounds, the vectors...</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">debug = True</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Setting strict to true will stop the algorithm (and</span><br><span class="line">return (-1, -1)) if we don&#x27;t have a correct </span><br><span class="line">upperbound on the determinant. Note that this </span><br><span class="line">doesn&#x27;t necesseraly mean that no solutions </span><br><span class="line">will be found since the theoretical upperbound is</span><br><span class="line">usualy far away from actual results. That is why</span><br><span class="line">you should probably use `strict = False`</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">strict = False</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">This is experimental, but has provided remarkable results</span><br><span class="line">so far. It tries to reduce the lattice as much as it can</span><br><span class="line">while keeping its efficiency. I see no reason not to use</span><br><span class="line">this option, but if things don&#x27;t work, you should try</span><br><span class="line">disabling it</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">helpful_only = True</span><br><span class="line">dimension_min = 7 # stop removing if lattice reaches that dimension</span><br><span class="line"></span><br><span class="line">############################################</span><br><span class="line"># Functions</span><br><span class="line">##########################################</span><br><span class="line"></span><br><span class="line"># display stats on helpful vectors</span><br><span class="line">def helpful_vectors(BB, modulus):</span><br><span class="line">    nothelpful = 0</span><br><span class="line">    for ii in range(BB.dimensions()[0]):</span><br><span class="line">        if BB[ii,ii] &gt;= modulus:</span><br><span class="line">            nothelpful += 1</span><br><span class="line"></span><br><span class="line">    print (nothelpful, &quot;/&quot;, BB.dimensions()[0], &quot; vectors are not helpful&quot;)</span><br><span class="line"></span><br><span class="line"># display matrix picture with 0 and X</span><br><span class="line">def matrix_overview(BB, bound):</span><br><span class="line">    for ii in range(BB.dimensions()[0]):</span><br><span class="line">        a = (&#x27;%02d &#x27; % ii)</span><br><span class="line">        for jj in range(BB.dimensions()[1]):</span><br><span class="line">            a += &#x27;0&#x27; if BB[ii,jj] == 0 else &#x27;X&#x27;</span><br><span class="line">            if BB.dimensions()[0] &lt; 60:</span><br><span class="line">                a += &#x27; &#x27;</span><br><span class="line">        if BB[ii, ii] &gt;= bound:</span><br><span class="line">            a += &#x27;~&#x27;</span><br><span class="line">        print (a)</span><br><span class="line"></span><br><span class="line"># tries to remove unhelpful vectors</span><br><span class="line"># we start at current = n-1 (last vector)</span><br><span class="line">def remove_unhelpful(BB, monomials, bound, current):</span><br><span class="line">    # end of our recursive function</span><br><span class="line">    if current == -1 or BB.dimensions()[0] &lt;= dimension_min:</span><br><span class="line">        return BB</span><br><span class="line"></span><br><span class="line">    # we start by checking from the end</span><br><span class="line">    for ii in range(current, -1, -1):</span><br><span class="line">        # if it is unhelpful:</span><br><span class="line">        if BB[ii, ii] &gt;= bound:</span><br><span class="line">            affected_vectors = 0</span><br><span class="line">            affected_vector_index = 0</span><br><span class="line">            # let&#x27;s check if it affects other vectors</span><br><span class="line">            for jj in range(ii + 1, BB.dimensions()[0]):</span><br><span class="line">                # if another vector is affected:</span><br><span class="line">                # we increase the count</span><br><span class="line">                if BB[jj, ii] != 0:</span><br><span class="line">                    affected_vectors += 1</span><br><span class="line">                    affected_vector_index = jj</span><br><span class="line"></span><br><span class="line">            # level:0</span><br><span class="line">            # if no other vectors end up affected</span><br><span class="line">            # we remove it</span><br><span class="line">            if affected_vectors == 0:</span><br><span class="line">                print (&quot;* removing unhelpful vector&quot;, ii)</span><br><span class="line">                BB = BB.delete_columns([ii])</span><br><span class="line">                BB = BB.delete_rows([ii])</span><br><span class="line">                monomials.pop(ii)</span><br><span class="line">                BB = remove_unhelpful(BB, monomials, bound, ii-1)</span><br><span class="line">                return BB</span><br><span class="line"></span><br><span class="line">            # level:1</span><br><span class="line">            # if just one was affected we check</span><br><span class="line">            # if it is affecting someone else</span><br><span class="line">            elif affected_vectors == 1:</span><br><span class="line">                affected_deeper = True</span><br><span class="line">                for kk in range(affected_vector_index + 1, BB.dimensions()[0]):</span><br><span class="line">                    # if it is affecting even one vector</span><br><span class="line">                    # we give up on this one</span><br><span class="line">                    if BB[kk, affected_vector_index] != 0:</span><br><span class="line">                        affected_deeper = False</span><br><span class="line">                # remove both it if no other vector was affected and</span><br><span class="line">                # this helpful vector is not helpful enough</span><br><span class="line">                # compared to our unhelpful one</span><br><span class="line">                if affected_deeper and abs(bound - BB[affected_vector_index, affected_vector_index]) &lt; abs(bound - BB[ii, ii]):</span><br><span class="line">                    print (&quot;* removing unhelpful vectors&quot;, ii, &quot;and&quot;, affected_vector_index)</span><br><span class="line">                    BB = BB.delete_columns([affected_vector_index, ii])</span><br><span class="line">                    BB = BB.delete_rows([affected_vector_index, ii])</span><br><span class="line">                    monomials.pop(affected_vector_index)</span><br><span class="line">                    monomials.pop(ii)</span><br><span class="line">                    BB = remove_unhelpful(BB, monomials, bound, ii-1)</span><br><span class="line">                    return BB</span><br><span class="line">    # nothing happened</span><br><span class="line">    return BB</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot; </span><br><span class="line">Returns:</span><br><span class="line">* 0,0   if it fails</span><br><span class="line">* -1,-1 if `strict=true`, and determinant doesn&#x27;t bound</span><br><span class="line">* x0,y0 the solutions of `pol`</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def boneh_durfee(pol, modulus, mm, tt, XX, YY):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Boneh and Durfee revisited by Herrmann and May</span><br><span class="line">    </span><br><span class="line">    finds a solution if:</span><br><span class="line">    * d &lt; N^delta</span><br><span class="line">    * |x| &lt; e^delta</span><br><span class="line">    * |y| &lt; e^0.5</span><br><span class="line">    whenever delta &lt; 1 - sqrt(2)/2 ~ 0.292</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # substitution (Herrman and May)</span><br><span class="line">    PR.&lt;u, x, y&gt; = PolynomialRing(ZZ)</span><br><span class="line">    Q = PR.quotient(x*y + 1 - u) # u = xy + 1</span><br><span class="line">    polZ = Q(pol).lift()</span><br><span class="line"></span><br><span class="line">    UU = XX*YY + 1</span><br><span class="line"></span><br><span class="line">    # x-shifts</span><br><span class="line">    gg = []</span><br><span class="line">    for kk in range(mm + 1):</span><br><span class="line">        for ii in range(mm - kk + 1):</span><br><span class="line">            xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk</span><br><span class="line">            gg.append(xshift)</span><br><span class="line">    gg.sort()</span><br><span class="line"></span><br><span class="line">    # x-shifts list of monomials</span><br><span class="line">    monomials = []</span><br><span class="line">    for polynomial in gg:</span><br><span class="line">        for monomial in polynomial.monomials():</span><br><span class="line">            if monomial not in monomials:</span><br><span class="line">                monomials.append(monomial)</span><br><span class="line">    monomials.sort()</span><br><span class="line">    </span><br><span class="line">    # y-shifts (selected by Herrman and May)</span><br><span class="line">    for jj in range(1, tt + 1):</span><br><span class="line">        for kk in range(floor(mm/tt) * jj, mm + 1):</span><br><span class="line">            yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk)</span><br><span class="line">            yshift = Q(yshift).lift()</span><br><span class="line">            gg.append(yshift) # substitution</span><br><span class="line">    </span><br><span class="line">    # y-shifts list of monomials</span><br><span class="line">    for jj in range(1, tt + 1):</span><br><span class="line">        for kk in range(floor(mm/tt) * jj, mm + 1):</span><br><span class="line">            monomials.append(u^kk * y^jj)</span><br><span class="line"></span><br><span class="line">    # construct lattice B</span><br><span class="line">    nn = len(monomials)</span><br><span class="line">    BB = Matrix(ZZ, nn)</span><br><span class="line">    for ii in range(nn):</span><br><span class="line">        BB[ii, 0] = gg[ii](0, 0, 0)</span><br><span class="line">        for jj in range(1, ii + 1):</span><br><span class="line">            if monomials[jj] in gg[ii].monomials():</span><br><span class="line">                BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY)</span><br><span class="line"></span><br><span class="line">    # Prototype to reduce the lattice</span><br><span class="line">    if helpful_only:</span><br><span class="line">        # automatically remove</span><br><span class="line">        BB = remove_unhelpful(BB, monomials, modulus^mm, nn-1)</span><br><span class="line">        # reset dimension</span><br><span class="line">        nn = BB.dimensions()[0]</span><br><span class="line">        if nn == 0:</span><br><span class="line">            print (&quot;failure&quot;)</span><br><span class="line">            return 0,0</span><br><span class="line"></span><br><span class="line">    # check if vectors are helpful</span><br><span class="line">    if debug:</span><br><span class="line">        helpful_vectors(BB, modulus^mm)</span><br><span class="line">    </span><br><span class="line">    # check if determinant is correctly bounded</span><br><span class="line">    det = BB.det()</span><br><span class="line">    bound = modulus^(mm*nn)</span><br><span class="line">    if det &gt;= bound:</span><br><span class="line">        print (&quot;We do not have det &lt; bound. Solutions might not be found.&quot;)</span><br><span class="line">        print (&quot;Try with highers m and t.&quot;)</span><br><span class="line">        if debug:</span><br><span class="line">            diff = (log(det) - log(bound)) / log(2)</span><br><span class="line">            print (&quot;size det(L) - size e^(m*n) = &quot;, floor(diff))</span><br><span class="line">        if strict:</span><br><span class="line">            return -1, -1</span><br><span class="line">    else:</span><br><span class="line">        print (&quot;det(L) &lt; e^(m*n) (good! If a solution exists &lt; N^delta, it will be found)&quot;)</span><br><span class="line"></span><br><span class="line">    # display the lattice basis</span><br><span class="line">    if debug:</span><br><span class="line">        matrix_overview(BB, modulus^mm)</span><br><span class="line"></span><br><span class="line">    # LLL</span><br><span class="line">    BB = BB.LLL()</span><br><span class="line"></span><br><span class="line">    # transform vector 1 &amp; 2 -&gt; polynomials 1 &amp; 2</span><br><span class="line">    PR.&lt;w,z&gt; = PolynomialRing(ZZ)</span><br><span class="line">    pol1 = pol2 = 0</span><br><span class="line">    for jj in range(nn):</span><br><span class="line">        pol1 += monomials[jj](w*z+1,w,z) * BB[0, jj] / monomials[jj](UU,XX,YY)</span><br><span class="line">        pol2 += monomials[jj](w*z+1,w,z) * BB[1, jj] / monomials[jj](UU,XX,YY)</span><br><span class="line"></span><br><span class="line">    # resultant</span><br><span class="line">    PR.&lt;q&gt; = PolynomialRing(ZZ)</span><br><span class="line">    rr = pol1.resultant(pol2)</span><br><span class="line"></span><br><span class="line">    if rr.is_zero() or rr.monomials() == [1]:</span><br><span class="line">        print (&quot;the two first vectors are not independant&quot;)</span><br><span class="line">        return 0, 0</span><br><span class="line">    </span><br><span class="line">    rr = rr(q, q)</span><br><span class="line"></span><br><span class="line">    # solutions</span><br><span class="line">    soly = rr.roots()</span><br><span class="line"></span><br><span class="line">    if len(soly) == 0:</span><br><span class="line">        print (&quot;Your prediction (delta) is too small&quot;)</span><br><span class="line">        return 0, 0</span><br><span class="line"></span><br><span class="line">    soly = soly[0][0]</span><br><span class="line">    ss = pol1(q, soly)</span><br><span class="line">    solx = ss.roots()[0][0]</span><br><span class="line"></span><br><span class="line">    #</span><br><span class="line">    return solx, soly</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    ############################################</span><br><span class="line">    # How To Use </span><br><span class="line">    ##########################################</span><br><span class="line"></span><br><span class="line">    #</span><br><span class="line">    # Problem (change those values)</span><br><span class="line">    #</span><br><span class="line"></span><br><span class="line">    # the modulus</span><br><span class="line">    N = 0xbadd260d14ea665b62e7d2e634f20a6382ac369cd44017305b69cf3a2694667ee651acded7085e0757d169b090f29f3f86fec255746674ffa8a6a3e1c9e1861003eb39f82cf74d84cc18e345f60865f998b33fc182a1a4ffa71f5ae48a1b5cb4c5f154b0997dc9b001e441815ce59c6c825f064fdca678858758dc2cebbc4d27L</span><br><span class="line"></span><br><span class="line">    # the public exponent</span><br><span class="line">    e = 0x11722b54dd6f3ad9ce81da6f6ecb0acaf2cbc3885841d08b32abc0672d1a7293f9856db8f9407dc05f6f373a2d9246752a7cc7b1b6923f1827adfaeefc811e6e5989cce9f00897cfc1fc57987cce4862b5343bc8e91ddf2bd9e23aea9316a69f28f407cfe324d546a7dde13eb0bd052f694aefe8ec0f5298800277dbab4a33bbL</span><br><span class="line">    c = 0xe3505f41ec936cf6bd8ae344bfec85746dc7d87a5943b3a7136482dd7b980f68f52c887585d1c7ca099310c4da2f70d4d5345d3641428797030177da6cc0d41e7b28d0abce694157c611697df8d0add3d900c00f778ac3428f341f47ecc4d868c6c5de0724b0c3403296d84f26736aa66f7905d498fa1862ca59e97f8f866cL</span><br><span class="line"></span><br><span class="line">    # the hypothesis on the private exponent (max 0.292)</span><br><span class="line">    delta = float(0.26) # d &lt; N^delta</span><br><span class="line"></span><br><span class="line">    #</span><br><span class="line">    # Lattice (tweak those values)</span><br><span class="line">    #</span><br><span class="line"></span><br><span class="line">    # you should tweak this (after a first run)</span><br><span class="line">    m = 4 # size of the lattice (bigger the better/slower)</span><br><span class="line"></span><br><span class="line">    # might not be a good idea to tweak these</span><br><span class="line">    t = int((1-2*delta) * m)  # optimization from Herrmann and May</span><br><span class="line">    X = 2*floor(N^delta)  # this _might_ be too much</span><br><span class="line">    Y = floor(N^(1/2))    # correct if p, q are ~ same size</span><br><span class="line"></span><br><span class="line">    #</span><br><span class="line">    # Don&#x27;t touch anything below</span><br><span class="line">    #</span><br><span class="line"></span><br><span class="line">    # Problem put in equation</span><br><span class="line">    P.&lt;x,y&gt; = PolynomialRing(ZZ)</span><br><span class="line">    A = int((N+1)/2)</span><br><span class="line">    pol = 1 + x * (A + y)</span><br><span class="line"></span><br><span class="line">    #</span><br><span class="line">    # Find the solutions!</span><br><span class="line">    #</span><br><span class="line"></span><br><span class="line">    # Checking bounds</span><br><span class="line">    if debug:</span><br><span class="line">        print (&quot;=== checking values ===&quot;)</span><br><span class="line">        print (&quot;* delta:&quot;, delta)</span><br><span class="line">        print (&quot;* delta &lt; 0.292&quot;, delta &lt; 0.292)</span><br><span class="line">        print (&quot;* size of e:&quot;, int(log(e)/log(2)))</span><br><span class="line">        print (&quot;* size of N:&quot;, int(log(N)/log(2)))</span><br><span class="line">        print (&quot;* m:&quot;, m, &quot;, t:&quot;, t)</span><br><span class="line"></span><br><span class="line">    # boneh_durfee</span><br><span class="line">    if debug:</span><br><span class="line">        print (&quot;=== running algorithm ===&quot;)</span><br><span class="line">        start_time = time.time()</span><br><span class="line"></span><br><span class="line">    solx, soly = boneh_durfee(pol, e, m, t, X, Y)</span><br><span class="line"></span><br><span class="line">    if solx &gt; 0:</span><br><span class="line">        print (&quot;=== solutions found ===&quot;)</span><br><span class="line">        if debug:</span><br><span class="line">            print (&quot;x:&quot;, solx)</span><br><span class="line">            print (&quot;y:&quot;, soly)</span><br><span class="line"></span><br><span class="line">        d = int(pol(solx, soly) / e)</span><br><span class="line">        print (&quot;d:&quot;, d)</span><br><span class="line">        m = pow(c,d,N)</span><br><span class="line">        print(long_to_bytes(int(m)))</span><br><span class="line"></span><br><span class="line">    if debug:</span><br><span class="line">        print(&quot;=== %s seconds ===&quot; % (time.time() - start_time))</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>



<h1 id="二十、AMM开根"><a href="#二十、AMM开根" class="headerlink" title="二十、AMM开根"></a>二十、AMM开根</h1><p>参考：<a href="https://zhuanlan.zhihu.com/p/623410303">宸极实验室—『CTF』AMM 算法详解与应用 - 知乎 (zhihu.com)</a></p>
<p><a href="https://arxiv.org/pdf/1111.4877.pdf">1111.4877.pdf (arxiv.org)</a></p>
<h2 id="算法浅析"><a href="#算法浅析" class="headerlink" title="算法浅析"></a>算法浅析</h2><h3 id="当e-2时"><a href="#当e-2时" class="headerlink" title="当e&#x3D;2时"></a>当e&#x3D;2时</h3><p><img src="/../images/RSA/46.png"></p>
<p><img src="/../images/RSA/47.png"></p>
<h3 id="当e-2时-1"><a href="#当e-2时-1" class="headerlink" title="当e&gt;2时"></a>当e&gt;2时</h3><p>证明过程不太理解</p>
<h2 id="2021黑盾杯Crypto1"><a href="#2021黑盾杯Crypto1" class="headerlink" title="2021黑盾杯Crypto1"></a>2021黑盾杯Crypto1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e = 1801</span><br><span class="line">c = pow(m,e,p)</span><br><span class="line"></span><br><span class="line">c =821562155714228494350968286343241874202753771452745916900616612053610190986294297934462409534126095213198464996196364868528238538372119009517541428785632007137206972918081643841690069171088425923887930051635578719252415693144672179185417101210954906623326286804995637775062840407550493095027500638719998 </span><br><span class="line">p =19897846550210846565807788524492364050901480736489979129040638436463635149815428186161001280958415730930156556581274966745574164608778242980049611665461488306439665507971670397595035647317930606555771720849158745264269952668944940061576328219674721623208805067371087817766416300084129945316973502412996143 </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">e = <span class="number">1801</span></span><br><span class="line">c = <span class="number">821562155714228494350968286343241874202753771452745916900616612053610190986294297934462409534126095213198464996196364868528238538372119009517541428785632007137206972918081643841690069171088425923887930051635578719252415693144672179185417101210954906623326286804995637775062840407550493095027500638719998</span></span><br><span class="line">p = <span class="number">19897846550210846565807788524492364050901480736489979129040638436463635149815428186161001280958415730930156556581274966745574164608778242980049611665461488306439665507971670397595035647317930606555771720849158745264269952668944940061576328219674721623208805067371087817766416300084129945316973502412996143</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">AMM</span>(<span class="params">o, r, q</span>):</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n----------------------------------------------------------------------------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Start to run Adleman-Manders-Miller Root Extraction Method&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Try to find one &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(r, o, q))</span><br><span class="line">    g = GF(q)</span><br><span class="line">    o = g(o)</span><br><span class="line">    p = g(random.randint(<span class="number">1</span>, q))</span><br><span class="line">    <span class="keyword">while</span> p ^ ((q-<span class="number">1</span>) // r) == <span class="number">1</span>:</span><br><span class="line">        p = g(random.randint(<span class="number">1</span>, q))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+] Find p:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(p))</span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    s = q - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> s % r == <span class="number">0</span>:</span><br><span class="line">        t += <span class="number">1</span></span><br><span class="line">        s = s // r</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+] Find s:&#123;&#125;, t:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(s, t))</span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (k * s + <span class="number">1</span>) % r != <span class="number">0</span>:</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    alp = (k * s + <span class="number">1</span>) // r</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[+] Find alp:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(alp))</span><br><span class="line">    a = p ^ (r**(t-<span class="number">1</span>) * s)</span><br><span class="line">    b = o ^ (r*alp - <span class="number">1</span>)</span><br><span class="line">    c = p ^ s</span><br><span class="line">    h = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, t):</span><br><span class="line">        d = b ^ (r^(t-<span class="number">1</span>-i))</span><br><span class="line">        <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;[+] Calculating DLP...&#x27;</span>)</span><br><span class="line">            j = - discrete_log(a, d)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;[+] Finish DLP...&#x27;</span>)</span><br><span class="line">        b = b * (c^r)^j</span><br><span class="line">        h = h * c^j</span><br><span class="line">        c = c ^ r</span><br><span class="line">    result = o^alp * h</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Finished in &#123;&#125; seconds.&quot;</span>.<span class="built_in">format</span>(end - start))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Find one solution: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(result))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findAllPRoot</span>(<span class="params">p, e</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Start to find all the Primitive &#123;:#x&#125;th root of 1 modulo &#123;&#125;.&quot;</span>.<span class="built_in">format</span>(e, p))</span><br><span class="line">    start = time.time()</span><br><span class="line">    proot = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(proot) &lt; e:</span><br><span class="line">        proot.add(<span class="built_in">pow</span>(random.randint(<span class="number">2</span>, p-<span class="number">1</span>), (p-<span class="number">1</span>)//e, p))</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Finished in &#123;&#125; seconds.&quot;</span>.<span class="built_in">format</span>(end - start))</span><br><span class="line">    <span class="keyword">return</span> proot</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findAllSolutions</span>(<span class="params">mp, proot, cp, p</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Start to find all the &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;.&quot;</span>.<span class="built_in">format</span>(e, cp, p))</span><br><span class="line">    start = time.time()</span><br><span class="line">    all_mp = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> root <span class="keyword">in</span> proot:</span><br><span class="line">        mp2 = mp * root % p</span><br><span class="line">        <span class="keyword">assert</span>(<span class="built_in">pow</span>(mp2, e, p) == cp)</span><br><span class="line">        all_mp.add(mp2)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Finished in &#123;&#125; seconds.&quot;</span>.<span class="built_in">format</span>(end - start))</span><br><span class="line">    <span class="keyword">return</span> all_mp</span><br><span class="line"></span><br><span class="line">mp = AMM(c,e,p)</span><br><span class="line">p_proot = findAllPRoot(p, e)</span><br><span class="line">mps = findAllSolutions(mp, p_proot, c, p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mps:</span><br><span class="line">	flag = long_to_bytes(<span class="built_in">int</span>(i))</span><br><span class="line">	<span class="keyword">if</span> <span class="string">b&#x27;flag&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">		<span class="built_in">print</span>(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2022NISACTF——rrssaa2"><a href="#2022NISACTF——rrssaa2" class="headerlink" title="2022NISACTF——rrssaa2"></a>2022NISACTF——rrssaa2</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import random</span><br><span class="line">import libnum</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">def gen():</span><br><span class="line">    p = 1801 * random.getrandbits(1012) + 1</span><br><span class="line">    while not isPrime(p):</span><br><span class="line">        p = 1801 * random.getrandbits(1012) + 1</span><br><span class="line">    return p</span><br><span class="line">p=gen()</span><br><span class="line">q=gen()</span><br><span class="line">e=1801</span><br><span class="line">n=p*q</span><br><span class="line">flag=&#x27;NSSCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;&#x27;</span><br><span class="line">flag=flag+&#x27;yhe92871899hihiohh97709ujojl;lhdiwoqu903YE98Y299HDY8W9EYRW8!$$%!$!$FSR@#$@%FSEGDRYERYHRWER@$%^$^DGTW%$^&amp;GRWR@$%@FASFSFQFSTGW#TWGARWQ$@%WGVDSGADQR@%TGVDSFASDATWEGHWE%@$GSDVSFQATY$^#^%@$!RAFSDGDRTW&#x27;</span><br><span class="line"></span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(&#x27;e=&#x27;,e)</span><br><span class="line">print(&#x27;p=&#x27;,p)</span><br><span class="line">print(&#x27;q=&#x27;,q)</span><br><span class="line">print(&#x27;c=&#x27;,c)</span><br><span class="line"></span><br><span class="line">#e= 1801</span><br><span class="line">#p= 49610229352589717245227429186510630298995334563536199979797365135356894947505595171590737127611751124743823204969291853243936699113293137172961540731655194113111189561603261168928406442577570919901769348742992633428864861175880441682752947688509869668929473479230018031647980097396415380123118521799468844841</span><br><span class="line">#q= 21081926656979729045764441706195868361643779935106260715219328461497406780587336009385210898093496090213306812904410650499587043699660339207567766840318127296396962037273317168795761421233687815992929975284592353117739413561939283754964442896468496199833988666060155459156116345763999855126020972915904618043</span><br><span class="line">#c= 601596145172542477058917394071994325109856881057412872218601643742101914635753765731910337249806643258952637146341530783703613931109366648847232809553067941206928974141651198815184695746636818122414926015513095322872645068410957200062317958684872682628646759817233433643987003499153702624673493727886566639667597997520471371146056861227114668317633291934130573158877960548655006208725827943739971068608175370661619328559766977175575896437656636083179668805135271793023165492681941002853661303072959879197775224449456951125268328000206540965011249895216257583247180682482954741912101069920760903900864428405997751199</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2</span><br><span class="line">import time</span><br><span class="line">import random</span><br><span class="line">from tqdm import tqdm</span><br><span class="line"></span><br><span class="line">e= 1801</span><br><span class="line">p= 49610229352589717245227429186510630298995334563536199979797365135356894947505595171590737127611751124743823204969291853243936699113293137172961540731655194113111189561603261168928406442577570919901769348742992633428864861175880441682752947688509869668929473479230018031647980097396415380123118521799468844841</span><br><span class="line">q= 21081926656979729045764441706195868361643779935106260715219328461497406780587336009385210898093496090213306812904410650499587043699660339207567766840318127296396962037273317168795761421233687815992929975284592353117739413561939283754964442896468496199833988666060155459156116345763999855126020972915904618043</span><br><span class="line">c= 601596145172542477058917394071994325109856881057412872218601643742101914635753765731910337249806643258952637146341530783703613931109366648847232809553067941206928974141651198815184695746636818122414926015513095322872645068410957200062317958684872682628646759817233433643987003499153702624673493727886566639667597997520471371146056861227114668317633291934130573158877960548655006208725827943739971068608175370661619328559766977175575896437656636083179668805135271793023165492681941002853661303072959879197775224449456951125268328000206540965011249895216257583247180682482954741912101069920760903900864428405997751199</span><br><span class="line"></span><br><span class="line">def AMM(o, r, q):</span><br><span class="line">    start = time.time()</span><br><span class="line">    print(&#x27;\n----------------------------------------------------------------------------------&#x27;)</span><br><span class="line">    print(&#x27;Start to run Adleman-Manders-Miller Root Extraction Method&#x27;)</span><br><span class="line">    print(&#x27;Try to find one &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;&#x27;.format(r, o, q))</span><br><span class="line">    g = GF(q)</span><br><span class="line">    o = g(o)</span><br><span class="line">    p = g(random.randint(1, q))</span><br><span class="line">    while p ^ ((q-1) // r) == 1:</span><br><span class="line">        p = g(random.randint(1, q))</span><br><span class="line">    print(&#x27;[+] Find p:&#123;&#125;&#x27;.format(p))</span><br><span class="line">    t = 0</span><br><span class="line">    s = q - 1</span><br><span class="line">    while s % r == 0:</span><br><span class="line">        t += 1</span><br><span class="line">        s = s // r</span><br><span class="line">    print(&#x27;[+] Find s:&#123;&#125;, t:&#123;&#125;&#x27;.format(s, t))</span><br><span class="line">    k = 1</span><br><span class="line">    while (k * s + 1) % r != 0:</span><br><span class="line">        k += 1</span><br><span class="line">    alp = (k * s + 1) // r</span><br><span class="line">    print(&#x27;[+] Find alp:&#123;&#125;&#x27;.format(alp))</span><br><span class="line">    a = p ^ (r**(t-1) * s)</span><br><span class="line">    b = o ^ (r*alp - 1)</span><br><span class="line">    c = p ^ s</span><br><span class="line">    h = 1</span><br><span class="line">    for i in range(1, t):</span><br><span class="line">        d = b ^ (r^(t-1-i))</span><br><span class="line">        if d == 1:</span><br><span class="line">            j = 0</span><br><span class="line">        else:</span><br><span class="line">            print(&#x27;[+] Calculating DLP...&#x27;)</span><br><span class="line">            j = - discrete_log(a, d)</span><br><span class="line">            print(&#x27;[+] Finish DLP...&#x27;)</span><br><span class="line">        b = b * (c^r)^j</span><br><span class="line">        h = h * c^j</span><br><span class="line">        c = c ^ r</span><br><span class="line">    result = o^alp * h</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start))</span><br><span class="line">    print(&#x27;Find one solution: &#123;&#125;&#x27;.format(result))</span><br><span class="line">    return result</span><br><span class="line">def findAllPRoot(p, e):</span><br><span class="line">    print(&quot;Start to find all the Primitive &#123;:#x&#125;th root of 1 modulo &#123;&#125;.&quot;.format(e, p))</span><br><span class="line">    start = time.time()</span><br><span class="line">    proot = set()</span><br><span class="line">    while len(proot) &lt; e:</span><br><span class="line">        proot.add(pow(random.randint(2, p-1), (p-1)//e, p))</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start))</span><br><span class="line">    return proot</span><br><span class="line"></span><br><span class="line">def findAllSolutions(mp, proot, cp, p):</span><br><span class="line">    print(&quot;Start to find all the &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;.&quot;.format(e, cp, p))</span><br><span class="line">    start = time.time()</span><br><span class="line">    all_mp = set()</span><br><span class="line">    for root in proot:</span><br><span class="line">        mp2 = mp * root % p</span><br><span class="line">        assert(pow(mp2, e, p) == cp)</span><br><span class="line">        all_mp.add(mp2)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start))</span><br><span class="line">    return all_mp</span><br><span class="line"></span><br><span class="line">cp = c % p</span><br><span class="line">cq = c % q</span><br><span class="line"></span><br><span class="line">mp = AMM(cp,e,p)</span><br><span class="line">mq = AMM(cq,e,q)</span><br><span class="line"></span><br><span class="line">p_proot = findAllPRoot(p,e)</span><br><span class="line">q_proot = findAllPRoot(q,e)</span><br><span class="line">mps = findAllSolutions(mp, p_proot, cp, p)</span><br><span class="line">mqs = findAllSolutions(mq,q_proot,cq,q)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#遍历所有可能</span><br><span class="line">for mpp in tqdm(mps):</span><br><span class="line">    for mqq in mqs:</span><br><span class="line">        ai = [int(mpp),int(mqq)]</span><br><span class="line">        mi = [p,q]</span><br><span class="line">        m = CRT_list(ai,mi)</span><br><span class="line">        flag = long_to_bytes(m)</span><br><span class="line">        if b&#x27;NSSCTF&#x27; in flag:</span><br><span class="line">            print(flag)</span><br><span class="line">            break</span><br></pre></td></tr></table></figure>

<p><code>mp = AMM(cp,e,p)</code>，<code>mq = AMM(cq,e,q)</code>解$mp \equiv m^e \mod p$和$mq \equiv m^e \mod q$</p>
<p><code>p_proot = findAllPRoot(p,e)</code>，<code>q_proot = findAllPRoot(q,e)</code>这个不太明白求的啥</p>
<p><code>mps = findAllSolutions(mp, p_proot, cp, p)</code>，<code>mqs = findAllSolutions(mq,q_proot,cq,q)</code>这应该是m的所有情况</p>
<p>最后遍历求解CRT</p>
<h1 id="二十一、共模攻击变形"><a href="#二十一、共模攻击变形" class="headerlink" title="二十一、共模攻击变形"></a>二十一、共模攻击变形</h1><h2 id="情况1：e1-e2不互素"><a href="#情况1：e1-e2不互素" class="headerlink" title="情况1：e1,e2不互素"></a>情况1：e1,e2不互素</h2><p><strong>e1,e2不互素，即gcd(e1,e2)!&#x3D;1</strong></p>
<p><strong>令t &#x3D; gcd(e1,e2)</strong><br>$$<br>由文章前面的共模攻击式子c_{1}^{x}×c_2^{y}(mod \quad n) \equiv m^{t}(mod \quad n)<br>$$</p>
<p>$$<br>则m^{t} &#x3D; k×n + c_{1}^{x}×c_2^{y}<br>$$</p>
<h2 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import gmpy2</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">k = 1024</span><br><span class="line">while 1:</span><br><span class="line">    flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">    m = libnum.s2n(flag)</span><br><span class="line">    p = libnum.generate_prime(k)</span><br><span class="line">    q = libnum.generate_prime(k)</span><br><span class="line">    n = p * q</span><br><span class="line">    tmp = libnum.generate_prime(4)</span><br><span class="line">    e1 = libnum.generate_prime(5) * tmp</span><br><span class="line">    e2 = libnum.generate_prime(5) * tmp</span><br><span class="line">    tmp2 = gmpy2.bit_length(m ** tmp) - gmpy2.bit_length(n)</span><br><span class="line">    if e1 != e2 and tmp2 &lt; 5:</span><br><span class="line">        break</span><br><span class="line">    k += tmp2 // 2</span><br><span class="line">print(flag)</span><br><span class="line">c1 = pow(m, e1, n)</span><br><span class="line">c2 = pow(m, e2, n)</span><br><span class="line">print(&quot;e1=&quot;, e1)</span><br><span class="line">print(&quot;e2=&quot;, e2)</span><br><span class="line">print(&quot;n=&quot;, n)</span><br><span class="line">print(&quot;c1=&quot;, c1)</span><br><span class="line">print(&quot;c2=&quot;, c2)</span><br></pre></td></tr></table></figure>

<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n= <span class="number">19474678913649097258390489993698634404112354172317306010023197847156694099670721761327194851970009271581549666788645497433190056135299423904183196428211720097778383008788705222994940143654464858441904620596484596346512546258221838544477940550376396677203257379949758730938581258992871705570847922776599616915733519585215572243928291618659043825329209345158300980691318185817290940425730134338749693091572842746733673342908172635417820608641805710421185052054000066207235255914663558591276027965181111243394719238943210391460931903101227440963377665461618104834863663740849922340905053750264657441352910246039293609643367940051324465147023474243224362152913517822894213761331561654655858920728085714369310139310386378474433039346461001868308134135362298325390206249247092133402040374395517273415606661403933705390825879552537393088886944922940487264224704885259420580277404667343842400220922804505835566052496110575752288394130226305637409179824473762478444360732822396393944426314881434132408204638085190098614163118051368269424038473349620971134861134137603699098720960181628570503797869982072783254713064905276853023938893875178460261697758362279989965392026805157348131834895995251415105178938979192148748647493811243573203145688897449401412372097795961539772849014562325239101253682046332206756094565291781</span></span><br><span class="line">e1 = <span class="number">319</span></span><br><span class="line">e2 = <span class="number">341</span></span><br><span class="line">c1 = <span class="number">16842097487578929747386013933836071311636435180786000333183479444850916208499056286293221277419396487143548868011121687411419006933297728370852363750322035680140458385936896809702003278914760352066710772774379515794440911494571101054875370632979664627428088945978102656878992542056983359586963711617334422080699715850848901481895781439634119925073029944688100348409613155880974748998758622098311059613939789339423339992132464171174123104436742936539749038386100174285273092064872962110961174532333866649632099684432465861670566720188498096950478835609006702822832535569740279550564709018652584734393583891347283516641024482147655707303660809974605932283320751419752851004868386620860461774410841309524864393100974165736049945040671353974167039407791367110609972671777553345885631486896801519491159873075020494968481046661647097363668961350255292613493490519231790196337146698217641580380569238319274538735600036562195973041732846936373910618424923755644620392149451787477945923716935327549760919227680773560668256346588136223461189956081899893679417046303238188505187585679903927787518164246954458038170693402350055866777159897918079058465076803320663064873176102836775732642340270760113509631774744076482366969652954901984726320611635556882140186758717303319295278262405745747267175536641440355265151505738959</span></span><br><span class="line">c2 = <span class="number">11882419292262439388395815852169631237359134106011110793207416772099869060262304736871190266614921889223922727440751243951466369747401979020372872126460796866664490364229918484890553550414970820526722511330604028963190564560830894577762895849951145089870332361493102336506523261215879020663433735193233792538730505795660978392622223090008019752787535539689555015412414444298098846960023750837015644522855346725774495736882904164804735576222229185641453887995254842617056884667691768874085981289380925271203339962843240701273777372488844619509988897713312382774750017391240294108840393576680678601939550735366514705783804254529195233406624997337321421836044641264988646831661593186219714359601246011436856726899017296455579882011341041715930436749266151654712590104320876653590775164982704496112329832684267637475509804745971848571244643987731101962814164824430221486667978354093400800773401904607552500150032713777036941455622982693087120359170639049551330567886289216980990770976252462925360856027498185494737491836702182511810948819989831212562989917938207204621062194173157840590954059982130144900289024500353220236075815227481710808333065928147587957726526698953469304559157057103278333800243155467404900528439556287027032253160322365280145370850141701695659907382027163725331629255756528099014003526137133</span></span><br><span class="line"></span><br><span class="line">t = gmpy2.gcd(e1,e2)</span><br><span class="line"><span class="keyword">if</span> t == <span class="number">1</span>:</span><br><span class="line">    s,x,y = gmpy2.gcdext(e1,e2)</span><br><span class="line">    m = (<span class="built_in">pow</span>(c1,x,n)*<span class="built_in">pow</span>(c2,y,n))%n</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    s,x,y = gmpy2.gcdext(e1,e2)</span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        m = gmpy2.iroot((<span class="built_in">pow</span>(c1,x,n)*<span class="built_in">pow</span>(c2,y,n)+k*n)%n,t)</span><br><span class="line">        <span class="keyword">if</span> m[<span class="number">1</span>]:</span><br><span class="line">            <span class="built_in">print</span>(long_to_bytes(m[<span class="number">0</span>]))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="情况2：给e1与e2的积"><a href="#情况2：给e1与e2的积" class="headerlink" title="情况2：给e1与e2的积"></a>情况2：给e1与e2的积</h2><p><strong>爆破e1，剩下的步骤和上题一样</strong></p>
<h2 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import gmpy2</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">k = 1024</span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line"></span><br><span class="line">while 1:</span><br><span class="line">    p = libnum.generate_prime(k)</span><br><span class="line">    q = libnum.generate_prime(k)</span><br><span class="line">    n = p * q</span><br><span class="line">    tmp = libnum.generate_prime(4)</span><br><span class="line">    e1 = libnum.generate_prime(5) * tmp</span><br><span class="line">    e2 = libnum.generate_prime(5) * tmp</span><br><span class="line">    tmp2 = gmpy2.bit_length(m ** tmp) - gmpy2.bit_length(n)</span><br><span class="line">    if e1 != e2 and tmp2 &lt; 5:</span><br><span class="line">        break</span><br><span class="line">    k += tmp2 // 2</span><br><span class="line">print(flag)</span><br><span class="line">c1 = pow(m, e1, n)</span><br><span class="line">c2 = pow(m, e2, n)</span><br><span class="line">print(&quot;e1*e2=&quot;, e1 * e2)</span><br><span class="line">print(&quot;n=&quot;, n)</span><br><span class="line">print(&quot;c1=&quot;, c1)</span><br><span class="line">print(&quot;c2=&quot;, c2)</span><br></pre></td></tr></table></figure>

<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e1e2 = <span class="number">83317</span></span><br><span class="line">n = <span class="number">19361442710572745971265661179912428614335978862294499554478708154961900725571203060796104846289397242207304532314240136962004100859120350866177200389723065658762704195258332314791286248842309297348039111045266185355903400590470820183877252896166548216731371364979378507526744861441605219478410567943584909399458417880788827318597539692741384869777249157338164956516233081381729474311604082892186490173033244693551617094635430697205804969501877592642316320873084247185093376277647579480643486369145925195734181193015900482737320548696928588870712293186252013457131251209473809656777543374500592007808404407059561585875569527546497652518580045435210514546460508584320606314122520882426004609258608147903667923350952560862343978526661419457923377730038903725129920335146125419046956321000719022303404018007514471776998828154744785228693422230685108494515083105086516002742258455143048441346760686508352771381755359768486489070279892078844716848637514485979868052449468414483027672075237348001190373461535494802211938683204976566773050049547807712425194913096401165728862378611187510228222428679755307056276133497536735863204478321549958435946853973687386589497836951783399492540878952618631792625025126620608024559471293131768988077589502325651357976822933654550846615039529755326862460868499406888969184042128071</span></span><br><span class="line">c1 = <span class="number">8461455935702774839606732696628583481106108739457157757237961493721249315707058365854463354773540401038228236301572933195823206925383589280380438344346918293151928169930134045632956081184945062566817678757614816611860006425866597730747864519352309046720733870943424680296477704991108084039103348714387678260925701357278152801810444616098214964231942511332731906589339642434586792884729500618636404879133808745489823990051381479316035290316511507860259556699539853817794899071305575419968794233519130191693519669424965740754005557268523536259961342893331243822271702601491251166024629032785331163334845458532041066873062181204642511730061193181806412423310871852101503714865811232852678040552266896756835104015126426669170036333066668010437674021104622132437422087899276215087590613842963706972249810831528040008304175911799215946803926073839260039708714727246670180210772138254229999545871929350538204078637835690649108982156556159082202035891312400182426109033284706424624286874595070797624804888642649414098331802113837492380725023537502746076689560748513729573164798419260068335949704460969862627638288475890309143274515210188524564546972793051029662396980537597835874860939675476734819945549433268818379519178647303476509820821756282974287073312744339124424284365074314353072957540119217061097316369179812</span></span><br><span class="line">c2 = <span class="number">6204846642785521340470513546335239064256758077473460303136152226321426573866713276868303467627807818878464124001025948893472833684203082226317608116339642653526005250588488719287359040352790572959995584093188339849695217956472022875459556871491299322868787108334073007332501731796096022506406756118808831646084743403979543281704069120640233328839980099290857269846287187888156728145277024309531510105331797866833685076835273931526615042292719970926967658919153638762985362453791732734631621502983351581711188066449777097203043897589205329057225446193852593056040301734809364853181753118739604843784216536562612033307359103893806510482236157475021740603255590914121641809865052126419196638531405221094438510231726208366630512008162663744010330103156199459170979721924714894281792427651932643530734043790246173905509400532261288534889712214483873969552991657537356198890952147322594953541508366871552561029095676172024539741525694906063413062943730465813047155464168544196529490081901356676689826701155342513241655234549380041635792150618405682571311160853526719882812618473055821608217492122688669131559593093840370537049894579011917334477512297137182557102626033423909278319394496823138854073015927815382203590762482110896381565689852266596980436613904791614372199019839459027972129220041158226866818118745059</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getM</span>(<span class="params">c1,c2,n,e1,e2</span>):</span><br><span class="line">    t = gmpy2.gcd(e1,e2)</span><br><span class="line">    s,x,y = gmpy2.gcdext(e1,e2)</span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">1</span>:</span><br><span class="line">        m = (<span class="built_in">pow</span>(c1,x,n)*<span class="built_in">pow</span>(c2,y,n)) % n</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">            m = gmpy2.iroot((<span class="built_in">pow</span>(c1,x,n)*<span class="built_in">pow</span>(c2,y,n)%n + k*n),t)</span><br><span class="line">            <span class="keyword">if</span> m[<span class="number">1</span>]:</span><br><span class="line">                <span class="built_in">print</span>(long_to_bytes(m[<span class="number">0</span>]))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e1 <span class="keyword">in</span> trange(<span class="number">2</span>,e1e2):</span><br><span class="line">    <span class="keyword">if</span> e1e2 % e1 == <span class="number">0</span>:</span><br><span class="line">        e2 = e1e2 // e1</span><br><span class="line">        getM(c1,c2,n,e1,e2)</span><br></pre></td></tr></table></figure>



<h1 id="二十二、有限域开根"><a href="#二十二、有限域开根" class="headerlink" title="二十二、有限域开根"></a>二十二、有限域开根</h1><p><img src="/../images/RSA/27.png"></p>
<h2 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import gmpy2</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">p = libnum.generate_prime(512)</span><br><span class="line">q = libnum.generate_prime(512)</span><br><span class="line">e = 3</span><br><span class="line">while 1:</span><br><span class="line">    p = libnum.generate_prime(512)</span><br><span class="line">    q = libnum.generate_prime(512)</span><br><span class="line">    if (p-1)%e==0 and (q-1)%e==0:</span><br><span class="line">        break</span><br><span class="line">n=p*q</span><br><span class="line">c=pow(m,e,n)</span><br><span class="line">print(flag)</span><br><span class="line">print(&quot;n=&quot;, n)</span><br><span class="line">print(&quot;p=&quot;, p)</span><br><span class="line">print(&quot;q=&quot;, q)</span><br><span class="line">print(&quot;c=&quot;, c)</span><br><span class="line">print(&quot;e=&quot;, e)</span><br></pre></td></tr></table></figure>

<p><strong>exp:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">n= 121176731012001774237554071517040520577093770585955284890111028833900485089366205861576854434071097785955426453274958947131350219079586688700799708437106991966824326227553177949832737829545215209285207091478265075229855158613766143623542365107905898499683217014784504271360637893610456050551417371109126935821</span><br><span class="line">p= 10294176862573184144889118081794828535963562542939700829097058698645551123632548241827576303461162025955304087621384738534602927608805520033003847729857913</span><br><span class="line">q= 11771386156436390390172944429184462613445295630519275927285184850353982566452678162531101585333236216451833768663392626736188991033254470541757714968120117</span><br><span class="line">c= 175676150266389842655713989253086844293109999214244727442799978297124143551654073679017014994908058988402189906092896028837004244573045641687986771129134527809468892554529220740843297716181676421633164172513308088943719087506588619693643820162046871380739428618325418829978973366928721397921633930049637</span><br><span class="line">e= 3</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(p))</span><br><span class="line">f = x^e - c</span><br><span class="line">f.monic()</span><br><span class="line">res1 = f.roots()</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(q))</span><br><span class="line">f = x^e - c</span><br><span class="line">f.monic()</span><br><span class="line">res2 = f.roots()</span><br><span class="line"></span><br><span class="line">for i in res1:</span><br><span class="line">    for j in res2:</span><br><span class="line">        n_list = [int(i[0]),int(j[0])]</span><br><span class="line">        a_list = [p,q]</span><br><span class="line">        m = CRT_list(n_list,a_list)</span><br><span class="line">        flag = long_to_bytes(int(m))</span><br><span class="line">        print(flag)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h2 id="2022强网杯——ASR"><a href="#2022强网杯——ASR" class="headerlink" title="2022强网杯——ASR"></a>2022强网杯——ASR</h2><p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import getPrime</span><br><span class="line">from secret import falg</span><br><span class="line">pad = lambda s:s + bytes([(len(s)-1)%16+1]*((len(s)-1)%16+1))</span><br><span class="line"></span><br><span class="line">n = getPrime(128)**2 * getPrime(128)**2 * getPrime(128)**2 * getPrime(128)**2</span><br><span class="line">e = 3</span><br><span class="line"></span><br><span class="line">flag = pad(flag)</span><br><span class="line">print(flag)</span><br><span class="line">assert(len(flag) &gt;= 48)</span><br><span class="line">m = int.from_bytes(flag,&#x27;big&#x27;)</span><br><span class="line">c = pow(m,e,n)</span><br><span class="line"></span><br><span class="line">print(f&#x27;n = &#123;n&#125;&#x27;)</span><br><span class="line">print(f&#x27;e = &#123;e&#125;&#x27;)</span><br><span class="line">print(f&#x27;c = &#123;c&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">n = </span><br><span class="line">e = 3</span><br><span class="line">c = </span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>$m^e &gt; n$，不能直接开e次方</p>
<p>$\because c \equiv m^e \mod n$</p>
<p>发现$n &#x3D; (p×q×r×t)^2$<br>网站分解出$p,q,r,t$<br>则c满足下式</p>
<p><img src="/../images/RSA/48.png"></p>
<p>有限域开根求出$mp,mq,mr,mt$<br>然后用中国剩余定理</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n = <span class="number">8250871280281573979365095715711359115372504458973444367083195431861307534563246537364248104106494598081988216584432003199198805753721448450911308558041115465900179230798939615583517756265557814710419157462721793864532239042758808298575522666358352726060578194045804198551989679722201244547561044646931280001</span></span><br><span class="line">c = <span class="number">945272793717722090962030960824180726576357481511799904903841312265308706852971155205003971821843069272938250385935597609059700446530436381124650731751982419593070224310399320617914955227288662661442416421725698368791013785074809691867988444306279231013360024747585261790352627234450209996422862329513284149</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">p = <span class="number">218566259296037866647273372633238739089</span></span><br><span class="line">q = <span class="number">223213222467584072959434495118689164399</span></span><br><span class="line">r = <span class="number">225933944608558304529179430753170813347</span></span><br><span class="line">t = <span class="number">260594583349478633632570848336184053653</span></span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(p))</span><br><span class="line">f = x^e-c</span><br><span class="line">f = f.monic()</span><br><span class="line">mp = f.roots()</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(q))</span><br><span class="line">f = x^e-c</span><br><span class="line">f = f.monic()</span><br><span class="line">mq = f.roots()</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(r))</span><br><span class="line">f = x^e-c</span><br><span class="line">f = f.monic()</span><br><span class="line">mr = f.roots()</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(t))</span><br><span class="line">f = x^e-c</span><br><span class="line">f = f.monic()</span><br><span class="line">mt = f.roots()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mp:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> mq:</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> mr:</span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> mt:</span><br><span class="line">                m_list = [<span class="built_in">int</span>(i[<span class="number">0</span>]),<span class="built_in">int</span>(j[<span class="number">0</span>]),<span class="built_in">int</span>(k[<span class="number">0</span>]),<span class="built_in">int</span>(b[<span class="number">0</span>])]</span><br><span class="line">                a_list = [p,q,r,t]</span><br><span class="line">                m = CRT_list(m_list,a_list)</span><br><span class="line">                flag = long_to_bytes(<span class="built_in">int</span>(m))</span><br><span class="line">                <span class="keyword">if</span> <span class="string">b&#x27;flag&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">                    <span class="built_in">print</span>(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="二十三、三个素数的维纳攻击"><a href="#二十三、三个素数的维纳攻击" class="headerlink" title="二十三、三个素数的维纳攻击"></a>二十三、三个素数的维纳攻击</h1><p>存了个脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def wiener(e, n):</span><br><span class="line">    m = 12345</span><br><span class="line">    c = pow(m, e, n)</span><br><span class="line">    q0 = 1</span><br><span class="line">    list1 = continued_fraction(Integer(e) / Integer(n))</span><br><span class="line">    conv = list1.convergents()</span><br><span class="line">    for i in conv:</span><br><span class="line">        k = i.numerator()</span><br><span class="line">        q1 = i.denominator()</span><br><span class="line">        for r in range(20):</span><br><span class="line">            for s in range(20):</span><br><span class="line">                d = r * q1 + s * q0</span><br><span class="line">                m1 = pow(c, d, n)</span><br><span class="line">                if m1 == m:</span><br><span class="line">                    return d</span><br><span class="line">        q0 = q1</span><br><span class="line"></span><br><span class="line">n = 1051380872316823433883636764584789285333736434524933570584976014001214015195582230652890036553897972507709868668015209942849015953126067065245745528656185713975834472569979390688522786334308265267342203713851528468719085926942222541344057327637925939220941677328780957242592769934672272901444344368132925072596706265951382183962516395989020286284674233929275036820658314907868575906130423049124591076625494555958927499995127864266451094815485831694951169813864579090722449382301556276181043387840715294133205479396272801536638003449150191833236756230648343641542001617352347728075031395009393805016183916046647042759712436405458561551257959973189661621088021485676031370872948254252297718720969276447566410825701049555286286171854286210170310303122812022424180992567945938220732070586725895910160295026510702457152084383868466740490026825254620849716745141621210206706738899418272128830937154184366826368016614460538955646609</span><br><span class="line"># p*r*q</span><br><span class="line">e = 401736266490324552517217032225246450087649254466718075727966287757972026925163477893539047721223580215545684494442007744774900721388024851291175127388784748482162997733029569314385345465782341732251402815344448962923207292061517106665954257137567332560956608813590130048988674456360832136718517222056109287921167927946304453828334895683526480626294649396329610693963520850896266343295069273447109718037817671775114733403154525393468056590686142168244467303584451585069101584798590889529292526446832857035880715351476044875846461493125136227486230514153648388383654116769560511713813660841282782474519612727725715364718394717990336084691567425849567195154254431858216101902309862385524999911892987920197370958210721993073768994565808825036701082088990540391431078200077738350023726344360396487614841476654096629864029557926380538230445278881935443675347998379733770494280427033480933837349115145552011734379818969027809471037</span><br><span class="line">d=wiener(e, n)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure>



<h1 id="二十四、q-inverse-e-p"><a href="#二十四、q-inverse-e-p" class="headerlink" title="二十四、q &#x3D; inverse(e,p)"></a>二十四、q &#x3D; inverse(e,p)</h1><h2 id="例题-7"><a href="#例题-7" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">e = 65537</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while 1:</span><br><span class="line">    p = libnum.generate_prime(512)</span><br><span class="line">    q = libnum.invmod(e, p)</span><br><span class="line">    if gmpy2.is_prime(q):</span><br><span class="line">        break</span><br><span class="line">n=p*q</span><br><span class="line">c=pow(m,e,n)</span><br><span class="line">print(&quot;n=&quot;,n)</span><br><span class="line">print(&quot;c=&quot;,c)</span><br></pre></td></tr></table></figure>

<p><img src="/../images/RSA/28.png"></p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n = <span class="number">58204114420266684815970658378327773998564393394613074044159240444415512492622689982761518905542522328879289101538953676661805875053162972893258897360344016406294652339343767887745752686437325346837603712186500309908703326587069304255508650910107794737000566778637055164127273830551001009133332601839918695739</span></span><br><span class="line">c = <span class="number">43430611858598126654595145883807180034546121754009334579568652220639483233618841529702503298293207886941913478597477904682701187000781983315547295293641024286170190626012102497319037012751300959255076727985925313853559910457404758461819072120343343943528618993507783981659418177044469142912677141806591464788</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">k = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    t = gmpy2.iroot((<span class="number">4</span>*k*e*n + <span class="number">1</span>),<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> t[<span class="number">1</span>]:</span><br><span class="line">        p = (t[<span class="number">0</span>]-<span class="number">1</span>) // (<span class="number">2</span>*k)</span><br><span class="line">        q = n // p</span><br><span class="line">        <span class="built_in">print</span>(q)</span><br><span class="line">        d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">        m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        k += <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h1 id="二十五、e-2-n-有限域开方"><a href="#二十五、e-2-n-有限域开方" class="headerlink" title="二十五、e &#x3D; 2^n(有限域开方)"></a>二十五、e &#x3D; 2^n(有限域开方)</h1><h2 id="例题-8"><a href="#例题-8" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">e = 2**4</span><br><span class="line">n=libnum.generate_prime(512)</span><br><span class="line">c=pow(m,e,n)</span><br><span class="line">print(&quot;n=&quot;,n)</span><br><span class="line">print(&quot;c=&quot;,c)</span><br><span class="line">print(&quot;e=&quot;,e)</span><br><span class="line">n= 6706056417909032146977148210894497447322670892758026214857499040210310599424027594966978579750086907555556785153774781114612452198663154506193494869117293</span><br><span class="line">c= 1242680122077482326416451537576315381462840270521607042121188408927264012190282446465124987976978765626943470962693854431894739138078757743809643142105235</span><br><span class="line">e= 16</span><br></pre></td></tr></table></figure>

<p><strong>类似于上面的有限域开方，这里只需要在modn的域内开方，比上面的少了一步</strong></p>
<p><strong>exp:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">n = 6706056417909032146977148210894497447322670892758026214857499040210310599424027594966978579750086907555556785153774781114612452198663154506193494869117293</span><br><span class="line">c = 1242680122077482326416451537576315381462840270521607042121188408927264012190282446465124987976978765626943470962693854431894739138078757743809643142105235</span><br><span class="line">e = 16</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line"></span><br><span class="line">f = x^e - c</span><br><span class="line">f.monic()</span><br><span class="line">roots = f.roots()</span><br><span class="line"></span><br><span class="line">for i in roots:</span><br><span class="line">    print(long_to_bytes(int(i[0])))</span><br></pre></td></tr></table></figure>



<h1 id="二十六、inverse-p-q-和inverse-q-p"><a href="#二十六、inverse-p-q-和inverse-q-p" class="headerlink" title="二十六、inverse(p,q)和inverse(q,p)"></a>二十六、inverse(p,q)和inverse(q,p)</h1><h2 id="1-已知phi"><a href="#1-已知phi" class="headerlink" title="1.已知phi"></a>1.已知phi</h2><h3 id="例题-9"><a href="#例题-9" class="headerlink" title="例题"></a>例题</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;flag&#123;&quot;</span> + <span class="built_in">str</span>(uuid.uuid4()) + <span class="string">&quot;&#125;&quot;</span></span><br><span class="line"><span class="comment"># print(flag)</span></span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">p = libnum.generate_prime(<span class="number">512</span>)</span><br><span class="line">q = libnum.generate_prime(<span class="number">512</span>)</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = p * q</span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line">pinv = gmpy2.invert(p, q)</span><br><span class="line">qinv = gmpy2.invert(q, p)</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e=&quot;</span>, e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;phi=&quot;</span>, phi)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&quot;</span>, c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;pinv=&quot;</span>, pinv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;qinv=&quot;</span>, qinv)</span><br><span class="line"></span><br><span class="line"><span class="comment">#e = 65537</span></span><br><span class="line"><span class="comment">#phi = 98229890689284912089157469320766533791995454910192245906925225670195818406213091522014617153508961926275340781138620279250871290490873820930414041953789279215193143006258942396087516751221787778485548659324564021606857623517821094138942269722883193348321303203233297445863729579811837657596605227772947768080</span></span><br><span class="line"><span class="comment">#c = 20962649632855841088231373617057756055795073764826640468523117901947795570191538819434503909156672490273164571512993513456958532656058586024929659925126633909116178539998046336126716552474329852733455142305774551889295732464058882055828240152313078876041502758035842268176085433166898402827107253041748761839</span></span><br><span class="line"><span class="comment">#p1 = 9278107621912111502897373552245845971739215588186465664496052995069919521787577753719495078780428864673954897367324663969013147023292682927178810784000630</span></span><br><span class="line"><span class="comment">#q1 = 1888254482465757731585051308443185269531054824465971018646930721602120686960471254468405491101133069657301849498853283496490197246867160626826664577479894</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../images/RSA/29.png"></p>
<p><strong>解方程组就可以得到p,q</strong></p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">phi = <span class="number">98229890689284912089157469320766533791995454910192245906925225670195818406213091522014617153508961926275340781138620279250871290490873820930414041953789279215193143006258942396087516751221787778485548659324564021606857623517821094138942269722883193348321303203233297445863729579811837657596605227772947768080</span></span><br><span class="line">c = <span class="number">20962649632855841088231373617057756055795073764826640468523117901947795570191538819434503909156672490273164571512993513456958532656058586024929659925126633909116178539998046336126716552474329852733455142305774551889295732464058882055828240152313078876041502758035842268176085433166898402827107253041748761839</span></span><br><span class="line">p1 = <span class="number">9278107621912111502897373552245845971739215588186465664496052995069919521787577753719495078780428864673954897367324663969013147023292682927178810784000630</span></span><br><span class="line">q1 = <span class="number">1888254482465757731585051308443185269531054824465971018646930721602120686960471254468405491101133069657301849498853283496490197246867160626826664577479894</span></span><br><span class="line"></span><br><span class="line">p = sympy.Symbol(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">q = sympy.Symbol(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f1 = p*p1 + q*q1 - <span class="number">1</span> - p*q</span><br><span class="line">f2 = (p-<span class="number">1</span>)*(q-<span class="number">1</span>) - phi</span><br><span class="line"></span><br><span class="line">solve = sympy.solve((f1,f2),(p,q))</span><br><span class="line"></span><br><span class="line">p = solve[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">q = solve[<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,<span class="built_in">int</span>(n))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">solve = [(22821479829759765249174158952963874504485986220619519269945583682564626268153743665526959332259951623597980273481165822290699158799779287591018079524989452861477827065749603046033438266476630644267862116418758098665007225158018687307221410295239838141742225128229743535936788871193288880270908998572787273667/9278107621912111502897373552245845971739215588186465664496052995069919521787577753719495078780428864673954897367324663969013147023292682927178810784000629, 75408410859525146839983310367802659287509468689572726636979641987631192138059347856487657821249010302677360507657454456960172131691094533339395962428799826353715315940509339350054078484745157134217686542905805922941850398359802406831720859427643355206579078075003553909926940708618548777325696229200160494413/1888254482465757731585051308443185269531054824465971018646930721602120686960471254468405491101133069657301849498853283496490197246867160626826664577479893), (8127563715841478757107960610706814401795230571120378813999159491557998089646611933175962412935611382853782409928576209320232898704593007140413385039209881, 12086019147143011196785992116890856402329280587171998344184616275731354798756009671338164277159323344037197449252782729162677126269020429021047263806975767)]</span><br></pre></td></tr></table></figure>

<p><strong>因为前面的数字太大了，不可能是p,q</strong></p>
<h2 id="2-已知e-d-phi"><a href="#2-已知e-d-phi" class="headerlink" title="2.已知e,d,phi"></a>2.已知e,d,phi</h2><h3 id="例题-10"><a href="#例题-10" class="headerlink" title="例题"></a>例题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">print(flag)</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">p = libnum.generate_prime(1024)</span><br><span class="line">q = libnum.generate_prime(1024)</span><br><span class="line">e = 65537</span><br><span class="line">n=p*q</span><br><span class="line">p1=libnum.invmod(p,q)</span><br><span class="line">q1=libnum.invmod(q,p)</span><br><span class="line">phi=(p-1)*(q-1)</span><br><span class="line">print(phi)</span><br><span class="line">d=libnum.invmod(e,phi)</span><br><span class="line"></span><br><span class="line">c=pow(m,e,n)</span><br><span class="line">print(&quot;p1=&quot;,p1)</span><br><span class="line">print(&quot;q1=&quot;,q1)</span><br><span class="line">print(&quot;d=&quot;,d)</span><br><span class="line">print(&quot;e=&quot;,e)</span><br><span class="line">print(&quot;c=&quot;,c)</span><br></pre></td></tr></table></figure>

<p><strong>其实给d也没区别，终究是要求p,q</strong></p>
<p><strong>套上面脚本就行，没区别</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">p1= <span class="number">97656077071270197914785321263555295398683131376741279762023269752748032446917564784973530125497364995807144029368514414686812526434051342203148587548869714362392149049199571504107521002327725946079985444111124295505554135534791115828253787424842366876671199369039838469527700802048214832651973914615014793434</span></span><br><span class="line">q1= <span class="number">39346433326508892813150536257919182675225716975877498778468626666265319210911093864684217868389854790505495572529483241732413112619372606685748980784688553398278315703981192828280813023954306657912647634729098972136705540024619937335024692325575092594446158807029214788285050359047781519982931005193436553164</span></span><br><span class="line"><span class="comment">#d= 13982206046522221689006948762375515892286671914597370002120896052266280914021885507889789598565474633660266121772385535949954654478591294089438758529565129571215458972099907852294228150256147359389834287744392536374255187239416806275744570662248893522074706262730636918053134499811014564470545819778015584753659205965073426501902382941707278051440033966771995946005135307665514929445057737703258338176975384665564222178081103000139437728386604903444661523794053627011660691133434801451813006697587015285256584456452850523012639216643290392821724776006584995172392016576699118057963479401425915020921720042294733838337</span></span><br><span class="line">e= <span class="number">65537</span></span><br><span class="line">c= <span class="number">13235028416286929520160810669079534965765212020283157183506000327481359053022089166886460096491962822206497841520395685863417454564782563002357235184688540460362871929729166716636143577909568477095287025119038866855396071566223268818065261766734924398179202129826294778702597618099032226876112654250403885134458713788086798004345808257538019652522209856828455756694071035571007463724635674562294436700546760823969026149755043139120494280665479551005965472492371422616161244117935709924215027494208339801474837499105640735072011664365891939864038690374913413240430803230704628673411107455299647523018041707726365601893</span></span><br><span class="line">phi=<span class="number">16033591784555690839033601641933863819862675274128076669740291933394723758788009352788583792713912217703542497595829207543956085361202366334328595985304274508481724780489075813896396106581346750635700757907059309496772854950127016253035273087412614339939285140337656629662098889174735118835844089284571097739371559723771996652001268037000802800553357819154820449211550823391567258031927998247803081416301018071582489307196620368843405837158330864310134068534625079672858460155583646814590373389203531298114865193213718937686858488611970228064763729093357377320357215677266414126622909951204685623007887150263682313184</span></span><br><span class="line"></span><br><span class="line">p = sympy.Symbol(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">q = sympy.Symbol(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f1 = p*p1 + q*q1 - <span class="number">1</span> - p*q</span><br><span class="line">f2 = (p-<span class="number">1</span>)*(q-<span class="number">1</span>) - phi</span><br><span class="line"></span><br><span class="line">solve = sympy.solve((f1,f2),(p,q))</span><br><span class="line"></span><br><span class="line">p = solve[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">q = solve[<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,<span class="built_in">int</span>(n))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>

<h2 id="3-变形"><a href="#3-变形" class="headerlink" title="3.变形"></a>3.变形</h2><h3 id="例题-11"><a href="#例题-11" class="headerlink" title="例题"></a>例题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line"># print(flag)</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">p = libnum.generate_prime(512)</span><br><span class="line">q = libnum.generate_prime(512)</span><br><span class="line"></span><br><span class="line">e = 65537</span><br><span class="line">n = p * q</span><br><span class="line">phi = (p - 1) * (q - 1)</span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line">p1 = gmpy2.invert(p, q)-q</span><br><span class="line">q1 = gmpy2.invert(q, p)-p</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line"></span><br><span class="line">print(&quot;e=&quot;, e)</span><br><span class="line">print(&quot;phi=&quot;, phi)</span><br><span class="line">print(&quot;c=&quot;, c)</span><br><span class="line">print(&quot;p1=&quot;, p1)</span><br><span class="line">print(&quot;q1=&quot;, q1)</span><br></pre></td></tr></table></figure>

<p><strong>给的invert(p,q)-q和invert(q,p)-p</strong></p>
<p><img src="/../images/RSA/30.png"></p>
<p><img src="/../images/RSA/31.png"></p>
<p><strong>所以还是解方程组</strong></p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">e= <span class="number">65537</span></span><br><span class="line">phi= <span class="number">153526208973286457920479376447622546334064100044507994947932972947056601063592943200823498761273906685365632931851181655405163001559274037884326450823919640514634182433839200397012200852498394907718538509040702321554785017853186412670980153149366201235845635320919980848682144430326738538775142630420821822960</span></span><br><span class="line">c= <span class="number">45404866893480020010799585996788902747901025575540655893265307771493992595444010006643443639614244962689890716458286889196613281948316354607540970243071548624687668875908716690311985915197944902857988253464493234021796216923039652003206533181461815990153623141243415592031190212825941414063970906141991979873</span></span><br><span class="line">p1= -<span class="number">11065332660497699825690181811194036599102527446002445107664152730915570503984416572510322521934240155183790860963748546243230674204488210677533190963726687</span></span><br><span class="line">q1= -<span class="number">1516147835082043403956384639695921948575165356837676821387726774997348251688472575043896909177257102383857065378906848506987546488480618072779943395893217</span></span><br><span class="line"></span><br><span class="line">p = sympy.Symbol(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">q = sympy.Symbol(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f1 = p*p1 + q*q1 - <span class="number">1</span> + p*q</span><br><span class="line">f2 = (p-<span class="number">1</span>)*(q-<span class="number">1</span>) - phi</span><br><span class="line"></span><br><span class="line">solve = sympy.solve((f1,f2),(p,q))</span><br><span class="line"></span><br><span class="line">p = solve[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">q = solve[<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,<span class="built_in">int</span>(n))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>



<h1 id="二十七、hint-pow-ap-b-q-n"><a href="#二十七、hint-pow-ap-b-q-n" class="headerlink" title="二十七、hint &#x3D; pow(ap+b,q,n)"></a>二十七、hint &#x3D; pow(ap+b,q,n)</h1><h2 id="例题-12"><a href="#例题-12" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import gmpy2</span><br><span class="line">import uuid</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line"></span><br><span class="line">e = 65537</span><br><span class="line">p = getPrime(1024)</span><br><span class="line">q = getPrime(1024)</span><br><span class="line">n = p * q</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">hint = pow(2020 * p + 2021, q, n)</span><br><span class="line">print(f&#x27;n=&#123;n&#125;&#x27;)</span><br><span class="line">print(f&#x27;c=&#123;c&#125;&#x27;)</span><br><span class="line">print(f&#x27;hint=&#123;hint&#125;&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="/../images/RSA/32.png"></p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n = <span class="number">27020725261160598541077357737650775795182555998856810737571508044949928734067444441660366270392732456051807439301564552672200975582350577967001486740668193835704559129378410828266554536148151615878808327988333060924165410762016082268322936465413880236634083213834739549234631742766416876749808978934944262651307600621868854944164060642189749365967978497831698002669974744487926082412272998646851047638183126945784060957075393737537570645086672473571281053798891685646561828588448040073373363454584468753860529849749093081434144360661566815886630699933232263079413562069476421802192735693386029862725050469209845710383</span></span><br><span class="line">c = <span class="number">10188807385387617708190575473905502994151677148079820873886980571555051900701810208218351138721306416600688313703084580808183634201231599134123549448962443376514560489130860694363901933597676373555599555647232128717993571185822894818704143675318690577221330618533739592165564396729937983659337232822442555504262694675199751730664450120569727835850996566436129543730932040989365233424791093843941154003052950306359994891955336607690065213304872738280674213630736611351982705373394299097653653497017756036211550125607093109216729483090391729134062236908282557149575812220142872855836932590459512028618076264332235518829</span></span><br><span class="line">hint = <span class="number">15179972145975733285419381814235528011288991423484121653543845156913121513320504879647666067298415751234264897435338898933073713420024176276221164394369781676781604128149168834126855517212300158864797800121336042194751965268493010327202598446572764475343894613152062609436699715193914479572113800212525965140106015838636914979735618606768207651697548364440806425770871133439416876157686985836939255598747973339866125864303982956813846287509191028829738926404992619459242904729015823730553526572575372668559669124599614613391797015393641171177282129497503752370800088634017972208535899870704612274473042064675033593148</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">p = gmpy2.gcd(<span class="built_in">pow</span>(<span class="number">2021</span>,n,n)-hint,n)</span><br><span class="line">q = n // p</span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>



<h1 id="二十八、hint-pow-ap-b-e-n"><a href="#二十八、hint-pow-ap-b-e-n" class="headerlink" title="二十八、hint &#x3D; pow(ap+b,e,n)"></a>二十八、hint &#x3D; pow(ap+b,e,n)</h1><p><img src="/../images/RSA/33.png"></p>
<h2 id="例题-13"><a href="#例题-13" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">print(flag)</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">p = libnum.generate_prime(512)</span><br><span class="line">q = libnum.generate_prime(512)</span><br><span class="line">e = 65537</span><br><span class="line">n = p * q</span><br><span class="line">h = 20211102</span><br><span class="line">hc = pow(h + p * 1111, e, n)</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(&quot;hc=&quot;, hc)</span><br><span class="line">print(&quot;n=&quot;, n)</span><br><span class="line">print(&quot;c=&quot;, c)</span><br><span class="line">hc = 71505320953946158049530109094654497075489963071106175336722892393493112481336409391299522595724154571954223093317880494307263262649833222750675105885636892419350501821324979706283867758665536771783209816719106279467902518895579024290387800216711663670572861182058425925280993190282267615052256942516011995207</span><br><span class="line">n = 76856511192427852645963041043072791148703422665129663050712492700760489247788743818199589072069758934570218804936479267319288093436111548055922916898782764333246946326823653877357695179165138863843657328764265204547147092074499832221138997131011222722917338444675582832114206750168113207646100633238664244737</span><br><span class="line">c = 39246179387125192271554620313966311736032348078183121707012959204367908070472764506984235827179206718838172586811066682034907967943722841257765922283692526422653916506577810629430853963448057701574209912936660396486847365579797147723437378122880075493171892191049105237005801787649587080840600670585409293046</span><br></pre></td></tr></table></figure>

<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">hint = <span class="number">71505320953946158049530109094654497075489963071106175336722892393493112481336409391299522595724154571954223093317880494307263262649833222750675105885636892419350501821324979706283867758665536771783209816719106279467902518895579024290387800216711663670572861182058425925280993190282267615052256942516011995207</span></span><br><span class="line">n = <span class="number">76856511192427852645963041043072791148703422665129663050712492700760489247788743818199589072069758934570218804936479267319288093436111548055922916898782764333246946326823653877357695179165138863843657328764265204547147092074499832221138997131011222722917338444675582832114206750168113207646100633238664244737</span></span><br><span class="line">c = <span class="number">39246179387125192271554620313966311736032348078183121707012959204367908070472764506984235827179206718838172586811066682034907967943722841257765922283692526422653916506577810629430853963448057701574209912936660396486847365579797147723437378122880075493171892191049105237005801787649587080840600670585409293046</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">b = <span class="number">20211102</span></span><br><span class="line"></span><br><span class="line">p = gmpy2.gcd(hint-<span class="built_in">pow</span>(b,e,n),n)</span><br><span class="line">q = n // p</span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>现代密码-非对称加密</category>
      </categories>
      <tags>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>格密码入门</title>
    <url>/2023/07/29/%E6%A0%BC%E5%AF%86%E7%A0%81%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>初识格密码</p>
<span id="more"></span>

<p>做题关键，构造出下列矩阵乘法<br>$$<br>v·M&#x3D;\overrightarrow{w}<br>$$</p>
<p>$$<br>v:未知量矩阵<br>$$</p>
<p>$$<br>M:已知量矩阵<br>$$</p>
<p>$$<br>\overrightarrow{w}:目标向量，即要求的值<br>$$</p>
<p><strong>需要注意的是，因为LLL算法是一步一步约减的，所以目标向量一定要比原来已知矩阵小</strong></p>
<p>根据$Hermite$定理，我们所求的目标向量一定要满足SVP的范围</p>
<h1 id="NTRU有关"><a href="#NTRU有关" class="headerlink" title="NTRU有关"></a>NTRU有关</h1><h2 id="入门题"><a href="#入门题" class="headerlink" title="入门题"></a>入门题</h2><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from secret import flag</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">f = bytes_to_long(flag)</span><br><span class="line">p = getPrime(512)</span><br><span class="line">g = getPrime(128)</span><br><span class="line">h = gmpy2.invert(f+20192020202120222023, p) * g % p</span><br><span class="line"></span><br><span class="line">print(&#x27;h =&#x27;, h)</span><br><span class="line">print(&#x27;p =&#x27;, p)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">h = 2230300126583677861466927910427460605336142000604400796769019169330805327830058127399640469637301157563524664730082687590109425103649095203274991089542329</span><br><span class="line">p = 6950733137747588463708927295050453925761832477377823596882238234496472403054344156839969133381577140118982692621000380716326275220824006196311323447685281</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>$$<br>要拿到flag,就得求出f的值<br>$$</p>
<p>$$<br>先令f’ &#x3D; f+20192020202120222023<br>$$</p>
<p>$$<br>已知h \equiv f’^{-1}g (\mod p)<br>$$</p>
<p>$$<br>\therefore hf’ \equiv g (\mod p)<br>$$</p>
<p>$$<br>\therefore g &#x3D; hf’ -kp<br>$$</p>
<p>构造出</p>
<p><img src="/../images/Lattice2/0.png"></p>
<p><strong>LLL算法可以把</strong>$(h,1),(p,0)$<strong>这组基，变成正交化程度最大的一组基</strong></p>
<p>其实际过程是把向量$(h,1),(p,0)$做线性组合，最后的结果就是$x_1(h,1)+x_2(p,0)&#x3D;(x_1h+x_2p,x_1+0)$</p>
<p>当$x_1&#x3D;f’,x_2&#x3D;-k$的时候，就是我们要的结果</p>
<h3 id="为什么LLL算法的结果就是我们要的值？"><a href="#为什么LLL算法的结果就是我们要的值？" class="headerlink" title="为什么LLL算法的结果就是我们要的值？"></a>为什么LLL算法的结果就是我们要的值？</h3><p>LLL算法是求解SVP问题的，我们要求的向量$\vec{v} &#x3D; (f’,g)$满足$||\vec{v}||\le \sqrt{2}det(\mathcal{L})$</p>
<p>其中，$\mathcal{L}$是$(h,1),(p,0)$构成的矩阵，其行列式为$p$</p>
<p>求解出$f’$后，我们便能求出$f$</p>
<p>构造的矩阵依赖下式</p>
<p><img src="/../images/Lattice2/1.png"></p>
<p>exp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line"></span><br><span class="line">h = 2230300126583677861466927910427460605336142000604400796769019169330805327830058127399640469637301157563524664730082687590109425103649095203274991089542329</span><br><span class="line">p = 6950733137747588463708927295050453925761832477377823596882238234496472403054344156839969133381577140118982692621000380716326275220824006196311323447685281</span><br><span class="line"></span><br><span class="line">Ge = Matrix(ZZ,[[1,h],[0,p]])</span><br><span class="line">print(Ge.LLL())</span><br><span class="line">f,g = Ge.LLL()[0]</span><br><span class="line">f,g = abs(f),abs(g)</span><br><span class="line"></span><br><span class="line">print(libnum.n2s(int(f-20192020202120222023)))</span><br></pre></td></tr></table></figure>

<h2 id="NSSCTF-HNCTF-2022-WEEK2-——littleLattice"><a href="#NSSCTF-HNCTF-2022-WEEK2-——littleLattice" class="headerlink" title="NSSCTF [HNCTF 2022 WEEK2] ——littleLattice"></a>NSSCTF [HNCTF 2022 WEEK2] ——littleLattice</h2><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from hashlib import *</span><br><span class="line"></span><br><span class="line">p = getPrime(2048)</span><br><span class="line">f = getPrime(1024)</span><br><span class="line">g = getPrime(768)</span><br><span class="line">h = pow(f,-1,p)*g%p</span><br><span class="line">verify = sha256(bytes.fromhex(hex(f+g)[2:])).hexdigest()</span><br><span class="line">print(f&#x27;verify = &#123;verify&#125;&#x27;)</span><br><span class="line">print(f&#x27;p = &#123;p&#125;&#x27;)</span><br><span class="line">print(f&#x27;h = &#123;h&#125;&#x27;)</span><br><span class="line">print(&#x27;NSSCTF&#123;&#x27; + md5(bytes.fromhex(hex(f+g)[2:])).hexdigest() + &#x27;&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">verify = 24425b693dbcace08a32572d499a5cbeb36e30db9278704195c67c3d32a81bdf</span><br><span class="line">p = 29908110980126088961686288727545150169450107297750996656924523214377817308111189721234667959695817050736874247951762130190209278324144437406652857446810518839546701950883392761869656586963587376306050382973323860395932741791372333809871487575268245618618143456971257992301722141464238875859134379745122404533776003095129169004284619647906206323263396219776072091827094295366090100037898314156271404760715453914459484087562963158208356228410105170495322276351631637885450926240143055767142216931354736779666836018983658010126520397012025067407223630891975504746697630878807952266767406899527721170062789607980517722293</span><br><span class="line">h = 26523576589113781532769165293024254940419790396713708680496148398686334583553504180195363282085884580924842673123375450894537445679687851322807762432476357713740302064160599132450619363411158141423252170448770929403179895813409897048848337375715079396639330537231353596884530617911351334318435031007342479134081403319324838464987064025256038807217697133175585927493402963025439540077915248356077623612217525231722274634984400273765262532561558296870531741633238736650375250957780701118781183335729715295271752736307479795186963108377228330313771245434127095507278278768792281414702334956407755841000748255424212840137</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>$$<br>我们已知h \equiv  f^{-1}×g (\mod p)<br>$$</p>
<p>$$<br>\therefore hf \equiv g (\mod p)<br>$$</p>
<p>$$<br>g &#x3D; hf-kp<br>$$</p>
<p>$$<br>要求flag,我们要求出f,g<br>$$</p>
<p>$$<br>我们的目标量就是f,g了<br>$$</p>
<p><img src="/../images/Lattice2/2.png"></p>
<p>因为$g,f$的值小于已知的$h,p$，而且$||(f,g)||\approx 1024bit$的大小小于$\sqrt{2p} \approx \sqrt{2}×1024bit$</p>
<p>所以可以用LLL算法求解$g,f$<br>$$<br>构造的矩阵依赖于下式:<br>$$<br><img src="/../images/Lattice2/3.png"></p>
<p>exp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from hashlib import sha256,md5</span><br><span class="line"></span><br><span class="line">verify = &quot;24425b693dbcace08a32572d499a5cbeb36e30db9278704195c67c3d32a81bdf&quot;</span><br><span class="line">p = 29908110980126088961686288727545150169450107297750996656924523214377817308111189721234667959695817050736874247951762130190209278324144437406652857446810518839546701950883392761869656586963587376306050382973323860395932741791372333809871487575268245618618143456971257992301722141464238875859134379745122404533776003095129169004284619647906206323263396219776072091827094295366090100037898314156271404760715453914459484087562963158208356228410105170495322276351631637885450926240143055767142216931354736779666836018983658010126520397012025067407223630891975504746697630878807952266767406899527721170062789607980517722293</span><br><span class="line">h = 26523576589113781532769165293024254940419790396713708680496148398686334583553504180195363282085884580924842673123375450894537445679687851322807762432476357713740302064160599132450619363411158141423252170448770929403179895813409897048848337375715079396639330537231353596884530617911351334318435031007342479134081403319324838464987064025256038807217697133175585927493402963025439540077915248356077623612217525231722274634984400273765262532561558296870531741633238736650375250957780701118781183335729715295271752736307479795186963108377228330313771245434127095507278278768792281414702334956407755841000748255424212840137</span><br><span class="line"></span><br><span class="line">Ge = Matrix(ZZ,[[1,h],[0,p]])</span><br><span class="line">#print(Ge.LLL())</span><br><span class="line">f,g = Ge.LLL()[0]</span><br><span class="line">f,g = abs(f),abs(g)</span><br><span class="line"></span><br><span class="line">if sha256(bytes.fromhex(hex(f+g)[2:])).hexdigest() == verify:</span><br><span class="line">    flag = &#x27;NSSCTF&#123;&#x27; + md5(bytes.fromhex(hex(f+g)[2:])).hexdigest() + &#x27;&#125;&#x27;</span><br><span class="line">    print(flag)</span><br></pre></td></tr></table></figure>

<p><code>NSSCTF&#123;884beaede45bb83d3706bcc14827dece&#125;</code></p>
<h2 id="CSDN某博主分享"><a href="#CSDN某博主分享" class="headerlink" title="CSDN某博主分享"></a>CSDN某博主分享</h2><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"> </span><br><span class="line">p = getPrime(1024)</span><br><span class="line"> </span><br><span class="line">f = getPrime(400)</span><br><span class="line">g = getPrime(512)</span><br><span class="line">r = getPrime(400)</span><br><span class="line"> </span><br><span class="line">h = inverse(f, p) * g % p</span><br><span class="line"> </span><br><span class="line">m = b&#x27;******&#x27;</span><br><span class="line">m = bytes_to_long(m)</span><br><span class="line"> </span><br><span class="line">c = (r*h + m) % p</span><br><span class="line"> </span><br><span class="line">print(f&#x27;p = &#123;p&#125;&#x27;)</span><br><span class="line">print(f&#x27;h = &#123;h&#125;&#x27;)</span><br><span class="line">print(f&#x27;c = &#123;c&#125;&#x27;)</span><br><span class="line"> </span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">p = 170990541130074930801165526479429022133700799973347532191727614846803741888876816210632483231997413973919037199883422312436314365293577997262903161076615619596783971730864586404602951191341733308807254112018161897113881363794353050758324742415299277578203838160939521046655099610387485947145087271531951477031</span><br><span class="line">h = 19027613518333504891337723135627869008620752060390603647368919831595397216728378486716291001290575802095059192000315493444659485043387076261350378464749849058547797538347059869865169867814094180939070464336693973680444770599657132264558273692580535803622882040948521678860110391309880528478220088107038861065</span><br><span class="line">c = 75639016590286995205676932417759002029770539425113355588948888258962338419567264292295302442895077764630601149285564849867773180066274580635377957966186472159256462169691456995594496690536094824570820527164224000505303071962872595619159691416247971024761571538057932032549611221598273371855762399417419551483</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>$$<br>\because c \equiv (r×f^{-1}×g +m) \mod p,这里f^{-1}是模p的逆元<br>$$</p>
<p>$$<br>\therefore fc \equiv (rg + mf) \mod p<br>$$</p>
<p>$$<br>mf \equiv (fc - rg) \mod p<br>$$</p>
<p>两边同模g，把r消去<br>$$<br>mf \equiv (fc\mod p) \mod g<br>$$</p>
<p>$$<br>m \equiv(fc\mod p) ×f^{-1}\mod g,这里f^{-1}是模g的逆元<br>$$</p>
<p><strong>这里需要注意的是</strong>$rg+mf应当小于p$,$m应当小于g$<strong>才能正确解密</strong></p>
<p>如果不满足上式的参数条件，$m$在加密过程中便有可能丢失数据</p>
<p>已知$c,p$，求出$f,g$即可求解$m$</p>
<p>构造</p>
<p><img src="/../images/Lattice2/2.png"></p>
<p>$\because \vec{v}&#x3D;(f,g) \approx 512bit &lt; \sqrt{2p} \approx \sqrt{2}×512bit$</p>
<p>依然是依赖于下式</p>
<p><img src="/../images/Lattice2/3.png"></p>
<p>exp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">p = 170990541130074930801165526479429022133700799973347532191727614846803741888876816210632483231997413973919037199883422312436314365293577997262903161076615619596783971730864586404602951191341733308807254112018161897113881363794353050758324742415299277578203838160939521046655099610387485947145087271531951477031</span><br><span class="line">h = 19027613518333504891337723135627869008620752060390603647368919831595397216728378486716291001290575802095059192000315493444659485043387076261350378464749849058547797538347059869865169867814094180939070464336693973680444770599657132264558273692580535803622882040948521678860110391309880528478220088107038861065</span><br><span class="line">c = 75639016590286995205676932417759002029770539425113355588948888258962338419567264292295302442895077764630601149285564849867773180066274580635377957966186472159256462169691456995594496690536094824570820527164224000505303071962872595619159691416247971024761571538057932032549611221598273371855762399417419551483</span><br><span class="line"></span><br><span class="line">Ge = Matrix(ZZ,[[h,1],[p,0]])</span><br><span class="line">print(Ge.LLL())</span><br><span class="line">g,f = Ge.LLL()[0]</span><br><span class="line">g,f = abs(g),abs(f)</span><br><span class="line"></span><br><span class="line">m = ((f*c%p)*gmpy2.invert(f,g)) % g</span><br><span class="line">print(libnum.n2s(int(m)))</span><br></pre></td></tr></table></figure>

<p><code>NSSCTF&#123;94068324-38bb-410b-b464-e1b8baf6b358&#125;</code></p>
<h2 id="2020巅峰极客修改"><a href="#2020巅峰极客修改" class="headerlink" title="2020巅峰极客修改"></a>2020巅峰极客修改</h2><p>题目:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from secret import flag</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def generate():</span><br><span class="line">    p = getStrongPrime(2048)</span><br><span class="line">    while True:</span><br><span class="line">        f = getRandomNBitInteger(1024)</span><br><span class="line">        g = getStrongPrime(768)</span><br><span class="line">        h = gmpy2.invert(f, p) * g % p</span><br><span class="line">        return (p, f, g, h)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def encrypt(plaintext, p, h):</span><br><span class="line">    m = bytes_to_long(plaintext)</span><br><span class="line">    r = getRandomNBitInteger(1024)</span><br><span class="line">    c = (r * h + m) % p</span><br><span class="line">    return c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p, f, g, h = generate()</span><br><span class="line">c = encrypt(flag, p, h)</span><br><span class="line">print(&#x27;h =&#x27;, h)</span><br><span class="line">print(&#x27;p =&#x27;, p)</span><br><span class="line">print(&#x27;c =&#x27;, c)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">h = 15920807412952692847985174177588211960281948838307253586797239960508125481987882224605864406372742338485793530131031795389776531751200676051949170672004649326503467447518123006808297262753280286176914568491022298784897984879823370933511805201516939304165656461649805404345353075803763209810253831770288511818668398003443730898078080711296567200650962390927974385735100849320021423318726773493255693093044142610555698370275203822724528162516863483780170076614868308468049805668954554578089167666866242081591436319781031943877834260419842837279937368942586813623585114579680192182136454951076576180846308031147577895183</span><br><span class="line">p = 29616445112694260274774681537287299269831042656521626513009034520717072986110554689452007791622053679125813101887358792411152206641110832730768759894034995329749945245036475665938165090997263055454214551943883405059392525425764609291470545536168035201657530029849113821500078015786845062143152799634844986753056256220285729693791666273618731684193516606613125066125143895019716948226556471128531174411802630235945882713680099627033330758906060609807833477234842026397619463093836747345939002210487194276855948870859245196439206070300222410002340377429280616491741559912351526804469748340235688215655559714767093336011</span><br><span class="line">c = 24894154600738747801028572977171957374256712941786243361235711912410748252475712552938200529578615522555383736598357845901370674754857388874985225645650913059820754690696257510209172235875364336887131653254443697948965333434213242584604843844646774324930722413839123594241879178636469903372909302377061318833174246232722769872293078758804927418352848560803152544304608965368181815249876729133751310904899772060616419975025741262545479052454752165874425435226386604586446369944613258629120527951194286510228752204113015018002437399369034486123978271982779314575972603420464431960235222295086660836240988842127196837233</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>和上题一样</p>
<p>exp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">h = 15920807412952692847985174177588211960281948838307253586797239960508125481987882224605864406372742338485793530131031795389776531751200676051949170672004649326503467447518123006808297262753280286176914568491022298784897984879823370933511805201516939304165656461649805404345353075803763209810253831770288511818668398003443730898078080711296567200650962390927974385735100849320021423318726773493255693093044142610555698370275203822724528162516863483780170076614868308468049805668954554578089167666866242081591436319781031943877834260419842837279937368942586813623585114579680192182136454951076576180846308031147577895183</span><br><span class="line">p = 29616445112694260274774681537287299269831042656521626513009034520717072986110554689452007791622053679125813101887358792411152206641110832730768759894034995329749945245036475665938165090997263055454214551943883405059392525425764609291470545536168035201657530029849113821500078015786845062143152799634844986753056256220285729693791666273618731684193516606613125066125143895019716948226556471128531174411802630235945882713680099627033330758906060609807833477234842026397619463093836747345939002210487194276855948870859245196439206070300222410002340377429280616491741559912351526804469748340235688215655559714767093336011</span><br><span class="line">c = 24894154600738747801028572977171957374256712941786243361235711912410748252475712552938200529578615522555383736598357845901370674754857388874985225645650913059820754690696257510209172235875364336887131653254443697948965333434213242584604843844646774324930722413839123594241879178636469903372909302377061318833174246232722769872293078758804927418352848560803152544304608965368181815249876729133751310904899772060616419975025741262545479052454752165874425435226386604586446369944613258629120527951194286510228752204113015018002437399369034486123978271982779314575972603420464431960235222295086660836240988842127196837233</span><br><span class="line"></span><br><span class="line">Ge = Matrix(ZZ,[[1,h],[0,p]])</span><br><span class="line">print(Ge.LLL())</span><br><span class="line">f,g = Ge.LLL()[0]</span><br><span class="line">f,g = abs(f),abs(g)</span><br><span class="line"></span><br><span class="line">m = ((f*c%p)*gmpy2.invert(f,g)) % g</span><br><span class="line">print(libnum.n2s(int(m)))</span><br></pre></td></tr></table></figure>



<h2 id="NSSCTF-深育杯2021-——GeGe"><a href="#NSSCTF-深育杯2021-——GeGe" class="headerlink" title="NSSCTF [深育杯2021]——GeGe"></a>NSSCTF [深育杯2021]——GeGe</h2><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2</span><br><span class="line">from flag import flag</span><br><span class="line"></span><br><span class="line">def encrypt(plaintext):</span><br><span class="line">    p = getStrongPrime(3072) </span><br><span class="line">    m = bytes_to_long(plaintext)</span><br><span class="line">    r = getRandomNBitInteger(1024)</span><br><span class="line">    while True:</span><br><span class="line">        f = getRandomNBitInteger(1024)</span><br><span class="line">        g = getStrongPrime(768)</span><br><span class="line">        h = gmpy2.invert(f, p) * g % p</span><br><span class="line">        c = (r * h + m * f) % p</span><br><span class="line">        return (h, p, c)</span><br><span class="line"></span><br><span class="line">h, p, c = encrypt(flag)</span><br><span class="line">with open(&quot;cipher.txt&quot;, &quot;w&quot;) as f:</span><br><span class="line">    f.write(&quot;h = &quot; + str(h) + &quot;\n&quot;)</span><br><span class="line">    f.write(&quot;p = &quot; + str(p) + &quot;\n&quot;)</span><br><span class="line">    f.write(&quot;c = &quot; + str(c) + &quot;\n&quot;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">#output</span><br><span class="line">h = 3967900409518491437091166715380802161532841159072519563471354336400750930009970177101953304861954502146570721506995224520631716261108071684882841102381144720177664434981608584075201907891964214604246219441325377602163957172642582158192223452845671007585556951922415200415538060247456213608112360361636912703380306386439846269645696750929811607783895294670639202472465920599542568227657152922843001792754116981992696203788298740550812661583820191877594185184758074771316815650833195023325150218113883046328740408517222933980589974912467363367727038230703152354450353199257411964288022409128890352346036423792759938468964462267528727695183747947515480432786669353434638860350849296620606820894819933050645748656981993408399675189724419997805599649975500093890450393421897803267909569938850674774386012819838940544502656293639875120854745249463561940935651895728242282430164407574626178693654713011323376912585958110558532953333</span><br><span class="line">p = 4407206782832544188667944201727813617189883940490534227436068867901196311508151544316989531306678865408607390128649278629254128753967046691736522108356971272311308455619879297358588727267184200777923695048248757115057072357087881336680504033511958280710547178971268670442650871890760916203109226852889599638484429889898210426540567794020013920566784973281560628666918122674783539653720295629054898529900882965691587718212291373734218555167591690910246380516121338139063419587750344469214004539520017140593342859857394308703001939640899189432836134392830208318268131639318655382175643272565186884496188876341460968563623529229713790076050095498053846983536874648190033735162809614805624209827336432223553914651838063614534617044557310972056169869738746432924853953258079006936103497626054364115282007843847693813896856977882285910369660539092462408790126385881581833165309032853389777355480169212478669139225609058338565029211</span><br><span class="line">c = 4052491539376955553220568757544621659293304958837707160681090710624505862889512520190589879197831394720145909992216099963759496125523078969015706069688556356682711471641851937470179182960755800968587551608595725470945584970094036299764623894583379909329996337429067328575804567222496890803396234507278490116354758303807070775249711087938549824010697869930856205244006491475201993228121418890520174179969294094963249013786611889790711801269524919695653453576043288934196952437164829830756439734795068980207758771052483500272264363028346668629397497794792110170275173209377114274164087320163340547019935562316429227119346802124620682293405375798340275679831750482339301440428527223801872439611461272229275824994734898078664180541096159146759378804836952981089673755590353588900522455968721971944276318473421193690310601002295637581030417570868955379815661133148339565983621730401675643094909263098778572081973142223744746526672</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>$$<br>已知h \equiv f^{-1}g (\mod p)<br>$$</p>
<p>有</p>
<p><img src="/../images/Lattice2/3.png"></p>
<p>$\because \vec{v}&#x3D;(f,g) \approx 512bit &lt; \sqrt{2p} \approx \sqrt{2}×512bit$</p>
<p><img src="/../images/Lattice2/2.png"><br>$$<br>又\because c \equiv rh+mf (\mod p)<br>$$</p>
<p>$$<br>c \equiv rf^{-1}g + mf (\mod p )<br>$$</p>
<p>$$<br>fc \equiv rg+mf^2 (\mod p)<br>$$</p>
<p>$$<br>mf^2 &#x3D; (fc(\mod p))(\mod g)<br>$$</p>
<p>$$<br>m &#x3D;(fc(\mod p))×f’^{2}(\mod g),这里f’是模g的逆元<br>$$</p>
<p>exp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">h = 3967900409518491437091166715380802161532841159072519563471354336400750930009970177101953304861954502146570721506995224520631716261108071684882841102381144720177664434981608584075201907891964214604246219441325377602163957172642582158192223452845671007585556951922415200415538060247456213608112360361636912703380306386439846269645696750929811607783895294670639202472465920599542568227657152922843001792754116981992696203788298740550812661583820191877594185184758074771316815650833195023325150218113883046328740408517222933980589974912467363367727038230703152354450353199257411964288022409128890352346036423792759938468964462267528727695183747947515480432786669353434638860350849296620606820894819933050645748656981993408399675189724419997805599649975500093890450393421897803267909569938850674774386012819838940544502656293639875120854745249463561940935651895728242282430164407574626178693654713011323376912585958110558532953333</span><br><span class="line">p = 4407206782832544188667944201727813617189883940490534227436068867901196311508151544316989531306678865408607390128649278629254128753967046691736522108356971272311308455619879297358588727267184200777923695048248757115057072357087881336680504033511958280710547178971268670442650871890760916203109226852889599638484429889898210426540567794020013920566784973281560628666918122674783539653720295629054898529900882965691587718212291373734218555167591690910246380516121338139063419587750344469214004539520017140593342859857394308703001939640899189432836134392830208318268131639318655382175643272565186884496188876341460968563623529229713790076050095498053846983536874648190033735162809614805624209827336432223553914651838063614534617044557310972056169869738746432924853953258079006936103497626054364115282007843847693813896856977882285910369660539092462408790126385881581833165309032853389777355480169212478669139225609058338565029211</span><br><span class="line">c = 4052491539376955553220568757544621659293304958837707160681090710624505862889512520190589879197831394720145909992216099963759496125523078969015706069688556356682711471641851937470179182960755800968587551608595725470945584970094036299764623894583379909329996337429067328575804567222496890803396234507278490116354758303807070775249711087938549824010697869930856205244006491475201993228121418890520174179969294094963249013786611889790711801269524919695653453576043288934196952437164829830756439734795068980207758771052483500272264363028346668629397497794792110170275173209377114274164087320163340547019935562316429227119346802124620682293405375798340275679831750482339301440428527223801872439611461272229275824994734898078664180541096159146759378804836952981089673755590353588900522455968721971944276318473421193690310601002295637581030417570868955379815661133148339565983621730401675643094909263098778572081973142223744746526672</span><br><span class="line"></span><br><span class="line">Ge = Matrix(ZZ,[[1,h],[0,p]])</span><br><span class="line">print(Ge.LLL())</span><br><span class="line">f,g = Ge.LLL()[0]</span><br><span class="line">f,g = abs(f),abs(g)</span><br><span class="line"></span><br><span class="line">f1 = gmpy2.invert(f,g)</span><br><span class="line">m = ((f * c % p)*f1**2)%g</span><br><span class="line">print(libnum.n2s(int(m)))</span><br></pre></td></tr></table></figure>

<p>上面五道题都是NTRU加密</p>
<h1 id="结合RSA"><a href="#结合RSA" class="headerlink" title="结合RSA"></a>结合RSA</h1><h2 id="羊城杯2020-LRSA"><a href="#羊城杯2020-LRSA" class="headerlink" title="羊城杯2020 LRSA"></a>羊城杯2020 LRSA</h2><p>题目:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from pwn import *</span><br><span class="line">from hashlib import sha256</span><br><span class="line">import string</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">from random import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2</span><br><span class="line">from flag import flag</span><br><span class="line"></span><br><span class="line">m=bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">def getPQ(p,q):</span><br><span class="line">    P=getPrime(2048)</span><br><span class="line">    Q=getPrime(2048)</span><br><span class="line">    t=(p*P-58*P+q)%Q</span><br><span class="line">    assert (isPrime(Q))</span><br><span class="line">    return P,Q,t</span><br><span class="line"></span><br><span class="line">B=getRandomNBitInteger(11)</span><br><span class="line">p=getPrime(B)</span><br><span class="line">q=getPrime(B)</span><br><span class="line">n=p*q</span><br><span class="line">e=65537</span><br><span class="line">c=pow(m,e,n)</span><br><span class="line">P,Q,t=getPQ(p,q)</span><br><span class="line"></span><br><span class="line">print(&quot;B=&quot;,B)</span><br><span class="line">print(&quot;P*P*Q=&quot;,P*P*Q)</span><br><span class="line">print(&quot;P*Q*Q=&quot;,P*Q*Q)</span><br><span class="line">print(&quot;t=&quot;,t)</span><br><span class="line">print(&quot;c=&quot;,c)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># B=1023</span><br><span class="line"># P*P*Q=17550772391048142376662352375650397168226219900284185133945819378595084615279414529115194246625188015626268312188291451580718399491413731583962229337205180301248556893326419027312533686033888462669675100382278716791450615542537581657011200868911872550652311318486382920999726120813916439522474691195194557657267042628374572411645371485995174777885120394234154274071083542059010253657420242098856699109476857347677270860654429688935924519805555787949683144015873225388396740487817155358042797286990338440987035608851331840925854381286767024584195081004360635842976624747610461507795755042915965483135990495921912997789567020652729777216671481467049291624343256152446367091568361258918212012737611001009003078023715854575413979603297947011959023398306612437250872299406744778763429172689675430968886613391356192380152315042387148665654062576525633130546454743040442444227245763939134967515614637300940642555367668537324892890004459521919887178391559206373513466653484926149453481758790663522317898916616435463486824881406198956479504970446076256447830689197409184703931842169195650953917594642601134810084247402051464584676932882503143409428970896718980446185114397748313655630266379123438583315809104543663538494519415242569480492899140190587129956835218417371308642212037424611690324353109931657289337536406499314388951678319136343913551598851601805737870217800009086551022197432448461112330252097447894028786035069710260561955740514091976513928307284531381150606428802334767412638213776730300093872457594524254858721551285338651364457529927871215183857169772407595348187949014442596356406144157105062291018215254440382214000573515515859668018846789551567310531570458316720877172632139481792680258388798439064221051325274383331521717987420093245521230610073103811158660291643007279940393509663374960353315388446956868294358252276964954745551655711981</span><br><span class="line"># P*Q*Q=17632503734712698604217167790453868045296303200715867263641257955056721075502316035280716025016839471684329988600978978424661087892466132185482035374940487837109552684763339574491378951189521258328752145077889261805000262141719400516584216130899437363088936913664419705248701787497332582188063869114908628807937049986360525010012039863210179017248132893824655341728382780250878156526086594253092249935304259986328308203344932540888448163430113818706295806406535364433801544858874357459282988110371175948011077595778123265914357153104206808258347815853145593128831233094769191889153762451880396333921190835200889266000562699392602082643298040136498839726733129090381507278582253125509943696419087708429546384313035073010683709744463087794325058122495375333875728593383803489271258323466068830034394348582326189840226236821974979834541554188673335151333713605570214286605391522582123096490317734786072061052604324131559447145448500381240146742679889154145555389449773359530020107821711994953950072547113428811855524572017820861579995449831880269151834230607863568992929328355995768974532894288752369127771516710199600449849031992434777962666440682129817924824151147427747882725858977273856311911431085373396551436319200582072164015150896425482384248479071434032953021738952688256364397405939276917210952583838731888536160866721278250628482428975748118973182256529453045184370543766401320261730361611365906347736001225775255350554164449014831203472238042057456969218316231699556466298168668958678855382462970622819417830000343573014265235688391542452769592096406400900187933156352226983897249981036555748543606676736274049188713348408983072484516372145496924391146241282884948724825393087105077360952770212959517318021248639012476095670769959011548699960423508352158455979906789927951812368185987838359200354730654103428077770839008773864604836807261909</span><br><span class="line"># t=44</span><br><span class="line"># c=4364802217291010807437827526073499188746160856656033054696031258814848127341094853323797303333741617649819892633013549917144139975939225893749114460910089509552261297408649636515368831194227006310835137628421405558641056278574098849091436284763725120659865442243245486345692476515256604820175726649516152356765363753262839864657243662645981385763738120585801720865252694204286145009527172990713740098977714337038793323846801300955225503801654258983911473974238212956519721447805792992654110642511482243273775873164502478594971816554268730722314333969932527553109979814408613177186842539860073028659812891580301154746</span><br></pre></td></tr></table></figure>

<p>先求$PPQ,PQQ$的公因数$PQ$</p>
<p>$P &#x3D; PPQ &#x2F;&#x2F; PQ$,$Q &#x3D; PQQ &#x2F;&#x2F; PQ$<br>$$<br>\because t \equiv (p-58)P+q (\mod Q)<br>$$</p>
<p>$$<br>\therefore t-q \equiv (p-58)P (\mod Q)<br>$$</p>
<p>$$<br>\therefore t-q &#x3D; (p-58)P+kQ<br>$$</p>
<p>构造格:</p>
<p><img src="/../images/Lattice2/4.png"></p>
<p>$t$已知，随后便可求出$p,q$</p>
<p>这里事先不知道$p,q$的大小，但是最后结果出来以后，$(p-58,t-q)$的长度是非常接近$\sqrt{2Q}$的</p>
<p><strong>exp:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line"></span><br><span class="line">B = 1023</span><br><span class="line">PPQ = 17550772391048142376662352375650397168226219900284185133945819378595084615279414529115194246625188015626268312188291451580718399491413731583962229337205180301248556893326419027312533686033888462669675100382278716791450615542537581657011200868911872550652311318486382920999726120813916439522474691195194557657267042628374572411645371485995174777885120394234154274071083542059010253657420242098856699109476857347677270860654429688935924519805555787949683144015873225388396740487817155358042797286990338440987035608851331840925854381286767024584195081004360635842976624747610461507795755042915965483135990495921912997789567020652729777216671481467049291624343256152446367091568361258918212012737611001009003078023715854575413979603297947011959023398306612437250872299406744778763429172689675430968886613391356192380152315042387148665654062576525633130546454743040442444227245763939134967515614637300940642555367668537324892890004459521919887178391559206373513466653484926149453481758790663522317898916616435463486824881406198956479504970446076256447830689197409184703931842169195650953917594642601134810084247402051464584676932882503143409428970896718980446185114397748313655630266379123438583315809104543663538494519415242569480492899140190587129956835218417371308642212037424611690324353109931657289337536406499314388951678319136343913551598851601805737870217800009086551022197432448461112330252097447894028786035069710260561955740514091976513928307284531381150606428802334767412638213776730300093872457594524254858721551285338651364457529927871215183857169772407595348187949014442596356406144157105062291018215254440382214000573515515859668018846789551567310531570458316720877172632139481792680258388798439064221051325274383331521717987420093245521230610073103811158660291643007279940393509663374960353315388446956868294358252276964954745551655711981</span><br><span class="line">PQQ = 17632503734712698604217167790453868045296303200715867263641257955056721075502316035280716025016839471684329988600978978424661087892466132185482035374940487837109552684763339574491378951189521258328752145077889261805000262141719400516584216130899437363088936913664419705248701787497332582188063869114908628807937049986360525010012039863210179017248132893824655341728382780250878156526086594253092249935304259986328308203344932540888448163430113818706295806406535364433801544858874357459282988110371175948011077595778123265914357153104206808258347815853145593128831233094769191889153762451880396333921190835200889266000562699392602082643298040136498839726733129090381507278582253125509943696419087708429546384313035073010683709744463087794325058122495375333875728593383803489271258323466068830034394348582326189840226236821974979834541554188673335151333713605570214286605391522582123096490317734786072061052604324131559447145448500381240146742679889154145555389449773359530020107821711994953950072547113428811855524572017820861579995449831880269151834230607863568992929328355995768974532894288752369127771516710199600449849031992434777962666440682129817924824151147427747882725858977273856311911431085373396551436319200582072164015150896425482384248479071434032953021738952688256364397405939276917210952583838731888536160866721278250628482428975748118973182256529453045184370543766401320261730361611365906347736001225775255350554164449014831203472238042057456969218316231699556466298168668958678855382462970622819417830000343573014265235688391542452769592096406400900187933156352226983897249981036555748543606676736274049188713348408983072484516372145496924391146241282884948724825393087105077360952770212959517318021248639012476095670769959011548699960423508352158455979906789927951812368185987838359200354730654103428077770839008773864604836807261909</span><br><span class="line">t = 44</span><br><span class="line">c = 4364802217291010807437827526073499188746160856656033054696031258814848127341094853323797303333741617649819892633013549917144139975939225893749114460910089509552261297408649636515368831194227006310835137628421405558641056278574098849091436284763725120659865442243245486345692476515256604820175726649516152356765363753262839864657243662645981385763738120585801720865252694204286145009527172990713740098977714337038793323846801300955225503801654258983911473974238212956519721447805792992654110642511482243273775873164502478594971816554268730722314333969932527553109979814408613177186842539860073028659812891580301154746</span><br><span class="line"></span><br><span class="line">PQ = gmpy2.gcd(PPQ,PQQ)</span><br><span class="line"></span><br><span class="line">P = PPQ // PQ</span><br><span class="line">Q = PQQ // PQ</span><br><span class="line"></span><br><span class="line">Ge = Matrix(ZZ,[[1,P],[0,Q]])</span><br><span class="line"></span><br><span class="line">p1 ,q1 = Ge.LLL()[0]</span><br><span class="line"></span><br><span class="line">#print(p1,q1)</span><br><span class="line">p1 = abs(p1)</span><br><span class="line"></span><br><span class="line">#print(p1,q1)</span><br><span class="line">p = p1 + 58</span><br><span class="line">q = t + q1</span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line">d = gmpy2.invert(65537,(p-1)*(q-1))</span><br><span class="line">m = pow(c,d,n)</span><br><span class="line">print(libnum.n2s(int(m)))</span><br></pre></td></tr></table></figure>

<h2 id="NUSTCTF-2022-新生赛-——lattice"><a href="#NUSTCTF-2022-新生赛-——lattice" class="headerlink" title="[NUSTCTF 2022 新生赛]——lattice"></a>[NUSTCTF 2022 新生赛]——lattice</h2><p>一道简单论文题</p>
<p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from random import randint</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">flag = bytes_to_long(flag)</span><br><span class="line">d = getPrime(randint(370, 390))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def enc(i):</span><br><span class="line">    print()</span><br><span class="line">    p = getPrime(512)</span><br><span class="line">    q = getPrime(512)</span><br><span class="line">    n = p * q</span><br><span class="line">    phi = (p - 1) * (q - 1)</span><br><span class="line">    e = inverse(d, phi)</span><br><span class="line">    c = pow(flag, e, n)</span><br><span class="line">    print(f&#x27;e_&#123;i&#125; =&#x27;, e)</span><br><span class="line">    print(f&#x27;n_&#123;i&#125; =&#x27;, n)</span><br><span class="line">    print(f&#x27;c_&#123;i&#125; =&#x27;, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    for i in range(3):</span><br><span class="line">        enc(i)</span><br><span class="line"></span><br><span class="line"># e_0 = 37389635736858807810703086504264263440188928763651776502954117173983775626039037008534821321761858567723984257427640816113325770208734640385635663643682102780255726244659849205653007212192504491177021176624605722718152646889627480051142935241036578957272339153039961711802753021931124235464986935316295647379</span><br><span class="line"># n_0 = 87704526707772151782606625126900349506318713860335977395824997219721333991491994027303721441548488339412359519408127174109547119019245873976917916080340858937125736650376514406944094998893225164676363063781400756374403299951466867573215964360920244878373810391250391475087527409213204756990192602517961590163</span><br><span class="line"># c_0 = 78656123855003406993963573497876652287109947684890741747390020445306861422604130132525802389554149844489256622057009394678814584233565675702142297935509191018145970589418173328145004732595569847696022333024124469320873194195223535859964387627938665526123562969554622541694399263934496631337485091067073489148</span><br><span class="line"></span><br><span class="line"># e_1 = 28535169211141109871379321582501492434722235009040085167442370469971731780018594508141105234950857774463438226249819106596920677559656398153362076685288045484306156454558741088396794170762527953573082734587618137075161676392362016474076363311708889307420903699720319611668580377903356783222664068961626803615</span><br><span class="line"># n_1 = 134298877057487865189085342936485527664167450453080897084604607959501054859295769447683135156167266222961308751016451904929475702646252122360203167489936020076488657815646993920082535307414536854323149177250531362615850689341066360635074886835720438532107976530111551202845697404444502476862934946146194420313</span><br><span class="line"># c_1 = 3208711484494445700905074340207543865325589037128163311082565190422756093807236786011349707275838139469873445326457948489588753029946395247710197747538418278782966047404435385208682596795152082296050804126524129644617710791433973098499266439604632728957505961744280687343384601998774018570047292904007768763</span><br><span class="line"></span><br><span class="line"># e_2 = 27653153186459366670449283776658896188717513017934031993526241644501850206894800647711159987946276669184047769965182746812351757618147642060630769822810070480507035319320426666128599562714143342910248758055424582501972900763786232170145957578683616604737178839977216709381529813768748145393798635858691196687</span><br><span class="line"># n_2 = 82113192811251631639012300385672674439485256963081847790431181633372052788107703751257606763043873164706839243919206719171536710944060815484051324239120708906418093409305166299531826404505861042666985630956832163750255358332156122245372899824101210233079028706971698312018388678352739819636695333269309456613</span><br><span class="line"># c_2 = 79145689398302968140315554300835109898158799236562716569497147385375487041207363302776833573990584370222316102267792795080448018216133931915984139305260191001847394275311719986838969706049641052337337102739487620502723651258075501409442088938776353037366614208693030741599888985069155346722608948495955447606</span><br></pre></td></tr></table></figure>



<p>令$M &#x3D; \sqrt{N_{max}}$，$M$是一组$N$中最大的$N$并且开根号。这组$N$满足：$N_1&lt;N_2&lt;\dots&lt;N_r &lt;2N_1$</p>
<p>又$\because e_id \equiv 1 (\mod \phi(N_i))$</p>
<p>这里把它写成$e_id &#x3D; 1+k_i\phi{N_i}$</p>
<p>假设$\phi(N_i)$可以写成$k_i(N_i-s_i)$的形式。其中$|s_i&lt;3N_i^{\frac{1}{2}}|$</p>
<p>则$e_id &#x3D; 1 + k_i(N_i-s_i)$</p>
<p>化简得$e_id-k_iN_i &#x3D; 1-k_is_i$</p>
<p>所以我们有$r+1$个等式:</p>
<p><img src="/../images/Lattice2/10.png"></p>
<p>写成矩阵相乘的形式</p>
<p><img src="/../images/Lattice2/11.png"></p>
<p>因为最后的目标向量满足LLL算法，所以我们可以得到$dM$</p>
<p>求得$dM$之后，我们可以求得$d$</p>
<p>exp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">e0 = 37389635736858807810703086504264263440188928763651776502954117173983775626039037008534821321761858567723984257427640816113325770208734640385635663643682102780255726244659849205653007212192504491177021176624605722718152646889627480051142935241036578957272339153039961711802753021931124235464986935316295647379</span><br><span class="line">n0 = 87704526707772151782606625126900349506318713860335977395824997219721333991491994027303721441548488339412359519408127174109547119019245873976917916080340858937125736650376514406944094998893225164676363063781400756374403299951466867573215964360920244878373810391250391475087527409213204756990192602517961590163</span><br><span class="line">c0 = 78656123855003406993963573497876652287109947684890741747390020445306861422604130132525802389554149844489256622057009394678814584233565675702142297935509191018145970589418173328145004732595569847696022333024124469320873194195223535859964387627938665526123562969554622541694399263934496631337485091067073489148</span><br><span class="line"></span><br><span class="line">e1 = 28535169211141109871379321582501492434722235009040085167442370469971731780018594508141105234950857774463438226249819106596920677559656398153362076685288045484306156454558741088396794170762527953573082734587618137075161676392362016474076363311708889307420903699720319611668580377903356783222664068961626803615</span><br><span class="line">n1 = 134298877057487865189085342936485527664167450453080897084604607959501054859295769447683135156167266222961308751016451904929475702646252122360203167489936020076488657815646993920082535307414536854323149177250531362615850689341066360635074886835720438532107976530111551202845697404444502476862934946146194420313</span><br><span class="line">c1 = 3208711484494445700905074340207543865325589037128163311082565190422756093807236786011349707275838139469873445326457948489588753029946395247710197747538418278782966047404435385208682596795152082296050804126524129644617710791433973098499266439604632728957505961744280687343384601998774018570047292904007768763</span><br><span class="line"></span><br><span class="line">e2 = 27653153186459366670449283776658896188717513017934031993526241644501850206894800647711159987946276669184047769965182746812351757618147642060630769822810070480507035319320426666128599562714143342910248758055424582501972900763786232170145957578683616604737178839977216709381529813768748145393798635858691196687</span><br><span class="line">n2 = 82113192811251631639012300385672674439485256963081847790431181633372052788107703751257606763043873164706839243919206719171536710944060815484051324239120708906418093409305166299531826404505861042666985630956832163750255358332156122245372899824101210233079028706971698312018388678352739819636695333269309456613</span><br><span class="line">c2 = 79145689398302968140315554300835109898158799236562716569497147385375487041207363302776833573990584370222316102267792795080448018216133931915984139305260191001847394275311719986838969706049641052337337102739487620502723651258075501409442088938776353037366614208693030741599888985069155346722608948495955447606</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = [n0,n1,n2]</span><br><span class="line">M = isqrt(max(n))</span><br><span class="line"></span><br><span class="line">ge = [[M,e0,e1,e2],</span><br><span class="line">    [0,-n0,0,0],</span><br><span class="line">    [0,0,-n1,0],</span><br><span class="line">    [0,0,0,-n2]]</span><br><span class="line">Ge = Matrix(ZZ,ge)</span><br><span class="line"></span><br><span class="line">dM = Ge.LLL()[0][0]</span><br><span class="line">d = abs(dM) // M</span><br><span class="line">m = pow(c0,d,n0)</span><br><span class="line">print(libnum.n2s(int(m)))</span><br></pre></td></tr></table></figure>

<h3 id="参考论文"><a href="#参考论文" class="headerlink" title="参考论文"></a>参考论文</h3><p><a href="https://www.ijcsi.org/papers/IJCSI-9-2-1-311-314.pdf">IJCSI-9-2-1-311-314.pdf</a></p>
<h1 id="CSDN某博主分享-1"><a href="#CSDN某博主分享-1" class="headerlink" title="CSDN某博主分享"></a>CSDN某博主分享</h1><p>题目</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"> </span><br><span class="line">flag = <span class="string">b&#x27;******&#x27;</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"> </span><br><span class="line">a = getPrime(<span class="number">1024</span>)</span><br><span class="line">b = getPrime(<span class="number">1536</span>)</span><br><span class="line"> </span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">r = random.randint(<span class="number">2</span>**<span class="number">14</span>, <span class="number">2</span>**<span class="number">15</span>)</span><br><span class="line"><span class="keyword">assert</span> ((p-r) * a + q) % b &lt; <span class="number">50</span></span><br><span class="line"> </span><br><span class="line">c = <span class="built_in">pow</span>( m, <span class="number">65537</span>, p*q )</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c = <span class="subst">&#123;c&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;a = <span class="subst">&#123;a&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;b = <span class="subst">&#123;b&#125;</span>&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">c = 78168998533427639204842155877581577797354503479929547596593341570371249960925614073689003464816147666662937166442652068942931518685068382940712171137636333670133426565340852055387100597883633466292241406019919037053324433086548680586265243208526469135810446004349904985765547633536396188822210185259239807712</span></span><br><span class="line"><span class="string">a = 134812492661960841508904741709490501744478747431860442812349873283670029478557996515894514952323891966807395438595833662645026902457124893765483848187664404810892289353889878515048084718565523356944401254704006179297186883488636493997227870769852726117603572452948662628907410024781493099700499334357552050587</span></span><br><span class="line"><span class="string">b = 1522865915656883867403482317171460381324798227298365523650851184567802496240011768078593938858595296724393891397782658816647243489780661999411811900439319821784266117539188498407648397194849631941074737391852399318951669593881907935220986282638388656503090963153968254244131928887025800088609341714974103921219202972691321661198135553928411002184780139571149772037283749086504201758438589417378336940732926352806256093865255824803202598635567105242590697162972609</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>已知等式<code>((p-r) * a + q) % b &lt; 50</code></p>
<p>令$x \equiv ((p-r)×a+q) \mod b$</p>
<p>$\therefore x - q \equiv (p-r)×a \mod b$</p>
<p>$\therefore x-q &#x3D; (p-r)×a+kb$</p>
<p>构造格求$p-r和x-q$，再爆破得到$p,q$</p>
<p><img src="/../images/Lattice2/5.png"></p>
<p>exp:</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sage</span><br><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">from tqdm import *</span><br><span class="line"></span><br><span class="line">c = 78168998533427639204842155877581577797354503479929547596593341570371249960925614073689003464816147666662937166442652068942931518685068382940712171137636333670133426565340852055387100597883633466292241406019919037053324433086548680586265243208526469135810446004349904985765547633536396188822210185259239807712</span><br><span class="line">a = 134812492661960841508904741709490501744478747431860442812349873283670029478557996515894514952323891966807395438595833662645026902457124893765483848187664404810892289353889878515048084718565523356944401254704006179297186883488636493997227870769852726117603572452948662628907410024781493099700499334357552050587</span><br><span class="line">b = 1522865915656883867403482317171460381324798227298365523650851184567802496240011768078593938858595296724393891397782658816647243489780661999411811900439319821784266117539188498407648397194849631941074737391852399318951669593881907935220986282638388656503090963153968254244131928887025800088609341714974103921219202972691321661198135553928411002184780139571149772037283749086504201758438589417378336940732926352806256093865255824803202598635567105242590697162972609</span><br><span class="line">e = 65537</span><br><span class="line"></span><br><span class="line">Ge = Matrix(ZZ,[[a,1],[b,0]])</span><br><span class="line"></span><br><span class="line">x_q,p_r = Ge.LLL()[0]</span><br><span class="line">xq,pr = -abs(x_q),abs(p_r)				#因为x是远小于q的，所以x-q肯定是负的</span><br><span class="line"></span><br><span class="line">for x in trange(50):</span><br><span class="line">    for r in range(2**14,2**15):</span><br><span class="line">        p = pr + r</span><br><span class="line">        q = x - xq</span><br><span class="line">        n = p*q</span><br><span class="line">        try:</span><br><span class="line">            d = gmpy2.invert(e,(p-1)*(q-1))</span><br><span class="line">            m = pow(c,d,n)</span><br><span class="line">            flag = libnum.n2s(int(m))</span><br><span class="line">            if b&#x27;NSSCTF&#x27; in flag:</span><br><span class="line">                print(flag)</span><br><span class="line">                break</span><br><span class="line">        except:</span><br><span class="line">            pass</span><br></pre></td></tr></table></figure>



<h1 id="CSDN分享"><a href="#CSDN分享" class="headerlink" title="CSDN分享"></a>CSDN分享</h1><p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from gmpy2 import *</span><br><span class="line"> </span><br><span class="line">flag = b&#x27;******&#x27;</span><br><span class="line">flag = bytes_to_long(flag)</span><br><span class="line"> </span><br><span class="line">p = getPrime(1024)</span><br><span class="line">r = getPrime(175)</span><br><span class="line">a = inverse(r, p)</span><br><span class="line">a = (a*flag) % p</span><br><span class="line"> </span><br><span class="line">print(f&#x27;a = &#123;a&#125;&#x27;)</span><br><span class="line">print(f&#x27;p = &#123;p&#125;&#x27;)</span><br><span class="line"> </span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">a = 79047880584807269054505204752966875903807058486141783766561521134845058071995038638934174701175782152417081883728635655442964823110171015637136681101856684888576194849310180873104729087883030291173114003115983405311162152717385429179852150760696213217464522070759438318396222163013306629318041233934326478247</span><br><span class="line">p = 90596199661954314748094754376367411728681431234103196427120607507149461190520498120433570647077910673128371876546100672985278698226714483847201363857703757534255187784953078548908192496602029047268538065300238964884068500561488409356401505220814317044301436585177722826939067622852763442884505234084274439591</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>已知等式： $a \equiv r^{-1}flag (\mod p)$</p>
<p>$\therefore flag \equiv ar (\mod p)$</p>
<p>即$flag &#x3D; ar + kp$</p>
<p>$a&#x3D;1023bit$</p>
<p>构造格$\mathcal{L}$</p>
<p><img src="/../images/Lattice2/6.png"></p>
<p>$\vec{v} &#x3D; (flag,k)且||\vec{v}||&lt;\sqrt{2}Det(\mathcal{L})$</p>
<p>exp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line"></span><br><span class="line">a = 79047880584807269054505204752966875903807058486141783766561521134845058071995038638934174701175782152417081883728635655442964823110171015637136681101856684888576194849310180873104729087883030291173114003115983405311162152717385429179852150760696213217464522070759438318396222163013306629318041233934326478247</span><br><span class="line">p = 90596199661954314748094754376367411728681431234103196427120607507149461190520498120433570647077910673128371876546100672985278698226714483847201363857703757534255187784953078548908192496602029047268538065300238964884068500561488409356401505220814317044301436585177722826939067622852763442884505234084274439591</span><br><span class="line"></span><br><span class="line">Ge = Matrix(ZZ,[[a,0],[p,1]])</span><br><span class="line"></span><br><span class="line">m,k = Ge.LLL()[0]</span><br><span class="line">m = abs(m)</span><br><span class="line">print(libnum.n2s(int(m)))</span><br></pre></td></tr></table></figure>



<h1 id="CSDN分享-1"><a href="#CSDN分享-1" class="headerlink" title="CSDN分享"></a>CSDN分享</h1><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from gmpy2 import *</span><br><span class="line"> </span><br><span class="line">flag = b&#x27;******&#x27;</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"> </span><br><span class="line">assert m.bit_length() == 351</span><br><span class="line">p = getPrime(1024)</span><br><span class="line">b = getPrime(1024)</span><br><span class="line">c = getPrime(400)</span><br><span class="line"> </span><br><span class="line">a = (b*m + c) % p</span><br><span class="line"> </span><br><span class="line">print(f&#x27;a = &#123;a&#125;&#x27;)</span><br><span class="line">print(f&#x27;b = &#123;b&#125;&#x27;)</span><br><span class="line">print(f&#x27;p = &#123;p&#125;&#x27;)</span><br><span class="line"> </span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">a = 92716521851427599147343828266552451834533034815416003395170301819889384044273026852184291232938197215198124164263722270347104189412921224361134013717269051168246275213624264313794650441268405062046423740836145678559969020294978939553573428334198212792931759368218132978344815862506799287082760307048309578592</span><br><span class="line">b = 155530728639099361922541063573602659584927544589739208888076194504495146661257751801481540924821292656785953391450218803112838556107960071792826902126414012831375547340056667753587086997958522683688746248661290255381342148052513971774612583235459904652002495564523557637169529882928308821019659377248151898663</span><br><span class="line">p = 100910862834849216140965884888425432690937357792742349763319405418823395997406883138893618605587754336982681610768197845792843123785451070312818388494074168909379627989079148880913190854232917854414913847526564520719350308494462584771237445179797367179905414074344416047541423116739621805238556845903951985783</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>已知等式$\quad $$a \equiv bm + c(\mod p)$<br>$$<br>\therefore c &#x3D; a -bm + kp<br>$$<br>构造格</p>
<p><img src="/../images/Lattice2/8.png"></p>
<p><strong>由于不知道中间矩阵最后一列应该是什么，我们先从右边的矩阵入手。</strong></p>
<p>因为$c$是$400bit$，$m$是$351bit$，所以向量$\vec{V}&#x3D;(c,m,?)$的长度大概就是在$400bit$左右</p>
<p><strong>由$Hermite$定理我们知道最短向量有上界</strong></p>
<p>$||\vec{v} &lt; \sqrt{3}det(\mathcal{L})||$$\therefore det(\mathcal{L})$应大于$400bit$</p>
<p>我认为$?$的取值应该在$176bit$以上</p>
<p>所以构造下列格：</p>
<p><img src="/../images/Lattice2/9.png"></p>
<p><strong>这个</strong>$2^{176}$<strong>需要不断测试，我测试结果为</strong>$2^{180}$<strong>即可获得正确答案</strong></p>
<h1 id="2023闽盾杯DDSA"><a href="#2023闽盾杯DDSA" class="headerlink" title="2023闽盾杯DDSA"></a>2023闽盾杯DDSA</h1><p>这道题有点涉及HNP问题</p>
<p>题目</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randbytes</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> FLAG</span><br><span class="line"></span><br><span class="line">prime_q = <span class="number">127421879856060385096053898551127157118456253994158974724886976404028426764068562017096096817549513218041429679987628739034764964376732733276949462214328863705096240012832165273860133745796844957157858326462845401062317289670577559619496217615868033525902303096223754465050250835491302759273614202275099668351</span></span><br><span class="line">prime_p = <span class="number">2</span> * prime_q + <span class="number">1</span></span><br><span class="line">generator = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_keys</span>(<span class="params">prime_p:<span class="built_in">int</span>, prime_q: <span class="built_in">int</span>, generator: <span class="built_in">int</span></span>):</span><br><span class="line">    private_key = <span class="built_in">int</span>(randbytes(<span class="number">48</span>).<span class="built_in">hex</span>(), <span class="number">16</span>)</span><br><span class="line">    public_key = <span class="built_in">pow</span>(generator, private_key, prime_p)</span><br><span class="line">    <span class="keyword">return</span> private_key, public_key</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signature</span>(<span class="params">m: <span class="built_in">str</span>, private_key: <span class="built_in">int</span></span>):</span><br><span class="line">    ephemeral_key = <span class="built_in">pow</span>(<span class="built_in">int</span>.from_bytes(m.encode(), <span class="string">&quot;big&quot;</span>), -<span class="number">1</span>, prime_q)</span><br><span class="line">    value_r = <span class="built_in">pow</span>(generator, ephemeral_key, prime_p) % prime_q</span><br><span class="line">    hash_value = sha256(m.encode()).hexdigest()</span><br><span class="line">    value_s = <span class="built_in">pow</span>(ephemeral_key, -<span class="number">1</span>, prime_q) * (<span class="built_in">int</span>(hash_value, <span class="number">16</span>) + private_key * value_r) % prime_q</span><br><span class="line">    <span class="keyword">return</span> hash_value, value_r, value_s</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">verification</span>(<span class="params">message_hash: <span class="built_in">str</span>, value_r: <span class="built_in">int</span>, value_s: <span class="built_in">int</span>, public_key: <span class="built_in">int</span></span>):</span><br><span class="line">    message_hash = <span class="built_in">int</span>(message_hash, <span class="number">16</span>)</span><br><span class="line">    inverse_s = <span class="built_in">pow</span>(value_s, -<span class="number">1</span>, prime_q)</span><br><span class="line">    u1 = message_hash * inverse_s % prime_q</span><br><span class="line">    u2 = value_r * inverse_s % prime_q</span><br><span class="line">    value_v = (<span class="built_in">pow</span>(generator, u1, prime_p) * <span class="built_in">pow</span>(public_key, u2, prime_p) % prime_p) % prime_q</span><br><span class="line">    <span class="keyword">return</span> value_v == value_r</span><br><span class="line"></span><br><span class="line">private_key, public_key = generate_keys(prime_p, prime_q, generator)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;prime_p = <span class="subst">&#123;prime_p&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;prime_q = <span class="subst">&#123;prime_q&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;generator = <span class="subst">&#123;generator&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;public_key = <span class="subst">&#123;public_key&#125;</span>&quot;</span>)</span><br><span class="line">hash_value, value_r, value_s = signature(FLAG, private_key)</span><br><span class="line"><span class="keyword">assert</span> verification(hash_value, value_r, value_s, public_key)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;FLAG= *******************************&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Here is your gift = <span class="subst">&#123;hash_value&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;value_r = <span class="subst">&#123;value_r&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;value_s = <span class="subst">&#123;value_s&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">prime_p = <span class="number">254843759712120770192107797102254314236912507988317949449773952808056853528137124034192193635099026436082859359975257478069529928753465466553898924428657727410192480025664330547720267491593689914315716652925690802124634579341155119238992435231736067051804606192447508930100501670982605518547228404550199336703</span></span><br><span class="line">prime_q = <span class="number">127421879856060385096053898551127157118456253994158974724886976404028426764068562017096096817549513218041429679987628739034764964376732733276949462214328863705096240012832165273860133745796844957157858326462845401062317289670577559619496217615868033525902303096223754465050250835491302759273614202275099668351</span></span><br><span class="line">generator = <span class="number">2</span></span><br><span class="line">public_key = <span class="number">67243435243013084147486854556817234112402511481243660325565023251853355494433326575673419694681555652669449040366620819266474334253578972440047168279142184141910485872726393507923996391796227576994885784959692699388957187699662551912804856807879764447982440118185734843107861320087767180763032071844141444498</span></span><br><span class="line">hash_value = <span class="string">&#x27;1cd920cc96d95280c96dd519df9ef49fed44c0ccfc80202372d1d196ea52ccb1&#x27;</span></span><br><span class="line">value_r = <span class="number">55738970979693187681378167695787130117222895714960965190485398883361826593727577547551100491285488657995662094510198245807164881975668033129508588482949937072551764160574163358989597712065236233432502150653495180122562651440328815420270936429340024510654195118602283837975822678425908768515924976212206091388</span></span><br><span class="line">value_s = <span class="number">16167384383010337939063062611160328697878797853686180912699394152331808942993583340068941838844464059078517385061012722104618040645796346201205622044690989665622791251498050801728558982153896995503905626972211668853043513769350513237538819164197920332285202321957958655237257294973629465658550364418471213584</span></span><br></pre></td></tr></table></figure>

<p>题目把$m$当作$k^{-1}$，把m的哈希值记作$H$，$x$是私钥</p>
<p>已知$s \equiv k^{-1}×(H + xr) \mod q$即$s \equiv m(H+xr) \mod q$</p>
<p>其中，$H,r,q,s$已知</p>
<p>做个推导$\because s \equiv mH+mxr \mod q \longrightarrow sH^{-1} \equiv m + mxrH^{-1} \mod q$</p>
<p>$\therefore m &#x3D; sH^{-1}-mxrH^{-1} +kq$，$sH^{-1}$看作常数$B$，$-rH^{-1}$看作$A$，令$mx&#x3D;t$</p>
<p>于是有$m &#x3D; At + B + kq$</p>
<h1 id="构造格-begin-pmatrix-k-t-1-end-pmatrix-begin-pmatrix-q-0-0-A-1-2-384-0-B-0-2-320-end-pmatrix"><a href="#构造格-begin-pmatrix-k-t-1-end-pmatrix-begin-pmatrix-q-0-0-A-1-2-384-0-B-0-2-320-end-pmatrix" class="headerlink" title="构造格$$\begin{pmatrix}k &amp; t &amp; 1\end{pmatrix}\begin{pmatrix}q &amp; 0 &amp;0 \A &amp; 1&#x2F;2^{384}&amp; 0\B &amp; 0&amp; 2^{320}\end{pmatrix}"></a>构造格<br>$$<br>\begin{pmatrix}<br>k &amp; t &amp; 1<br>\end{pmatrix}<br>\begin{pmatrix}<br>q &amp; 0 &amp;0 \<br>A &amp; 1&#x2F;2^{384}&amp; 0\<br>B &amp; 0&amp; 2^{320}<br>\end{pmatrix}</h1><p>\begin{pmatrix}<br>m &amp; t&#x2F;2^{384} &amp; 2^{320}<br>\end{pmatrix}<br>$$<br>猜测$m \approx 320bit$，因为$x \approx 384bit$，所以$t \approx 2^{384+320}$</p>
<p>所以构造出$1&#x2F;2^{384}$，使得目标向量每个值差不多大</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = </span><br><span class="line">q = </span><br><span class="line">g = <span class="number">2</span></span><br><span class="line">pb = </span><br><span class="line">h = <span class="string">&#x27;1cd920cc96d95280c96dd519df9ef49fed44c0ccfc80202372d1d196ea52ccb1&#x27;</span></span><br><span class="line">r = </span><br><span class="line">s = </span><br><span class="line"></span><br><span class="line">H = <span class="built_in">int</span>(h,<span class="number">16</span>)</span><br><span class="line">inv = gmpy2.invert(H,q)</span><br><span class="line">A = -r*inv</span><br><span class="line">B = s*inv</span><br><span class="line"></span><br><span class="line">M = [[q,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">      [A,<span class="number">1</span>/<span class="number">2</span>^<span class="number">384</span>,<span class="number">0</span>],</span><br><span class="line">      [B,<span class="number">0</span>,<span class="number">2</span>^<span class="number">320</span>]]</span><br><span class="line"></span><br><span class="line">Ge = Matrix(M)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Ge.LLL():</span><br><span class="line">    <span class="keyword">if</span> i[-<span class="number">1</span>] == <span class="number">2</span>^<span class="number">320</span>:</span><br><span class="line">        m = i[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br></pre></td></tr></table></figure>

<h1 id="NPUCTF2020——BabyLCG"><a href="#NPUCTF2020——BabyLCG" class="headerlink" title="NPUCTF2020——BabyLCG"></a>NPUCTF2020——BabyLCG</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LCG</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, bit_length</span>):</span><br><span class="line">        m = getPrime(bit_length)</span><br><span class="line">        a = getRandomRange(<span class="number">2</span>, m)</span><br><span class="line">        b = getRandomRange(<span class="number">2</span>, m)</span><br><span class="line">        seed = getRandomRange(<span class="number">2</span>, m)</span><br><span class="line">        self._key = &#123;<span class="string">&#x27;a&#x27;</span>:a, <span class="string">&#x27;b&#x27;</span>:b, <span class="string">&#x27;m&#x27;</span>:m&#125;</span><br><span class="line">        self._state = seed</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self</span>):</span><br><span class="line">        self._state = (self._key[<span class="string">&#x27;a&#x27;</span>] * self._state + self._key[<span class="string">&#x27;b&#x27;</span>]) % self._key[<span class="string">&#x27;m&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> self._state</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">export_key</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_lcg</span>():</span><br><span class="line">    rand_iter = LCG(<span class="number">128</span>)</span><br><span class="line">    key = rand_iter.export_key()</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f.write(<span class="built_in">str</span>(key))</span><br><span class="line">    <span class="keyword">return</span> rand_iter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak_data</span>(<span class="params">rand_iter</span>):</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;old&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        f.write(<span class="built_in">str</span>(rand_iter.<span class="built_in">next</span>() &gt;&gt; <span class="number">64</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> rand_iter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">rand_iter</span>):</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;ct&quot;</span>, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">    key = rand_iter.<span class="built_in">next</span>() &gt;&gt; <span class="number">64</span></span><br><span class="line">    key = (key &lt;&lt; <span class="number">64</span>) + (rand_iter.<span class="built_in">next</span>() &gt;&gt; <span class="number">64</span>)</span><br><span class="line">    key = long_to_bytes(key).ljust(<span class="number">16</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    iv = long_to_bytes(rand_iter.<span class="built_in">next</span>()).ljust(<span class="number">16</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    pt = flag + (<span class="number">16</span> - <span class="built_in">len</span>(flag) % <span class="number">16</span>) * <span class="built_in">chr</span>(<span class="number">16</span> - <span class="built_in">len</span>(flag) % <span class="number">16</span>)</span><br><span class="line">    ct = cipher.encrypt(pt.encode())</span><br><span class="line">    f.write(ct)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    rand_iter = gen_lcg()</span><br><span class="line">    rand_iter = leak_data(rand_iter)</span><br><span class="line">    encrypt(rand_iter)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>题目先是生成20个随机数，然后把第21个随机数的高位和第22个随机数的高位拼接成key，再把第23个随机数当作iv，进行了CBC加密。</p>
<p>只要恢复seed，剩下的问题就迎刃而解了。</p>
<p>问题是，题目只给出20个随机数的高64位</p>
<p>$\because X_{n+1} \equiv (aX_n + b) \mod m$</p>
<p>把$X$拆成高位和低位之和，即$X &#x3D; H+L$</p>
<p>$\therefore H_{n+1}+L_{n+1} \equiv a(H_n+L_n) + b \mod m$</p>
<p>于是我们得到$L_{n+1} \equiv aL_n + (aH_n+b-H_{n+1}) \mod m$</p>
<p>$L_2 \equiv aL_1 + (aH_1+b-H_2) \mod m$</p>
<p>$L_3 \equiv a(aL_1 + aH_1+b-H_2)+aH_2+b-H_3 \mod m$，即$L_3 \equiv a^2L_1+(aH_2+b-H_3+a^2H_1+b-H_2)$</p>
<p>于是能得到$L_i$与$L_1$的关系</p>
<p>则有$L_{i} \equiv A_iL_1 +B_i \mod m$，即$L_{i+1} &#x3D; A_iL_1 + B_i + k_{i}m$</p>
<h1 id="构造格-begin-pmatrix-k-1-k-2-cdots-k-19-L-1-1-end-pmatrix-begin-pmatrix-m-0-cdots-0-0-0-0-m-cdots-0-0-0-vdots-vdots-ddots-vdots-vdots-vdots-0-0-cdots-m-0-0-A-1-A-2-cdots-A-19-1-0-B-1-B-2-cdots-B-19-0-2-64-end-pmatrix"><a href="#构造格-begin-pmatrix-k-1-k-2-cdots-k-19-L-1-1-end-pmatrix-begin-pmatrix-m-0-cdots-0-0-0-0-m-cdots-0-0-0-vdots-vdots-ddots-vdots-vdots-vdots-0-0-cdots-m-0-0-A-1-A-2-cdots-A-19-1-0-B-1-B-2-cdots-B-19-0-2-64-end-pmatrix" class="headerlink" title="构造格$$\begin{pmatrix}k_1 &amp; k_2 &amp;\cdots &amp; k_{19} &amp;L_1 &amp; 1\end{pmatrix}\begin{pmatrix}m &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0\0 &amp; m &amp; \cdots &amp; 0 &amp; 0 &amp; 0\\vdots &amp;\vdots &amp; \ddots &amp; \vdots &amp;\vdots &amp; \vdots\0 &amp; 0 &amp; \cdots &amp;m &amp;0 &amp; 0\A_1 &amp; A_2 &amp;\cdots &amp;A_{19} &amp; 1 &amp; 0\B_1 &amp; B_2 &amp; \cdots &amp;B_{19} &amp;0 &amp; 2^{64}\end{pmatrix}"></a>构造格<br>$$<br>\begin{pmatrix}<br>k_1 &amp; k_2 &amp;\cdots &amp; k_{19} &amp;L_1 &amp; 1<br>\end{pmatrix}<br>\begin{pmatrix}<br>m &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0\<br>0 &amp; m &amp; \cdots &amp; 0 &amp; 0 &amp; 0\<br>\vdots &amp;\vdots &amp; \ddots &amp; \vdots &amp;\vdots &amp; \vdots\<br>0 &amp; 0 &amp; \cdots &amp;m &amp;0 &amp; 0\<br>A_1 &amp; A_2 &amp;\cdots &amp;A_{19} &amp; 1 &amp; 0\<br>B_1 &amp; B_2 &amp; \cdots &amp;B_{19} &amp;0 &amp; 2^{64}<br>\end{pmatrix}</h1><p>\begin{pmatrix}<br>L_2 &amp; L_3 &amp; \cdots &amp;L_{20} &amp; L_1 &amp;2^{64}<br>\end{pmatrix}<br>$$<br>$L_i &#x3D; 64bit$，所以最后调一个$2^{64}$</p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = <span class="number">107763262682494809191803026213015101802</span></span><br><span class="line">b = <span class="number">153582801876235638173762045261195852087</span></span><br><span class="line">m = <span class="number">226649634126248141841388712969771891297</span></span><br><span class="line">c = [<span class="number">0</span>,<span class="number">7800489346663478448</span>,<span class="number">11267068470666042741</span>,<span class="number">5820429484185778982</span>,<span class="number">6151953690371151688</span>,<span class="number">548598048162918265</span>,<span class="number">1586400863715808041</span>,<span class="number">7464677042285115264</span>,<span class="number">4702115170280353188</span>,<span class="number">5123967912274624410</span>,<span class="number">8517471683845309964</span>,<span class="number">2106353633794059980</span>,<span class="number">11042210261466318284</span>,<span class="number">4280340333946566776</span>,<span class="number">6859855443227901284</span>,<span class="number">3149000387344084971</span>,<span class="number">7055653494757088867</span>,<span class="number">5378774397517873605</span>,<span class="number">8265548624197463024</span>,<span class="number">2898083382910841577</span>,<span class="number">4927088585601943730</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#0是seed的高位</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(c)):</span><br><span class="line">    c[i] = c[i] &lt;&lt; <span class="number">64</span></span><br><span class="line"></span><br><span class="line">A = [<span class="number">1</span>]</span><br><span class="line">B = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(c)-<span class="number">1</span>):</span><br><span class="line">    Ai = a*A[i-<span class="number">1</span>] % m</span><br><span class="line">    Bi = (a*B[i-<span class="number">1</span>] + a*c[i]+b-c[i+<span class="number">1</span>]) % m</span><br><span class="line">    A.append(Ai)</span><br><span class="line">    B.append(Bi)</span><br><span class="line"></span><br><span class="line">A = A[<span class="number">1</span>:]</span><br><span class="line">B = B[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">M = Matrix(<span class="number">21</span>,<span class="number">21</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">19</span>):</span><br><span class="line">    M[i,i] = m</span><br><span class="line">    M[-<span class="number">1</span>,i] = B[i]</span><br><span class="line">    M[-<span class="number">2</span>,i] = A[i]</span><br><span class="line">M[-<span class="number">1</span>,-<span class="number">1</span>] = <span class="number">2</span>^<span class="number">64</span></span><br><span class="line">M[-<span class="number">2</span>,-<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> M.LLL():</span><br><span class="line">    <span class="keyword">if</span> i[-<span class="number">1</span>] == <span class="number">2</span>^<span class="number">64</span>:</span><br><span class="line">        L1 = i[-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">seed1 = c[<span class="number">1</span>] + L1</span><br><span class="line"></span><br><span class="line">inv = gmpy2.invert(a,m)</span><br><span class="line">seed = inv * (seed1 - b) % m</span><br><span class="line"></span><br><span class="line">s = [seed]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">23</span>):</span><br><span class="line">    s.append((a*s[i] + b)%m)</span><br><span class="line"></span><br><span class="line">key = s[-<span class="number">3</span>] &gt;&gt; <span class="number">64</span></span><br><span class="line">key = (key &lt;&lt; <span class="number">64</span>) + (s[-<span class="number">2</span>] &gt;&gt; <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">key = long_to_bytes(key).ljust(<span class="number">16</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">iv = long_to_bytes(s[-<span class="number">1</span>]).ljust(<span class="number">16</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cipher = <span class="built_in">open</span>(<span class="string">&quot;ct&quot;</span>,<span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line"></span><br><span class="line">aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line"><span class="built_in">print</span>(aes.decrypt(cipher))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>格密码</category>
      </categories>
      <tags>
        <tag>Lattice</tag>
      </tags>
  </entry>
  <entry>
    <title>沙盒逃逸</title>
    <url>/2023/08/18/%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8/</url>
    <content><![CDATA[<p>从HNCTF开始学习沙盒逃逸</p>
<span id="more"></span>

<h1 id="calc-jail-beginner-JAIL"><a href="#calc-jail-beginner-JAIL" class="headerlink" title="calc_jail_beginner(JAIL)"></a>calc_jail_beginner(JAIL)</h1><p>题目源码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Your goal is to read ./flag.txt</span></span><br><span class="line"><span class="comment">#You can use these payload liked `__import__(&#x27;os&#x27;).system(&#x27;cat ./flag.txt&#x27;)` or `print(open(&#x27;/flag.txt&#x27;).read())`</span></span><br><span class="line"></span><br><span class="line">WELCOME = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  _     ______      _                              _       _ _ </span></span><br><span class="line"><span class="string"> | |   |  ____|    (_)                            | |     (_) |</span></span><br><span class="line"><span class="string"> | |__ | |__   __ _ _ _ __  _ __   ___ _ __       | | __ _ _| |</span></span><br><span class="line"><span class="string"> | &#x27;_ \|  __| / _` | | &#x27;_ \| &#x27;_ \ / _ \ &#x27;__|  _   | |/ _` | | |</span></span><br><span class="line"><span class="string"> | |_) | |___| (_| | | | | | | | |  __/ |    | |__| | (_| | | |</span></span><br><span class="line"><span class="string"> |_.__/|______\__, |_|_| |_|_| |_|\___|_|     \____/ \__,_|_|_|</span></span><br><span class="line"><span class="string">               __/ |                                           </span></span><br><span class="line"><span class="string">              |___/                                            </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(WELCOME)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Welcome to the python jail&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Let&#x27;s have an beginner jail of calc&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Enter your expression and I will evaluate it for you.&quot;</span>)</span><br><span class="line">input_data = <span class="built_in">input</span>(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Answer: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">eval</span>(input_data)))</span><br></pre></td></tr></table></figure>

<p>了解一下eval函数的特性即可解决</p>
]]></content>
      <tags>
        <tag>jail</tag>
      </tags>
  </entry>
  <entry>
    <title>初识格</title>
    <url>/2023/07/28/%E5%88%9D%E8%AF%86%E6%A0%BC/</url>
    <content><![CDATA[<p>记录笔者学习Lattice的过程，好记忆不如烂笔头</p>
<span id="more"></span>

<h1 id="格的定义"><a href="#格的定义" class="headerlink" title="格的定义"></a>格的定义</h1><p>给定$n$维空间中$n$个线性无关向量：$\vec{b_1},\vec{b_2},…,\vec{b_n}$，并把这$n$个向量称为基</p>
<p>对于这一组向量，存在线性组合$x_1\vec{b_1}+x_2\vec{b_2}+\dots+x_n\vec{b_n}$</p>
<p>我们把整系数的线性组合构成的集合称为格即$x_i \in \mathbb{Z}$<br>$$<br>记为\mathcal{L}(B) &#x3D;<br>\begin{Bmatrix}<br>x_1\vec{b_1}+x_2\vec{b_2} + …+x_n\vec{b_n} ,x_i \in \mathbb{Z}<br>\end{Bmatrix}<br>$$</p>
<p>举个例子</p>
<p><img src="/../images/Lattice/0.png"></p>
<p>上图为2维空间中的一个格，这个格的基为$(0,1)和(1,0)$</p>
<p><strong>需要注意的是，不同的基有可能生成同样的格。</strong></p>
<p>同样是这个二维空间的格，我们可以用下面这个基构成</p>
<p><img src="/../images/Lattice/1.png"></p>
<p><strong>这组基为</strong>$(1,1)$和$(2,1)$</p>
<p>这里提出一个问题，<strong>什么样的基可以生成同样的格？</strong>即格基的等价变换问题</p>
<h1 id="格基的等价变换"><a href="#格基的等价变换" class="headerlink" title="格基的等价变换"></a>格基的等价变换</h1><ol>
<li>$\color{red}列向量交换$，即$\vec{b_i}\longleftrightarrow \vec{b_j}$</li>
</ol>
<p>这里给出二维空间中的例子</p>
<p><strong>上述格基$\vec{b_1} &#x3D;(0,1),\vec{b_2}&#x3D;(1,0)$，现在令二者交换，即$\vec{b_1} &#x3D;(1,0),\vec{b_2}&#x3D;(0,1)$</strong></p>
<p>显而易见，两组格基产生的格是一样的</p>
<ol start="2">
<li>$\color{red}向量取反$，即$\vec{b_i} \longleftrightarrow {-\vec{b_i}}$</li>
</ol>
<p>还是上述例子，$\vec{b_1} &#x3D; (0,1)$，现在令$\vec{b_1}’ &#x3D; -\vec{b_1} &#x3D; (0,-1)$</p>
<p>显而易见，变换之后的基产生的格是一样的</p>
<ol start="3">
<li>$\color{red}整系数线性组合$，即$\vec{b_i} \longleftrightarrow \vec{b_i} + k \vec{b_j}$</li>
</ol>
<p>对于上述基$\vec{b_1}&#x3D;(0,1),\vec{b_2}&#x3D;(1,0)$构成的格中</p>
<p>取格点$(4,3)$</p>
<p>现将$\vec{b_1} \longleftrightarrow \vec{b_1}+2\vec{b_2}$，即新的格基为$\vec{b_1}’&#x3D;(2,1),\vec{b_2}’&#x3D;(1,0)$</p>
<p>则格点$(3,4)$对于新的格基有了新的线性组合$(3,4)&#x3D;3\vec{b_1}’-2\vec{b_2}’$</p>
<p>但还是在这个新基的产生的格点上</p>
<p><strong>上述3个方法可以概括为格基矩阵B右乘一个幺模矩阵U(行列式为</strong>$±1$<strong>的矩阵)</strong></p>
<p>对于上述例子有下式</p>
<p><img src="/../images/Lattice/2.png"></p>
<p>且$||U||&#x3D;1$</p>
<p>$\therefore$格基$B$和格基$B’$等价</p>
<p>由此我们可以得到结论</p>
<h1 id="两个格基产生相同格的条件"><a href="#两个格基产生相同格的条件" class="headerlink" title="两个格基产生相同格的条件"></a>两个格基产生相同格的条件</h1><p>如果格基矩阵$B_1,B_2$满足$B_2&#x3D;B_1U$，则两格基产生的格一样</p>
<h1 id="格的基本区域"><a href="#格的基本区域" class="headerlink" title="格的基本区域"></a>格的基本区域</h1><p><strong>给定格基B产生的格</strong>，<strong>我们可以确定基础平行多面体</strong>，设为P(B)，$P(B) &#x3D;<br>\begin{Bmatrix}<br>a_1\vec{b_1}+a_2\vec{b_2} + … +a_n\vec{b_n}\quad |(0 \le a_i &lt;1)<br>\end{Bmatrix}$</p>
<p>可以理解为最小重复单元</p>
<p>下面给出二维空间中某个格的基本区域</p>
<p><img src="/../images/Lattice/3.png"></p>
<p><strong>上图中，红色区域就是这个格的基本区域</strong></p>
<p>当我们把基本区域放到的每个格点中，则会遍布这个二维空间</p>
<p><strong>基本区域有什么用呢？</strong></p>
<p>我们发现，当在格中随便取一点$k$，我们都可以把他映射到基本区域中的某个点中</p>
<p>例如$k(3.5,2.4)$，其映射在基本区域的点就是$k’(0.5,0.4)$</p>
<p><img src="/../images/Lattice/4.png"></p>
<p>映射后：</p>
<p><img src="/../images/Lattice/5.png"></p>
<p>上面的操作可归纳为：<br>$$<br>k &#x3D; m_1\vec{b_1}+m_2\vec{b_2}+…+m_n\vec{b_n}<br>$$<br>映射:<br>$$<br>k’ &#x3D; (m_1 \mod 1)\vec{b_1}+(m_2 \mod 1)\vec{b_2} +…+(m_n \mod 1)\vec{b_n}<br>$$</p>
<p><strong>除此之外，我们可以发现，在一个基本区域中，不存在两个等价的点</strong></p>
<h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><p>格的行列式指的是基本区域的体积</p>
<p>由上面格基产生相同格的条件，我们可以推断出<strong>他们的行列式相同</strong></p>
<p>$\because B_2 &#x3D; B_1U$</p>
<p>$\therefore det(B_2)&#x3D;det(B_1)det(U)&#x3D;det(B_1)$</p>
<p><strong>行列式越小，格点的密度越大</strong></p>
<h1 id="延展空间"><a href="#延展空间" class="headerlink" title="延展空间"></a>延展空间</h1><p>我们称格$\mathcal{L}(B)$中基向量的所有线性组合所形成的集合为这组基向量所张成的延展空间(span)</p>
<p>即$span(\mathcal{L}(B)) &#x3D;<br>span(B)&#x3D;<br>\begin{Bmatrix}<br>a_1\vec{b_1}+a_2\vec{b_2}+…+a_n\vec{b_n}|a_i\in \mathbb{R}<br>\end{Bmatrix}$</p>
<h1 id="Successive-Minima-连续极小"><a href="#Successive-Minima-连续极小" class="headerlink" title="Successive Minima(连续极小)"></a>Successive Minima(连续极小)</h1><p><strong>由于格上的点是离散的，所以除了零向量外肯定存在一个非零向量，其长度是最短的。</strong></p>
<p>我们定义$\lambda_1(\mathcal{L})$为格$\mathcal{L}$中最短非零向量的长度**(这里不考虑零向量)**</p>
<p>这里的长度指的是欧几里得范数</p>
<p>准确的说，应该是最短非零向量集，因为有一个最短非零向量就有两个(这个向量取反)</p>
<p>因此，在$n$维格中，我们有$2n$个最短向量，每个轴上都有两个最短向量</p>
<p><strong>给个二维空间中的例子来理解</strong></p>
<p><img src="/../images/Lattice/6.png"></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在格$\mathcal{L}$中，第$i$连续极小值$(i&#x3D;1,2,\dots,n)$，为$\lambda_i&#x3D;min{r:dim \enspace span(\mathcal{B}(r))\cap \mathcal{L}\ge i}$</p>
<p>定义是比较抽象的</p>
<p>在定义中，$\mathcal{B}(r)$表示半径为$r$的超球体,该超球体和格$\mathcal{\mathcal{L}}$交集产生的向量张成(span)的空间的维度(dim)为i</p>
<p>换言之,第i个连续极小值即包含至少i个线性无关格向量的最小球半径</p>
<p><strong>以下图为例</strong></p>
<p><img src="/../images/Lattice/7.png"></p>
<p><strong>把球的中心放在原点，若球中有非零格向量，那么球中不止一个格向量。以上图为例，红色区域包含了一个非零格向量以及它的逆向量，但这二者在同一条直线上，仅张成一维空间，该超球体的半径是$\lambda_1$</strong></p>
<p><strong>而下图中，一个更大的超球体包含了4个非零格向量，可以张成二维空间，该超球体的半径是$\lambda_2$</strong> </p>
<p><img src="/../images/Lattice/8.png"></p>
<p>对这个概念模糊不清</p>
<p><strong>重点是要知道$\lambda_1(\mathcal{L})$指的是格$\mathcal{L}$最短非零向量的长度</strong></p>
<p><strong>施密特正交化给出格中最短非零向量长度的有效下界</strong></p>
<h1 id="施密特正交化"><a href="#施密特正交化" class="headerlink" title="施密特正交化"></a>施密特正交化</h1><p>其作用是把一组基转换成一组正交基。学了线性代数这门课的话理解起来并不难。</p>
<p>这里给出二维空间中的一个例子：</p>
<p><img src="/../images/Lattice/9.png"></p>
<p><strong>如图，把原来一组基</strong>$\vec{b_1},\vec{b_2}$<strong>，转换成</strong>$\widetilde{b}_1,\widetilde{b}_2$<strong>这一组正交基</strong></p>
<p>过程如下</p>
<p>首先,给定一组线性无关的向量$\vec{b_1},\vec{b_2},…,\vec{b_n}$</p>
<p>然后通过计算得到一组正交基$\widetilde{b}_1,\widetilde{b}_2,…,\widetilde{b}_n$</p>
<p><img src="/../images/Lattice/10.png"></p>
<p>$&lt;\vec{b_i},\vec{b_j}&gt;$表示$\vec{b_i}$与$\vec{b_j}$的内积</p>
<p>我们令$\mu_{i,j}&#x3D;\frac{&lt;\vec{b_i},\widetilde{b}_j&gt;}{&lt;\widetilde{b}_j,\widetilde{b}_j&gt;}$</p>
<p>则正交化向量可表示为</p>
<p><img src="/../images/Lattice/11.png"></p>
<p>书上的解释（虽然有些杂乱，也可参考参考）：</p>
<p><img src="/../images/Lattice/0.jpg"></p>
<p><strong>值得一提的是，施密特正交化能将基正交化，但并不能直接应用于格基，因为正交化过程中系数并没限制为整数，也就是 格基 施密特正交化后的结果很可能不在格上</strong></p>
<p>下面讲施密特正交化的应用</p>
<h2 id="QR分解"><a href="#QR分解" class="headerlink" title="QR分解"></a>QR分解</h2><p>对于格而言，先对格基$\vec{b_1},\vec{b_2},…,\vec{b_n}$间接使用施密特正交化 ($\color{red}施密特正交化过程中,没有保证系数都是整数,我们需要对其取整$)</p>
<p>之后我们能得到<strong>近似正交基</strong>$\widetilde{b}_1,\widetilde{b}_2,…,\widetilde{b}_n$</p>
<p>把他写成矩阵形式为</p>
<p><img src="/../images/Lattice/13.png"></p>
<p>本质上，QR分解形式的矩阵是格基的另一种矩阵表示法，上图中每个列向量都是格基</p>
<p><strong>结论如下</strong></p>
<ol>
<li>该矩阵是上三角行列式所以行列式$det(B) &#x3D; \prod_{i&#x3D;1}^{n}||\widetilde{b}_i||$</li>
<li>我们能得到$\lambda_1$的下界，即$\lambda_1\ge min(||\widetilde{b}_i||)$</li>
</ol>
<p>我的理解是，既然得到了近似正交基，那我把$min(||\widetilde{b}_i||)$这个基之外的基全部取0，是不是就能得到$\lambda_1$了</p>
<p>更严谨的证明：</p>
<p><img src="/../images/Lattice/12.png"></p>
<p>看不懂证明就这样吧，总之我们得到了$\lambda_1$的下界</p>
<h1 id="格中难题"><a href="#格中难题" class="headerlink" title="格中难题"></a>格中难题</h1><h2 id="SVP最短向量问题-Shortest-Vector-Problem"><a href="#SVP最短向量问题-Shortest-Vector-Problem" class="headerlink" title="SVP最短向量问题(Shortest Vector Problem)"></a>SVP最短向量问题(Shortest Vector Problem)</h2><p>SVP，最短向量问题，准确的说是最短非零向量问题。定义如下</p>
<p><strong>给定一个基为$B$的格$\mathcal{L}(B)$,找到一个这个基构成的格点,使得这个点离0坐标点的距离最近</strong>，即$||Bx||\le \lambda_1$</p>
<p><strong>因为$\lambda_1$是格点之间的最短距离，所以Bx距离0点的距离并不会小于$\lambda_1$，最多等于$\lambda_1$</strong></p>
<p><strong>最短向量是存在上界的</strong></p>
<h2 id="Hermite定理"><a href="#Hermite定理" class="headerlink" title="Hermite定理"></a>Hermite定理</h2><p>这个定理给出了最短向量的上界，定理内容如下</p>
<p><strong>对于n维的格$\mathcal{L}$,都包含一个非零向量$\vec{v} \in \mathcal{L}$,满足$||\vec{v}|| \le \sqrt{n}det(\mathcal{L})^{\frac{1}{n}}$</strong></p>
<p><img src="/../images/Lattice/20.png"></p>
<p>上图中，格的基向量$B&#x3D;[b_1,b_2]$,我们找到了$Bx&#x3D;5b_1-2b_2$这个点，正好就是格的最短向量λ1</p>
<p>对于某些不太好的格来说，严格计算SVP是件很苦难的事，于是有了要求宽松一点的$SVP\gamma$问题</p>
<p><strong>定义如下：</strong></p>
<p>给定一个基为B的格$\mathcal{L}(B)$,找到一个这个基构成的格点,使得这个点离0坐标点的距离$\le \gamma\lambda_1$</p>
<p>$||Bx|| \le \gamma \lambda_1$</p>
<p><img src="/../images/Lattice/15.png"><br>$$<br>如图所示，当\gamma&#x3D;2时，SVP_\gamma问题有了很多解<br>$$</p>
<h2 id="CVP最近向量问题-Closest-Vector-Problem"><a href="#CVP最近向量问题-Closest-Vector-Problem" class="headerlink" title="CVP最近向量问题(Closest Vector Problem)"></a>CVP最近向量问题(Closest Vector Problem)</h2><p>定义如下：</p>
<p><strong>给定连续空间中任意的一个点t，找到距离这个点最近的格点Bx，满足$||Bx-t|| \le \mu$</strong></p>
<p><img src="/../images/Lattice/16.png"></p>
<p>这里我们的约束距离$\mu$就是这个Lattice的覆盖半径(即所有可能的t中距离格点最长的距离)。</p>
<p>同理我们有要求宽松点的$CVP\gamma$问题</p>
<p><strong>定义如下：</strong><br>$$<br>||Bx-t|| \le \gamma\mu<br>$$<br><img src="/../images/Lattice/17.png"><br>$$<br>这个图很好表示了当\gamma&#x3D;2的情况下，我们找到了更多满足CVP的点<br>$$<br>加上一个宽松的参数$\gamma$之后，CVP问题就会变得简单一些，解的数量也变多了。</p>
<h2 id="SIVP最短独立向量问题-Shortest-Independent-Vector-Problem"><a href="#SIVP最短独立向量问题-Shortest-Independent-Vector-Problem" class="headerlink" title="SIVP最短独立向量问题(Shortest Independent Vector Problem)"></a>SIVP最短独立向量问题(Shortest Independent Vector Problem)</h2><p><strong>定义如下</strong><br>$$<br>给定一个格\mathcal{L}(B),找到n个线性独立的向量Bx_1,Bx_2,…Bx_n并且这些向量的长度都要小于等于最长的最短向量<br>$$</p>
<p>$$<br>max||Bx_i|| \le \lambda_n<br>$$</p>
<p><img src="/../images/Lattice/18.png"><br>$$<br>这个图很好表达了当n&#x3D;2的情况下，我们找到了两个小于等于\lambda_2的点<br>$$</p>
<p>$$<br>同理,我们有SIVP_\gamma问题<br>$$</p>
<p>$$<br>在SIVP_\gamma问题中,我们只需要找到\gamma \lambda_n范围中的格点即可<br>$$</p>
<p><img src="/../images/Lattice/19.png"></p>
<h1 id="LLL算法"><a href="#LLL算法" class="headerlink" title="LLL算法"></a>LLL算法</h1><p><strong>首先，我们知道一个格可能有很多基，这些基里面，肯定有好坏之分</strong></p>
<p><img src="/../images/Lattice/22.png"></p>
<p>比如上图中，蓝色的基明显就比绿色的基好。</p>
<p>这是因为</p>
<ol>
<li><strong>蓝色的基向量更短</strong></li>
<li><strong>蓝色的基夹角更大，即正交性更好，这会帮助我们更好地观察格</strong></li>
</ol>
<h2 id="LLL算法的目的"><a href="#LLL算法的目的" class="headerlink" title="LLL算法的目的"></a>LLL算法的目的</h2><p><strong>在n维空间中，LLL算法要做的是让施密特正交化的程度最大化</strong></p>
<p>官方解答是，LLL算法要找一个基，使得Gram-Schmidt向量的正交程度不会下降太快</p>
<p>以下是LLL规约基的样子</p>
<p><img src="/../images/Lattice/23.png"></p>
<p>这其实就是施密特正交化的过程</p>
<p>B这个基可以写成一个正交向量构成的矩阵，乘上一个幺模矩阵</p>
<h2 id="LLL规约基拥有的性质"><a href="#LLL规约基拥有的性质" class="headerlink" title="LLL规约基拥有的性质"></a>LLL规约基拥有的性质</h2><ol>
<li><p>所有$|\mu_{i,j}|\le \frac{1}{2}$</p>
</li>
<li><p>向量长度满足这样关系:</p>
<p><img src="/../images/Lattice/27.png"></p>
</li>
</ol>
<p>性质2大概的意思就是得到的向量不能太短</p>
<p>两个性质综合起来的结论是$||\widetilde{b}_{i+1}||^2 \ge \frac{1}{2}||\widetilde{b}_i||^2$</p>
<p><strong>这就是LLL算法？？？？？？？？？？？？？对此我十分疑惑</strong></p>
<p><img src="/../images/Lattice/24.png"><br>$$<br>我们有一个基B，用b_1,b_2,\dots,b_n表示，写成列向量的形式即得到等号左边的矩阵。<br>$$</p>
<p>$$<br>中间的是施密特正交基,用\widetilde{b}_1,\widetilde{b}_2,\dots,\widetilde{b}_n表示<br>$$</p>
<p>需要在正交基乘上右边的矩阵才能得到B</p>
<h3 id="如何让这些u都小于0-5？"><a href="#如何让这些u都小于0-5？" class="headerlink" title="如何让这些u都小于0.5？"></a>如何让这些u都小于0.5？</h3><p>只要把每一列多次减去第一列就可以满足</p>
<h3 id="如何保证向量不会减小得太快"><a href="#如何保证向量不会减小得太快" class="headerlink" title="如何保证向量不会减小得太快"></a>如何保证向量不会减小得太快</h3><p>$$<br>如果\widetilde{b}_2和\widetilde{b}_3不符合第二个条件，会把\widetilde{b}_2和\widetilde{b}_3换一下<br>$$</p>
<p>每次交换后，我们都会更接近于得到一个更好的基</p>
<p>这里没给出证明。</p>
<p><strong>讲到这里，我还是不太明白LLL算法能给我带来什么</strong></p>
<p>一道例题讲解格密码的应用：</p>
<h1 id="入门题"><a href="#入门题" class="headerlink" title="入门题"></a>入门题</h1><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from secret import flag</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">f = bytes_to_long(flag)</span><br><span class="line">p = getPrime(512)</span><br><span class="line">g = getPrime(128)</span><br><span class="line">h = gmpy2.invert(f+20192020202120222023, p) * g % p</span><br><span class="line"></span><br><span class="line">print(&#x27;h =&#x27;, h)</span><br><span class="line">print(&#x27;p =&#x27;, p)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">h = 2230300126583677861466927910427460605336142000604400796769019169330805327830058127399640469637301157563524664730082687590109425103649095203274991089542329</span><br><span class="line">p = 6950733137747588463708927295050453925761832477377823596882238234496472403054344156839969133381577140118982692621000380716326275220824006196311323447685281</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>要拿到flag,就得求出f的值</p>
<p>先令$f’ &#x3D; f+20192020202120222023$</p>
<p>已知$h \equiv f’^{-1}g (\mod p)$</p>
<p>$\therefore hf’ \equiv g (\mod p)$</p>
<p>$\therefore g &#x3D; hf’ -kp$</p>
<p>构造出</p>
<p><img src="/../images/Lattice2/0.png"></p>
<h2 id="为什么LLL算法可以得到我们需要的f’-g"><a href="#为什么LLL算法可以得到我们需要的f’-g" class="headerlink" title="为什么LLL算法可以得到我们需要的f’,g"></a>为什么LLL算法可以得到我们需要的f’,g</h2><p><strong>LLL算法可以把</strong>$(h,1),(p,0)$<strong>这组基，变成正交化程度最大的一组基，它可以求解最短向量问题</strong></p>
<p><strong>如果说</strong>$点(f’,g)$<strong>正好是最短向量，那是不是用LLL算法就可以求解出f’,g的值</strong></p>
<p><strong>为什么点</strong>$(f’,g)$<strong>是最短向量？</strong></p>
<p><strong>Hermite定理给出了最短向量的上界：</strong><br>$$<br>||\vec{v}|| \le \sqrt{n}det(\mathcal{L})^{\frac{1}{n}}<br>$$<br>对于格$\mathcal{L}$</p>
<p><img src="/../images/Lattice2/7.png"></p>
<p>其行列式$det(\mathcal{L})&#x3D;p$</p>
<p>所以最短向量$||\vec{v}|| \le \sqrt{2p}$</p>
<p>而$p$是$512bit$的，$g$是$128bit$</p>
<p>所以向量$\vec{v}&#x3D;(f’,g)$的长度$||\vec{v}||$远小于$\sqrt{2p}$的大小</p>
<p>所以可以认为我们需要求的$f’,g$就是最短向量</p>
<p>求解出$f’$后，我们便能求出f</p>
<p>构造的矩阵依赖下式</p>
<p><img src="/../images/Lattice2/1.png"></p>
<p>exp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line"></span><br><span class="line">h = 2230300126583677861466927910427460605336142000604400796769019169330805327830058127399640469637301157563524664730082687590109425103649095203274991089542329</span><br><span class="line">p = 6950733137747588463708927295050453925761832477377823596882238234496472403054344156839969133381577140118982692621000380716326275220824006196311323447685281</span><br><span class="line"></span><br><span class="line">Ge = Matrix(ZZ,[[h,1],[p,0]])</span><br><span class="line">print(Ge.LLL())</span><br><span class="line">g,f = Ge.LLL()[0]</span><br><span class="line">g,f = abs(g),abs(f)</span><br><span class="line"></span><br><span class="line">print(libnum.n2s(int(f-20192020202120222023)))</span><br></pre></td></tr></table></figure>

<p>值得注意的是，当我们把中间的已知矩阵进行乘法以后，输出的结果也会有所不同。</p>
<p><strong>例如，我把中间向量修改为</strong></p>
<p><img src="/../images/Lattice2/12.png"></p>
<p><strong>输出的值是原来g的10倍</strong><br>$$<br>\because f’×10h-10p×k &#x3D; 10g<br>$$<br>在一定情况下，可以先求需求量的倍数，再求需求量</p>
]]></content>
      <categories>
        <category>格密码</category>
      </categories>
      <tags>
        <tag>Lattice</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔(二)</title>
    <url>/2023/08/18/%E9%9A%8F%E7%AC%94(%E4%BA%8C)/</url>
    <content><![CDATA[<p>总结一些18岁这一年的经历吧。</p>
<span id="more"></span>

<p>今天是2023年8月18日，农历七月初三，正是笔者的生日。</p>
<p>先从高考结束讲起。</p>
<p>三天的高考中，第一天语数考的十分不理想，估摸着自己要失败了，晚上并没有复习第二天的科目，和朋友打了几把游戏便睡了。后两天的考试伴随雨天，搞得人怪难受的，除了化学，其他科目和平常感觉差不多。考完政治便急匆匆回了家，没有像其他人一样，朋友家人在门口送花。这一点我无所谓，我把只是把高考当成一次不太平凡的考试罢了。回到家后便打开电视收看喜欢的综艺，晚饭过后便睡了觉，没有通宵之类的放纵行为。对未来没什么规划，也没打算旅游，在家里玩了几天。高考出分的那一刻，有意外也有惊喜，惊喜的是后两天的科目并没有考砸，反而出乎意料的好，但语文也出乎意料的差，离梦想的学习确实差了几分。剩下的几天便是研究志愿填报的事情了，最后报了本省一所比较好的大学，选了网络空间安全专业（我也不知道为啥我就把他当第一志愿了，也许比较新颖吧）志愿填报确实是件难事。录取结果出来之后加上了新生群，简单了解了一下事宜，接触了CTF（这也许是比较关键的一件事吧）。在剩下的一个多月的时间，瞎玩是占大部分的，也简单学习了一些C语言知识，还学了单车（惊讶吧，18岁才会踩单车）。</p>
<p>时间来到2023年9月12日，早上6点便起了，几个小时的车程，带着紧张又激动的心情来到学校，到达学校已是中午。在学长引导下，把行李放回宿舍之后边和好朋友一起吃了午饭（挺幸运的，能和朋友在同一所大学），回到宿舍整理了一下内务便和朋友去学校逛了逛。第一次和同学们见面是专业两个班一起举办的一个破冰行动，大家自我介绍，表演才艺，有一说一确实有心动的女生，不过大部分是隔壁班的，当然自己班也有三两个。接下来的一周是新生宣传周，每天有部分时间是集合听课了解学校。第一个周末便和朋友去了图书馆（这一点我也是没想到的，我一个从不看书的人居然会去图书馆。不过谁能想到我之后有时间便是泡在图书馆呢）。</p>
<p>接下来便是一段学习经历了，有一说一我得提一嘴，为什么会去参加广播操啊，真的是折磨人，大早上起来做操，满身汗去上课，还加上晚自习课后训练，不过好在是熬过去了。也是加了网安协会，毕竟是和专业有关，当时不太懂，便跟风加了进去。</p>
<p>时间来到第一次参加CTF比赛，具体记不大清了，只记得当时没什么实力，整个人思想也没觉悟，并没有很热爱CTF，更多的课余时间是打游戏，也是跟着室友混了个奖（小比赛）。时间来到12月12日，因为疫情被迫提前回家，当时还感觉挺难过的，因为见不到自己的心动女孩了。回到家后，稍作整顿，每天学点东西再娱乐一会，准备期末考的时间还准备的挺好，因为没把时间花在比赛上，第一个学期的成绩还算不错，在专业第五。</p>
<p>一个多月的寒假转眼就过，寒假期间也是决定要走密码学方向（我不确定这个方向是否合适），刚开始学习没有人指导什么的，自己瞎学了一些东西就开始做题，在做题中学东西（这个方式对我来说并没有用）。寒假打了西湖论剑，不出意外爆0，现在回头看，以当时的我的能力根本就做不出什么题。</p>
<p>回到学校，依旧喜欢着那个女孩。新的学期，游戏的时间减少了，更多的时间花在了学习CTF，实力也有所上升，在校赛拿了一等奖，还是挺开心的。值得提的是，“大物实验”这门课是真的把我恶心到了。感觉这个学期时间过得很快，转眼就到了备战期末考的时间。在这之前，有幸认识了星盟战队的师傅，在师傅们的帮助下，有了学习的方向，考完试之后是一段个性化培养周的时间，在这时间里，认认真真的学习了一番，实力有所提升。但第二学期的成绩并不理想，需要调整学习方式了。</p>
<p>稍微总结一下第二学期吧，多了份羡慕，多了份焦虑，羡慕同届一位CTFer已经赚了大钱，焦虑未来该干嘛，该考研，还是该直接工作呢，我能干些什么呢？他们都说网安人才不愁就业，可怎样才算上人才呢？</p>
<p>回家前一周搬到了新宿舍，4人间，两个室友早早回了家，偌大的房间显得有些安静，不过我还是每天泡图书馆。</p>
<p>时间来到2023年7月4日，成功加入星盟，不过是个预备队。</p>
<p>回到家后参加星盟师傅组织的特训计划，跟着特训学习，自己确实进步了不少，见识也长进了不少。</p>
<p>时间来到2023年7月25日，成功选上了协会的密码学部长。这确实是件比较开心的事。</p>
<p>讲完了学习，想讲讲情感。大一这一年，和女生打交道的时间好像真的特别少，让我不得不怀疑计算机类的学生真的难谈到恋爱吗？但室友却在来到学校一个月里就谈上了，喜欢的女生也在放假之间谈了恋爱，想了想也许自己的问题吧，讲到这不得不叹声气。本人就一普通人，长相并不突出，也没什么能吸引人的点，好在身体健康没什么缺陷，性格上憨厚内向，认为自己吸引不到女生（感觉确实如此），现实中很少主动接触女生，只敢在网上聊聊天罢了，根本没有追求女生的勇气。本人是很渴望在大学期间有一段恋爱的，不过也仅局限在“想”，朋友们总说我怂，确实如此，因为没有拿得出手的东西，拿什么来吸引人呢？所以只好等，等一个不知道有没有可能的“可能”，等人来了解我。</p>
<p>7月底这几天看到协会迎新群里来了很多新生，看到新生对CTF发问，此刻便想起去年的我，虽早早便了解了CTF，可当时的我还是迷茫的，没有铁了心要着手哪个方向。现在的我，有些后悔没有早日下定决心学习，也多少有些犹豫踏上了密码学这条道路，下学期了解到的活动几乎都是攻防演练，似乎证明攻防，渗透，护网才是主流。</p>
<p>八月初也是在学长的渠道那里报了关于护网的活动，学了一点点基础，没提起兴趣。</p>
<p>被星盟里的师傅拉去出NSSCTF两周年的密码题，怪紧张的，以我的知识水平，出的题也许随便就给打爆了，而且没什么创新，想到这，不禁担心是不是会被喷烂。</p>
<p>8月12日，比较开心的一天吧，从预备队提到了主队，如愿和交流比较多的师傅同队了，他们领先我好多，我得花多少时间才能达到他们的水平呢？马上就开学了，还有很多内容没掌握，提到这又开始焦虑了。</p>
<p>发现从下学期开始，焦虑就常常伴随着我，看到高中同学旅游的旅游，挣钱的挣钱，恋爱的恋爱，难免有些许羡慕，前几天看一位同学的朋友圈，说放假就该躺平，可于我而言，读书读了个半吊子，其他方面也没天赋，又不甘心于摆烂，真的想躺平就躺平吗？</p>
<p>8月13日，看了NepCTF的赛后复现，感叹这些出题人的水平都好高啊，自己没接触的内容还是太多了。</p>
<p>总结便做到这里，希望接下来的日子好好加油。</p>
<p>送给看到这篇文章的人一句话：<strong>保持乐观，心怀希望，成功就在不远处</strong></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>背包密码</title>
    <url>/2023/08/02/%E8%83%8C%E5%8C%85%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>简述背包密码</p>
<span id="more"></span>

<p>在学习背包密码之前，我们需要了解什么是背包问题</p>
<h1 id="什么是背包问题？"><a href="#什么是背包问题？" class="headerlink" title="什么是背包问题？"></a>什么是背包问题？</h1><p>假定一个背包可以承重$S$，现在有$n$个物品，其重量分别为$a_1,a_2\dots a_n$，试问装哪些物品可以<strong>恰好</strong>使得背包被装满，而且每个物品<strong>最多被装一次</strong>。转化成数学式子即是<br>$$<br>x_1a_1+x_2a_2+\dots+x_na_n&#x3D;S<br>$$<br>其中$x_i&#x3D;0或1$</p>
<p>显然我们必须枚举所有的 n 个物品的组合才能解决这个问题，而复杂度也就是$2^n$，这也就是背包加密的妙处所在。</p>
<p>在谈加密过程之前，先了解一下超递增序列</p>
<h1 id="什么是超递增序列"><a href="#什么是超递增序列" class="headerlink" title="什么是超递增序列"></a>什么是超递增序列</h1><p>$\begin{Bmatrix}a_1,a_2,\dots,a_n\end{Bmatrix}$是超递增序列，指的是$a_i&gt;a_1+a_2+\dots+a_{i-1}$，即第$i$个数大于前面$i-1$个数之和，也即$a_i&gt;2a_{i-1}$</p>
<p>当明文和超递增序列依次相乘再求和时<br>$$<br>x_1a_1+x_2a_2+\dots+x_na_n&#x3D;S,x_i&#x3D;<br>\begin{Bmatrix}<br>0,1<br>\end{Bmatrix},<br>a_i&gt;0<br>$$<br><strong>我们可以通过依次比较S与序列中最大的元素大小关系，来确定该元素性质</strong></p>
<p>例如，当$S&gt;a_n$时，说明$x_n&#x3D;1$</p>
<p>接下来，令$S&#x3D;S-a_n$，再比较$S$与$r_{n-1}$</p>
<p>通过n次比较，我们即可获得所有x的值</p>
<h1 id="背包密码"><a href="#背包密码" class="headerlink" title="背包密码"></a>背包密码</h1><p>背包密码流程如下:</p>
<p><img src="/../images/Lattice/25.png"></p>
<h2 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h2><h3 id="明文"><a href="#明文" class="headerlink" title="明文"></a>明文</h3><p>把<strong>明文字符串</strong>转换成<strong>二进制数字</strong>，然后<strong>从高位到低位</strong>的$0,1$作为$x_i$的值</p>
<h3 id="私钥"><a href="#私钥" class="headerlink" title="私钥"></a>私钥</h3><p>选取一个<strong>超递增序列</strong>$\begin{Bmatrix}r_1,r_2,\dots,r_n\end{Bmatrix}$</p>
<h3 id="公钥"><a href="#公钥" class="headerlink" title="公钥"></a>公钥</h3><ol>
<li><p>生成模数$B$，满足<br>$$<br>B&gt;\sum_{i&#x3D;1}^{n}r_i,即B&gt;2r_n<br>$$</p>
</li>
<li><p>生成乘数$A$，满足$gcd(A,B)&#x3D;1$</p>
</li>
<li><p>生成公钥序列$M&#x3D;\begin{Bmatrix}M_1,M_2,\dots,M_n\end{Bmatrix}$，其中$M_i \equiv Ar_i \mod B$</p>
</li>
</ol>
<h3 id="密文"><a href="#密文" class="headerlink" title="密文"></a>密文</h3><p>$$<br>S &#x3D; xM &#x3D; \sum_{i&#x3D;1}^{n}x_iM_i<br>$$</p>
<p>其中$M,A,B,S$是公布的</p>
<h2 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h2><ol>
<li><p>计算$A$关于模$B$的逆元$A^{-1}$</p>
</li>
<li><p>计算$S’$</p>
</li>
</ol>
<p>$$<br>S’\equiv A^{-1}S \equiv A^{-1}\sum_{i&#x3D;1}^nx_iM_i\equiv A^{-1}\sum_{i&#x3D;1}^nx_iAr_i \equiv \sum_{i&#x3D;1}^nx_ir_i \mod B<br>$$</p>
<ol start="3">
<li>利用超递增序列$r$的性质，求解明文二进制</li>
<li>二进制$\longrightarrow$数字$\longrightarrow$字符串</li>
</ol>
<h1 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h1><h2 id="参数不当"><a href="#参数不当" class="headerlink" title="参数不当"></a>参数不当</h2><p>如果乘数$A$，超递增序列$r$的大小选取不当，使得$Ar_i&lt;B$，则$Ar_i \mod B &#x3D; Ar_i$，这就导致公钥序列$M$是个很明显的超递增序列。</p>
<h3 id="DASCTF5月赛——knapsack"><a href="#DASCTF5月赛——knapsack" class="headerlink" title="DASCTF5月赛——knapsack"></a>DASCTF5月赛——knapsack</h3><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from functools import reduce</span><br><span class="line"></span><br><span class="line">def genKey(length):</span><br><span class="line">    A, B = getPrime(64), getPrime(1025)</span><br><span class="line"></span><br><span class="line">    Rn = getPrime(1024)</span><br><span class="line">    key1 = [Rn//2**i for i in range(1, length+1)]</span><br><span class="line">    key2 = [i*A % B sfor i in key1]</span><br><span class="line">    return key1,key2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def encrypt(text,key):</span><br><span class="line">    Sum=0</span><br><span class="line">    for i in range(len(text)):</span><br><span class="line">        Sum+=int(text[i])*key[i]</span><br><span class="line">    return Sum</span><br><span class="line"></span><br><span class="line">def save(Ciper,Key):</span><br><span class="line">    f1=open(&quot;pub.txt&quot;,&quot;w&quot;)</span><br><span class="line">    for i in range(len(Key)):</span><br><span class="line">        f1.write(str(Key[i])+&#x27;n&#x27;)</span><br><span class="line">    f2=open(&quot;cip.txt&quot;,&quot;w&quot;)</span><br><span class="line">    f2.write(hex(Ciper))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FLAG = bin(bytes_to_long(flag.encode()))[2:]</span><br><span class="line">Key1,Key2 = genKey(len(FLAG))</span><br><span class="line">Ciper = encrypt(FLAG,Key1)</span><br><span class="line">save(Ciper,Key2)</span><br></pre></td></tr></table></figure>

<p>由于没有附件，只能自己一通分析，然后对照Wp给的数据</p>
<p>首先注意到这个$key1$是个超递减的序列，而且乘数$A$非常小。</p>
<h4 id="如何求A"><a href="#如何求A" class="headerlink" title="如何求A"></a>如何求A</h4><p>我们可以通过序列中两个最小值求$gcd$来获得$A$</p>
<p>因为$A$和序列中两个最小值相乘的结果很有可能小于$B$</p>
<p>如此一来我们就获得了$A$</p>
<h4 id="如何求B"><a href="#如何求B" class="headerlink" title="如何求B"></a>如何求B</h4><p>我们先假设最小的是$a_0$，$a_0到a_n依次增大$</p>
<p>如果能找到两个数满足$a_{i+1}&lt;a_i$，这就说明从$a_i$到$a_{i+1}$存在一次模运算</p>
<p>$A \times a_{i+1}&#x3D;A \times 2a_i \mod B$</p>
<p>如此一来，是否有这个式子$B &#x3D; A(2a_i-a_{i+1})$</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.anquanke.com/post/id/206493#h3-11">DASCTF五月月赛 暨 BJDCTF 3rd 部分WP-安全客 - 安全资讯平台 (anquanke.com)</a></p>
<h2 id="背包问题通解"><a href="#背包问题通解" class="headerlink" title="背包问题通解"></a>背包问题通解</h2><p>当密度$d &#x3D; \frac{len(M)}{log_2(max(M_i))}&lt;0.9408$时，LLL算法能通杀这类背包问题</p>
<p>我们构造格$\mathcal{L}$</p>
<p><img src="/../images/Lattice2/13.png"></p>
<p> 其中$S$是密文，$M_i$是公钥序列</p>
<p>这是一个$(n+1)×(n+1)$的矩阵</p>
<p>假设每一行为$V_i$，例如$V_1&#x3D;(1,0,…,M_1,0)$，不难理解$V_i$就是格$\mathcal{L}$的基</p>
<p>我们设明文序列为$x&#x3D;\begin{Bmatrix}x_1,x_2,\dots,x_n \end{Bmatrix}$，$x_i&#x3D;\begin{Bmatrix}0,1 \end{Bmatrix}$</p>
<p>很明显，对于线性组合$x_1V_1+x_2V_2+\dots+x_nV_n-V_{n+1}$必然在格点上面，因为$x_i$只能取$0$或$1$</p>
<p>则向量$\vec{t}&#x3D;x_1V_1+x_2V_2+\dots+x_nV_n-V_{n+1}$即$\overrightarrow{t} &#x3D; (x_1,x_2,\dots,x_n,0)$</p>
<p>而$||\vec{t}||&#x3D;1$,$det(\mathcal{L})&#x3D;S^{\frac{1}{n+1}}$</p>
<p>根据$Hermite$定理，$||\vec{t}||&lt;\sqrt{n+1}\times det(\mathcal{L})$</p>
<p>所以$\vec{t}$是格$\mathcal{L}$的最短向量，可以用LLL算法解决</p>
<p>理解不一定到位，大家可以翻看参考文章</p>
<p><strong>sage代码实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">M = []														#公钥序列</span><br><span class="line">S = 														#密文</span><br><span class="line"></span><br><span class="line">n = len(M)									</span><br><span class="line">Ge = Matrix.identity(n)										#创建n维的单位阵</span><br><span class="line">last_row = [0 for x in range(n)]					</span><br><span class="line">Ge_last_row = Matrix(ZZ, 1, len(last_row), last_row)</span><br><span class="line"></span><br><span class="line">last_col = M[:]									</span><br><span class="line">last_col.append(S)											#格最后一列为公钥序列加密文S</span><br><span class="line">Ge_last_col = Matrix(ZZ, len(last_col), 1, last_col)</span><br><span class="line"></span><br><span class="line">Ge = Ge.stack(Ge_last_row)									#在矩阵Ge下面添加一行</span><br><span class="line">Ge = Ge.augment(Ge_last_col)								#在矩阵Ge右边添加一列</span><br><span class="line"></span><br><span class="line">X = Ge.LLL()</span><br><span class="line">#print(X)</span><br><span class="line">for t in X:</span><br><span class="line">    tmp = t[:-1]</span><br><span class="line">    ans = [str(abs(k)) for k in tmp]</span><br><span class="line">    try:</span><br><span class="line">        flag = int(&#x27;&#x27;.join(ans), 2)</span><br><span class="line">        print(libnum.n2s(flag))</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br><span class="line">print(&#x27;0ver&#x27;)</span><br></pre></td></tr></table></figure>

<p><code>Ge_last_row = Matrix(ZZ, 1, len(last_row), last_row)</code>：这行代码的作用是创建一个矩阵对象 <code>M_last_row</code>，使用整数环（<code>ZZ</code>）作为矩阵的元素类型，矩阵的维度为1行和<code>last_row</code> 的长度，矩阵的行向量由 <code>last_row</code> 列表提供。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">M = []</span><br><span class="line">S = </span><br><span class="line"></span><br><span class="line">n = len(M)									</span><br><span class="line">Ge = Matrix.identity(n)</span><br><span class="line">last_row = [0 for x in range(n)]					</span><br><span class="line">Ge_last_row = Matrix(ZZ, 1, len(last_row), last_row)</span><br><span class="line"></span><br><span class="line">last_col = M[:]									</span><br><span class="line">last_col.append(S)	</span><br><span class="line">Ge_last_col = Matrix(ZZ, len(last_col), 1, last_col)</span><br><span class="line"></span><br><span class="line">Ge = Ge.stack(Ge_last_row)	</span><br><span class="line">Ge = Ge.augment(Ge_last_col)</span><br><span class="line"></span><br><span class="line">X = Ge.LLL()[0]</span><br><span class="line">print(X)</span><br></pre></td></tr></table></figure>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="MoeCTF2022——MiniMiniBackPack"><a href="#MoeCTF2022——MiniMiniBackPack" class="headerlink" title="MoeCTF2022——MiniMiniBackPack"></a>MoeCTF2022——MiniMiniBackPack</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> FLAG <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_key</span>(<span class="params">size</span>):</span><br><span class="line">    s = <span class="number">1000</span></span><br><span class="line">    key = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        a = random.randint(s + <span class="number">1</span>, <span class="number">2</span> * s)</span><br><span class="line">        <span class="keyword">assert</span> a &gt; <span class="built_in">sum</span>(key)</span><br><span class="line">        key.append(a)</span><br><span class="line">        s += a</span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">L = <span class="built_in">len</span>(<span class="built_in">bin</span>(m)[<span class="number">2</span>:])</span><br><span class="line">key = gen_key(L)</span><br><span class="line">c = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">    c += key[i]**(m&amp;<span class="number">1</span>)</span><br><span class="line">    m &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(key)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>

<p><code>gen_key</code>生成超递增序列。$c$由背包加密得来，题目把$c$和私钥都给了。</p>
<p>把$c$依次和序列中最大的值比较即可求解</p>
<p>exp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">key = [1928, 4648, 12352, 24010, 58760, 148406, 441469, 906294, 2347544, 4145527, 13246047, 33012060, 104677731, 233784625, 398671830, 1138569375, 3847891246, 7151230548, 17442630021, 46416620988, 118857237060, 363519789685, 661956375011, 1712300152639, 4761949150147, 8964540458636, 24746310311237, 62452210349278, 150016895989040, 453927852027278, 948923770773559, 3275343477577565, 5756783232753127, 13616706687879089, 26402320025439836, 91814578040763059, 211796919962932717, 385545413311588646, 742071895214889791, 2137385737378343660, 5820500440463297078, 15401185997444609852, 49206779920875282228, 101148479344021765606, 205390946600728256099, 593695571211967641654, 1163476540184124239753, 3920275177926640702128, 11188401781366603668803, 26452211702098700985776, 56612547941955968739356, 176511950177344415872304, 350456159524844834233165, 932655004294881661656249, 3077731648705646793828507, 9127653332576335535543235, 14107124912327219069005253, 53639235705342264540097281, 139903414487199921597126219, 377113327325865137005647964, 797007439689940464465071770, 2456373221352926158802602905, 4997725491122440484756502995, 17601885978368777637676626066, 27945705300453872028061217316, 70259455336271034962808380541, 241339934663279791843376677893, 565927167417896365819102921696, 1498269591024734505946670540129, 4476165672138335294342834148717, 8246962867693878472370951037335, 29609522845816295639745215494800, 71952214344473760246502727717474, 169361817288205588754741757159731, 390045301314759178244461824288458, 1337540279161737220902909199776611, 3221480198479784802709388960779700, 9670513515504338974817616478456700, 16261746247432868145400788404115430, 53594268392537203440232335914792279, 142627442102890550431018293710429426, 249683635647920776857130562696997561, 689878480570146636843962995034183967, 1647889244922264517646376201060969417, 4362391204795633804803911898013660682, 11983025462449787764688227594361812707, 19474005190319410527122673327870913310, 40950423948271412394664153066384954054, 139255978428478610787399242087880835737, 382133188700471370531564036246745271608, 618340037056166043673108074267387394368, 1728641328632513907826054966389623526131, 4246454964077064700888723109771772689322, 7526932088676669848792644586429545161503, 14761773428394206759829134632198244970685, 42336665776969730227150513015344171877811, 73191053942159553542196382411683917861300, 211549032502894704558541919050681697675397, 554709644259380577558971870420849574372151, 1251152425154260246544953154540513290303621, 2818798972367329802956936052623797403793942, 7638358444068983298092603686815486790113890, 24695143882440275994689721479314417528417480, 45729327569890326278523663568847218262894959, 129925286147414817076637512089880305727457533, 357058960265822950281886346091988882031910760, 870811282376277097902073516532006850342152858, 2399129617319427629796691807338852665469337085, 7522497498897836117435156411281203259743818186, 17703808279261898891912155690137638994014567408, 39174398341780347981624886777838524967209728446, 71626422074785376430650030090797947505033373583, 189453667691364649027951065496599754814571374684, 437295033677960022667168340703719574179513440159, 1105022320374390979035499970036715293235993540826, 2482140894382786914874701298953446381142900730227, 7941406921570365260066022237661009338911386179194, 13688077798315662160188528865690475378175919829521, 40118424472696130315297350323559766967889857978364, 105189379969045772302352882060687514329245824860122, 199293659238948607716187263853532082285127398693261, 499536111913922039437392654679505181047127518386152, 1265716378918935998920835568757397506132677689873802, 4251975766094131691018482661130820129953060977929504, 11152957210935036994690757763894857926461579995709364, 29243034751011001056721898400833781278921232465896703, 83127804731558215656517415813913013712630964732885793, 197287313991484123623412111326147421339126168589781103, 580348074469542880297800575176456597744257638809118170, 952848219059546044449261356813174361415872857630315510, 2114745453546299027601967135831843941629758587200332803, 6732303576367127091793491258707612535996916865106486930, 17969751578033370972927234837249484835783104974373526668, 50353964851880252824761483078317672020552394668185625845, 114792749147200000567884552573247130055515068451479473326, 344881289580954366545252182642967036273037618565165401985, 1028830458186445450162354520820201527695218769577051320473, 2074905233540761021629273629118215092544205899770047449244, 6827824489946353955926387525605200460781082737913381690336, 13024891552715019198360589788142658101822141014082307429749, 25961005268769363699702206141880105110265708699262059458918, 75403822308341240881775753922079349096463802345797378834029, 237384123451169596772029918832412849807327730438354057322622, 712646240930595428776240903619042913605109976371239636231758, 1858677703618066892165605509033944664007520745899837556768895, 4139395606166311238767981220233801698454319610253778363314838, 11051661045091733320416016319660914967058929654228453865287281, 29811585925705783247773137027702029276636378622129036803066195, 90685056735716951430085719312184849024248295771954003433442472, 157500945846011120649342030924242308092488581060888955520117740, 372901626023221848769914983494185928870895559258054416488096811, 768231028240804910809905945806694160784354754863882766743917789, 2779285901235347349512412519384436770411460171816095983145397440, 6374104945628711471675855561257403169698347988699930709009388571, 15606620797895735826222569176215400049549335070727802852935792508, 36407286542538484153926148252126040596266900628856973721204544487, 124345134443495254231144676818478910782759198180390061540449975329, 247113740493284619019931820393865652802499920117478290621711932786, 546250851448819627474782890078865878619982888424175090054606739349, 1708592433038733956978819431107564666115535756847903016488985258178, 3469784692808773680977989909012383598601318450115335667599446101916, 10923256812598128494335226092601900716551326610194937277684839542369, 21012491338240214838754959441277560200420746284908398093641375760080, 60889459302270258776558311240916612146241213106331686794170240374762, 163976015330661921425351604828688078789049035481531041973974028089785, 289037863251569623683823097040957275672420698243074506420157297827331, 757077203699594125515581476518783513279367742304415416466493229482750, 2419895647396662523171144180707701121877346566438572088091207837906226, 7355085337963583789485765997525070376210546183075717620390510384848601, 15051216064674860618341980616144084279926804604562228123313569479773613, 27941489504573067317849352242679271094163397351402254909630669501407776, 101620497919142332166787423172023060084593540312322612628746436809445674, 226881723516906947900548874100926330355595061853588440070446478001634192, 436083549067326238210237926429619818583468595956103126733614121273925302, 1114300762650958326100809843235006795980444078921364112608090634574957344, 2067630703150668695099956606446000647289440828791043320265352802856027353, 6184858091099126482135322120120464262653454412363734887325664168742191917, 20198724557091875844715800016163838909724718285368458520056089111628596330, 31016012035612935043240048944310566375654982913771972602093586083253422398, 120517928868495613278649932692310155587627278645665690072538147101563551766, 189853493819940791022006359464978248211780374156959402302888328075135559122, 709261139869078187523368280811328692680117587337216655356117972203528916551, 1494450926662311226674274795483402016068321469408932952124223720040234068030, 4833201522454078687541173754025375255160393643329610440001807389162022858137, 13065426763007211443646416727098859879614516619696845038342383829309179073982, 31498041121702214861734489217437935540479379421202405303460486717862084301294, 59291071262486212405215961522173655254987660557013973769285757104149711757459, 137325620971003240316895273046089454057536316983680621619104742603734626157973, 322033994335205758184753941417891767592538862759074152575171260357782006734442, 820082783566832754339608163235147685713597507674476057203654315048011026367219, 2282651344288337092906883083740075053173109353137863831730238422975306417325757, 5445119536937019732153059574137765564679350539463171899410036275958492350218676, 15640432491440562916581632653853505713511238255286321934711250830601955403677071, 41106883032429969859399906487019322357415120653637758039703350990320596875155176, 103754830954744065029443848605781937050053754534445990149281507972325774765844876, 234666834709268927734887936099822319961738129376455664521947726208265410000264742, 796501101363737180381507228150305361162624877853273443755457607681031102231623307, 1624552917282803716066319956956102765638808948119862597393339135995911391379123522, 4643272637840339310515026952678388354699825180379372281574901801196876030063101974, 12698618143562269391895747140398377495554004174836256597996901873500325652914287227, 35723733467261031422647885542793080310475947027099953899906182407397300154268828906, 66579759042299327879621766658030061118334921216187867761491910504181344451238684350, 239558348723378720363003224968080360385965369779814655734270075126998161979921905000, 674426340811237207208953232785934391016215462902095720638324651170969997400637801355, 1698823780061918718547756106555041994312203433347013142428193591099315938666752495147, 3485698669992831956608280816819201625859973318902236645999324294867314338271763576226, 11913442231481393917536601792582866930393303587594985248503741285895455503031416467367, 23070531945625150855016941245865388154950147453856685413887739256847410892916751249842, 63062109298026246794043518591814177894498277952179449322185515920851203385563000039545, 201500456854818387020432137947274011145636992031847792130877996231861744196691929847748, 386293027342088096708767070123592359264038177654678967794307420131436089009234887958085, 962652147623483170628478119235555226505070396879489339105090935822447174750045231232478, 3035935960793431917350036879195567655285637476975406683996240225461808984868014791791433, 6208746117115824715018162711918248788514776556569667609833722045497831346028332955531410, 11762322147658744239353552479176647603950873433079903790516674882105043434830328826675415, 22679200582127225664793559521091332878355319644677462980823198911465583443269858630893253, 73929710933006149888049977928677968518055319247626886667227984506656971966999436923186972, 122524349818395517581134493004049791722607446965559017459380345881157453828660236992049404, 412926833511789222428174650284405691872834629858851326844087117202853421601692502254318141, 1029385129423499530322969843276842783066057615497035785381633948646265964471244991407283657, 2374019900827890887681448469648598056064267661046120767421848772396302513783495423644064007, 7129046282305997419886465925038724574815350866486395082327924571694995543004421437396685163, 15553684426659575255143733092646126163883808844830770798803864550707886694317293166976752540, 36868510946091898479948303208447807989049331965479662439764899809218618486185846045349542501, 92245655628350120221629636214996850938258802134676165059052497372214318974743615511153118145, 186463470334970062582820387784350511557982560369498424617823476509363037536450250866616200018, 572967521502291777355369990006837729815084981232789335148124013079835565379339449250907380488, 1481745249132912511970258586968019679134485717661841452421417313959912906838055641721186578588, 3465571259266031075485176569236690543411907657240139447438094553546637617425088900258756309108, 8435925081032968505659480326132770316717891729208893135134645312992136104713045209348571379936, 20315655322325100095226141940419414017723560946817780337100296517956534785685937181001107745352, 43069115966613244938070771746304575880400024938295357246717079316564326270692925649165248799853, 154233412749662382894550506472683312102297703424057840129476320316144010040200771168572376219849, 352877164586305833533208196782157198192758667776588081344657867110512140773408077435261431699405, 731939874265903145518316019567169287035472945759023530855697163432627661288949769619402453516834, 2189452024672949178210645600969378516255080271308334836448144354429705327344143994347331957449853, 3896543605375761834186485166037278157701213968430616464967138263870727947226180820650265115757354, 9136364061744114854751740581900554472617621867814569413142650998411332183920873701211555172374338, 31182169589957210510416755511542482029989997938097777712995732237583051643250531461221140115798313, 76737932310662322563271317876920472434982416417386459109415811734811165935978744596464401289256365, 191657687539432627521287232027340814340762593718642860136243059179657356411665753239917046107562015, 530361069831754440835688500919172905456422674539149906219439563860239029311496751350136915275150864, 1387792997020024308183922178096461451972294935906886419345639014544739179094711431002567439046777688, 2286383934503119795216122706571707851067263586234080042542833733216757155431244141022301236049602882, 5217435832596475959525740735112831333306893965389666926215938837589313774349496690036610287629333005, 13857335145208908258169891019385567845284268412333112678215001155302498425490658878264656236992134935, 40163901018471004896425196956916864061977023091787666532481831101052032374062940939516719648018676594, 82892214529323438899501402117098988403652889186148588453800977258361448264060748670322604495661134167, 178956544188555415155972101504345380390695957167910254018903325710948594375512551321503428603501757891, 563888574268395325287659273510106617675959539240732287901035847602904779682730930207201257182213858543, 1616044303623257921514683914498983737627603891472634935907943748930280908786049272784565904600012939098, 2891229181345915888829785513242002484495784340354174828728993457272687483459059048534538302181816688976, 10207730272860940549823879515425309207636840459300447491903147067853625202918689426829904372421061677895, 17526621515916394607402562632381069779604072768221581075247386337947979364802058499395942689207299830365, 55864742839796343168209200305202648507682753148596246337408494037308856790224259497580631081634646188041, 165332196033938201434627346583990806851682965862702414330472648748014088812475559273855488926778988149883, 494729626554411141427744566730794748483202977845760867859438479405205853778032755546761473203576297889449, 773241724058457908926664671814549280391747757602041708672622636112281590651589333985868232639345426359863, 2643090721830219937871980242863893762864524580138013585975903383984399727700467749841537295988160882592554, 7602742125929529736410459828760559621377824926000865839917497433361558637433229365703421216832254559844712, 20298012813427893859751095024917906619591438637592000480476880613738608994530228331797315397345124353458048, 57138113294488937158388285440237932686091901290656714986248760196665994518443306993120321953623611701468826, 156180826248086652580528603931836069088833849466705801833826561589537926864487694377480227882717998855358198, 405091254840842081029125739284610173825182926000756067214428354197290398676973286834323853061720032954965963, 778366116109730017138034746329928058267161795656720444904686750506814152375884477590166274857108289313593118, 1796005150394618766778725965351985496132876507371048438760920669904977557456986675227521156526604287512648264, 3898444018773054695814825596014017751795964177961572987153324103751602074848254485225397417397654262390321944, 10703462078231223004197739814155717950000211259146027443753796966491790618726938276000128782966812980398530204, 18372321975824831177753464245580317968933119357879255869022769977852558056854497414886761863892673585456643891, 48317491803925955550053615386786484989034506042840366819980397407568791721238179125455458641299301269848666510, 158255568588301663954187011445643163738485858122034088577201324726783893231449209827193255340005164973552974453, 456823552578369748946561710072366945172148623875999657195033140013027572670231347304984109456384691884394301596, 707160118481884894551388234729179730915972581073118662214623842056893684770640844231508665861861467073743805665, 2706927376520605764276007802932993151885010075033345167172586198244735154579188535970342536626727165782495180134, 5524495123704893916572931697399108221354633312984253879509446961783982258828184219735409076305664075360213376822, 11902801828947547843316856179728603283371324186706149334180029898787026360919748804787239985463725865632928552507, 42817758358028425898228144386760814695029076486689089958556088081002352872886441780712721026897632438300836110665, 85341298053933033277929612803230545434450389443924565926372394273668666803233325131592974981823970679666528469082, 203545487666526735282497187348232067937848828434866343193810463204944901878674073018178572958556722616056919932826, 404490991972927610287798222030298357859147323959244483279529298622268125169109324278915340735214314234862449055448, 1015889532249910731454157235904076803563143859066636167138222193683905683535906365566683356226160720652109370999321, 2376026683785110886914732723263521678018967831673326233555377196140833492114241003132626058539164015299593970425136, 6462912523501528306439979574464826777892245783057732634021629306276087967421373795532316029843905278328516884883058, 16981441701453104471733297233747957918575727289870879189918428405182537334140409929337675754279869961515500536636176, 37605582989982272328044312175947277729400907856460324692248887357599456103017970584086153023793040540391945445989257, 91747039052675678105959960961981861389020215173307703983752122608163760292472703277085998681706298344337891404847646, 197976695213061406953734629818998754281337862490966315225432914015679415715157795368611025598068494075696354180224057, 407579734020903728451591407903624856111929215373480871243621182164970838186438777218257932637652562832905518769398262, 1192695842629740666007709455549699909835266353292608841275812622248241416280954865990629770667881078271433918923422731, 2356450454926316659685731978750584215969826513728852376452662114206102092287531644004469937748823746129670826796883901, 6606194810680818911726753398369719656427756109429906495763748359459974583720214056977960616895121295259675484772228900, 21238856384108665139068993634246013308212000660518883089302921531246892139968871926076965355331061987385136533519279525, 60431698017667972588320134967121949330864812114211557015977441929363675768812209839204671181454067749535515855713156763, 174665868422753780275604141699079697885219220210916384980421958910804651659162534153721798589901082858559767609552079345, 394230935137659132182806278870718863867754651145064639278806591391259891710009233085853984826856234290081395609225890238, 938316178783979725028510016300351906317832877618969965871296642973988528249289624189564279188734089982984293864940639663, 1690300816950917856165481180579373059665398098127346945618427499442023814975741786872721941536175836912500050716899314350, 4241040212750921734662543578806315663721700243000974307468609317605794291246764526126048318503818177838783905309400289117, 9899615703109749398438558898664002269482804539466079984631091253252047080143600618559486614511675282173378128689947106499, 19072918764217687057379877185516040357999863490449836492311841376572022870447983721729056895047026984202403660270528351362, 61457030295636043956746238914591148777316757448303861396901131680368800892725607851722251866187547310356464672462006792936, 130554685050076234706409249768453974245979757597714789262984612467812333642313018653001831006709360179701213479970689476759, 317707441009141362433020809851971219097475768762476580041791647909345575364794752462683617015215387354639266789655705355159, 766407353781281024676870262720057676902122989643223864583232810528888853102644816087185770633710024110065414129660560848818, 1378158372668635043591303404733183053913783647791091758022520799715774445178343987469574552089574912051263356050601448829569, 2849814783153826557775488037652012659704609417837692209372285071574038848736100379264094051217084360358380745456795092662367, 7761768442678261726960193678894950205212069061687767898603990098871593859918952089239031086652597614705182760193814143657094, 25797856998139398890116390239859835084629679432044893266362900315705828350899796936954893678013444560821963770721738841492762, 45230528787260219469707111504991583088449246785732739036848497764369166856369435663350796527642874763730890628636593210838634, 125595007654406839330037705158661517651788635482067500225344073216015649944944879970130124750959631685921435054581613709164822, 338747508849935686599681561847193572302329804892368313208731993174039023400358858978202514407262943107662339259004212857955666, 927842701337787263386928773903441275979399427379662460065544246411463087320044839262987027337743305220579800532826965270689250, 1974283905173053393614664395812743602970084360210384412934832566684934360366297764438728189449912704403685566054487439810857627, 6547791381850377804871914819409383329722364771877581519586671693693630274474320389311984387956647850854999536112540018330183809, 15709320907036538202306551117984227990557852089499582468594623629463507925701405510011304643762744267804282547349971254508845938, 40270138688478461945314017148044972001708543125646521974155404640273555509873235113536988809551924038925428913961013964565197607, 99168179703900580858922903603323807687115252977021819828415602208147447841271397891925410158445036111494543958823713690209285369, 269868178430265744761277563499719925184037917272176039027995896214226177897366881562687640385414521231482816048831046030643750903, 831659192392583336646613887566957000280656975320208034953861277421104038936580189145699653541798336705409469145595542460062434471, 2073476643694212471632333653958562004434818366225131771845046659755589302151344899589183197864077374128293181680576229954100550419, 4554149306780266313933686119966338774145476827044906188542821462680791576860383095025724314895890630857897398967476576259995321191, 14651118307465336327922062019691151414683570292038775511915021602908118951591926995520466221396947959539039452124967851254379010308, 32590352694473324794187157416677986187287003972605121693147144070229453983956761041980924463747749024664597601177994952136065984811, 81134631049823241301269776481475653931802229294857541846620286653857647735078830230944498091871440739749676625155855958593920070814, 185677119342066492911752180414903294080590111905381979357926969960006994207482364686831869137669282514024709390338951171955152686319, 611640161419871188028819133410469586343996954403636969815202842657504592966769167857498786484339404586484056783483882604337795700345, 1665805557476802274778809527131744615949426833045219219448282924298718975882034660815478936907356513550130652021165488275923832785881]</span><br><span class="line">c = 2396891354790728703114360139080949406724802115971958909288237002299944566663978116795388053104330363637753770349706301118152757502162</span><br><span class="line"></span><br><span class="line">m = &#x27;&#x27;</span><br><span class="line">for i in reversed(key):</span><br><span class="line">    if c &gt; i:</span><br><span class="line">        m += &#x27;1&#x27;</span><br><span class="line">        c -= i</span><br><span class="line">    else:</span><br><span class="line">        m += &#x27;0&#x27;</span><br><span class="line">        c -= 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = long_to_bytes(int(m,2))</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>

<p>笔者对这道题进行稍微修改发现，有的序列(数据比较多，可能会导致序列中的数据有一些奇妙的关系)经过LLL算法规划后得到的数据有0，1以外的数据。</p>
<h2 id="MoeCTF2022——knapsack"><a href="#MoeCTF2022——knapsack" class="headerlink" title="MoeCTF2022——knapsack"></a>MoeCTF2022——knapsack</h2><p>题目</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long,long_to_bytes,GCD,inverse</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bitlength</span>(<span class="params">n</span>):<span class="comment">#判断消息长度</span></span><br><span class="line">	length=<span class="built_in">len</span>(<span class="built_in">bin</span>(bytes_to_long(n))[<span class="number">2</span>:])</span><br><span class="line">	<span class="keyword">return</span> length</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">makeKey</span>(<span class="params">n</span>):<span class="comment">#生成超递增序列，得到私钥、公钥</span></span><br><span class="line">	length=<span class="built_in">len</span>(n)</span><br><span class="line">	privKey = [randint(<span class="number">1</span>, <span class="number">65536</span>**length)]</span><br><span class="line">	<span class="built_in">sum</span> = privKey[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">		privKey.append(randint(<span class="built_in">sum</span>*<span class="number">255</span> + <span class="number">1</span>, <span class="number">65536</span>**(length + i)))</span><br><span class="line">		<span class="built_in">sum</span> += privKey[i]</span><br><span class="line">	q = <span class="number">255</span>*randint(privKey[length-<span class="number">1</span>] + <span class="number">1</span>, <span class="number">2</span>*privKey[length-<span class="number">1</span>])</span><br><span class="line">	r = randint(<span class="number">1</span>, q)</span><br><span class="line">	<span class="keyword">while</span> GCD(r, q) != <span class="number">1</span>:</span><br><span class="line">		r = randint(<span class="number">1</span>, q)</span><br><span class="line">	pubKey = [ r*w % q <span class="keyword">for</span> w <span class="keyword">in</span> privKey ]<span class="comment">#将超递增序列变为非超递增序列，作为公钥</span></span><br><span class="line">	<span class="keyword">return</span> privKey, q, r, pubKey</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">msg, pubKey</span>):<span class="comment">#用公钥加密消息</span></span><br><span class="line">	cipher = <span class="number">0</span></span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> bit <span class="keyword">in</span> msg:</span><br><span class="line">		cipher += bit*pubKey[i]</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> cipher</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">cipher, privKey, q, r</span>):<span class="comment">#用私钥求得超递增序列并解密</span></span><br><span class="line">	d = inverse(r, q)</span><br><span class="line">	msg = cipher*d % q</span><br><span class="line">	res = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">	n = <span class="built_in">len</span>(privKey)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">		temp=<span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> msg &gt;= privKey[i]:</span><br><span class="line">			<span class="keyword">while</span> msg &gt;= privKey[i]:</span><br><span class="line">				temp=temp+<span class="number">1</span></span><br><span class="line">				msg -= privKey[i]</span><br><span class="line">			res =  <span class="built_in">bytes</span>([temp]) + res</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			res =  <span class="built_in">bytes</span>([<span class="number">0</span>]) + res </span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">privKey, q, r, pubKey=makeKey(flag)</span><br><span class="line">cipher=encrypt(flag,pubKey)</span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&quot;pubKey.txt&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="built_in">str</span>(pubKey))</span><br><span class="line">f.close()</span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&quot;cipher.txt&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="built_in">str</span>(cipher))</span><br><span class="line">f.close()</span><br><span class="line"><span class="built_in">print</span>(decrypt(encrypt(flag,pubKey),privKey,q,r))</span><br><span class="line"><span class="keyword">assert</span> decrypt(encrypt(flag,pubKey),privKey,q,r)==flag</span><br></pre></td></tr></table></figure>

<p>题目已经很贴心给了注释</p>
<p>exp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">M = [8639902583677674310880931793028177280541434011292290504202065853840987502967193292082744312615700434593144813157877283996511132107220470301049233647133408049028266415548603044821875100911736779016733764651538561081471760073024901013269329030282540268057926893298880605006783804814169640893918174416684396473085843437738560093104518378524427428449369031845530695254533729875357632791209728472396631069254545688073527219830, 16412795671399200780410369416718200126247920664621109172347415680005387903489020995450209711828570735415943889363228088231729204296365628434015660102046415392160980472272559259705186844881452797719608700810640858964540124307963570631307965212179112567625375169247224532541645290209536697657292517320097861498807160219866672156203488965096062697707956833540149569006121676793811420684019155246005879602727894940460106460425, 1002483078449652086908127901165742700721575695431977944228135611564705696962544084765706920800603400348407970043674673111909948831677555786509139726134228930151292393556003965787320346201469741608940033259208434513230462286500445047749412928990508135782414968218031136356601029216877376563453734566125800306022631214791796995657970239075130824719419551039046131552320134110768030600558391775291997167887552475043961982479, 2238951719129102684908508004589371017508128103247447515477314623396874326632900138922634752384371309915247686376088188378411136513128697780426310438781294619639028237392912133929126286576611773410531662546965371159839695457500259703379712133530424987700108668317058486891872074268472615506849525949557819649248663298510166491366824248526632970988729421252090737838283604158996925358054184183912031175441649168801364477497, 5634843816732445026126467098373466021485769627903521660842347695720253281030482413552009914416263510962518645905534351024856098851613741584157560289954680322367708989388356896291579138242423737071936969416183795417059233168737593374557100712180960324956368186029307481493787661489262846069411165605826200576757012590288649575515313112890878467873797655979953750167348022896037285417957167761342222784479775154484055454300, 9186610770346409723100374171388664935178707704940676612563986340255427150913228007547473624373722376412452006509593871272640178049654772086095028603022475485769195013987324300619058730137213629241547292874688026607272301254060765768412491266856867815505612614998943264567979641302858974943094758843838673682824294909500855339786155131092900834359374160001259207411314769180927212657053081774058447428598226306560920557103, 20086923313584400496691602764043099251746628122644779399842432220366854165950153096939613947370676658491693142658541069764999486380151371297168776865169982649753241182524436613459151210953276528861607793419032177588079933942873702274888793149133043040881921816738144320494857431431348403935934220691400258374550028362585563810770890511960106477474196749665991783492371663595335417853709562030925255330540927197410589197346, 16344638306391326377686133680466529244247158645077173788183670515669569922257628136592428719458630174158247262608062501473710159252996556402841773688479781261071952868217032789112171578864311013133034166125522508960509753908661140291243310989744814838516658654858087285501428760026897645388510723360904014743591560741892432193065079183777716928931428528657537811530112798506687040813493577134938597056885544404165334440417, 2612829152363810360381140114448267548309487113451765642875771138774557011657898432249330366979748000196797448616557121603054240633550483300886876115997009072175661113374511516053173148943538562172144361976376460500609759755722891157667525246977951372954709581129289399522608993482768996162810200357621658110354562179066558050350148834136898974813148680250028733112017355078329753267780915289394014243208598474729032384564, 19064240755529577125292283074595989361230925740751604828791433834485710855856801533155956923513647433086102471927289219051556692578080054437968339223710189223092053257138547582773966036253443266822181812437558595870339679800887565183836282812813501470568462858382546100456455622835475204306486289729917538078517665215080886364990781487301918217104266484901312499340347150623781762028474648151175735340611348792151618766861, 3702565937757268048976391733125277066442618380743768416638899741455818391864276934809663789147326816784849214974228391513975011092043466189181524135072744668991818700123641118048186561731463987428008289526424894229838318750539451785156527758792285754054388512341416769819020768917817009268720412709209493639300206208469077070001276757631341988430056132551557700579907926834862070107929804804811568088452140366936341777345, 11502581665457615587254363930374727534860957412318365767186339391962456747857398825121846821211261108113447361990519412493867120624842707484788658261017505214188933491782380457717248447441244784000616729072274616859314952832500266181433915883265604874701734571473682998617103861022495595430816700108408197717973513190148901952092370293707843130828467727037293783684148539875615050978469354573967054299566840777623355696582, 10073083484226771776559359501269382896512475376861352563707048944846887937508361476948371289888897049589767849211355238137412974054578287303103882003280146530845186837491695691790335230428734898979480016209102240902149523701595231852831084035640546876424433409207622149923419358639246084622889479686948602188084403074936426671633324202401473825907348902812619313043234644293320117923314933945154795101196969895143521199483, 18992409093137046378732842744306503603860785524225852139724096390190053840935906726926035874997131679911084133508187235324077341016070148447808448470772128318056137717495126904574038547394615807743718419710808943840981025768473805273816544440631835254252102209159686821504850348775772310988837820388009691813555637320221225893184839014117064201469792554472415820296766165441072313200265279873167507641917097468147741179316, 12008203894395308866804419286918131211163695386800382803649167279012655799569753801988115828424417187344919188165247175430808022391086771474851545255339167112615263516693822036949280138705995693945006477452686019283850377188419366812168825267599287239756656176060444742334708935226087327402356564944368424241454091730626764098428899236088185072241508877992009374541429500266147060644167717198271648252572069852366770066941, 4038832885441543178685778998777010366178385846540652554740976864087276470059402915973964964623701441198410064422128360212066090056314261540125817743157487504771683739028804039509503547125770628097134761153720275162291365442343531369529592717402946253265532741567152583164953954964898610320442871432658088455178094417777512351495473972183676615716829056159421852585171139955117355872271110823592402383029525931751267792629, 19670194103573995335546778884365243181264524353822662897934014963532181109426494031783122562547168306646340318701174006591358124967291240381472860805618047808677531825042365670594937665873102378022268329092094697067984029740301822623602184731823873558795434660094128877563657141012814479754588351209580370149201870079338556937517586419874603443731575388938047952534772975732556105736933783615623583780757885995121940503338, 448587250547880364312998824100142781832002491807797554233277109625321555526950425023215743109760909527612986436313497543133603769113094218925472945334223939771684911674114594383329812680099071618542069490401164113149299269806494788678936049434267166672312670105320059285800764845917405038243022972683567686862055442132133699091060023879225704166728623235301057086116134392930454897470872517830183804157659700625445889830, 10930161231241723347656392354185186093279947414736961273749133046917264525983266922573827501912949183911557744485967859327719400057117437345731516339396700486673896394578991271601789139805337761538463364911028532947314087595485794633342964066494181066852782300122468958298766435768883484054954993425768743684068334128908076033268101822190508581559994522635605495674677985961570352022867982948658497701704571958572471959037, 8912625957861947176692856854564685913647250060559881612290601882706188054788510505473405766899729572895845562443591906130010557402952386484482517393552180643811875543260186615419673392566496124447912269542460226666482647910551668827648093182498966897648613164572222270243359702963101177490336287533554365928047224202986800381789195759761436787301775857956490336462761874360038594427862527456596260884381704781454223633779, 2306551289216069191130454513919221829895901755421732012054334929893242554080663470365833623647910595823559794161380381203244457273338204281828065815403836409342993408047475650247775548054870518506855112285782988053629107469383261669351486184529190835182475578503456288807168306057143062378581633799682759776120760924076418979302287358897599267369532373529226015751378954828919709070562305354324298101375251784620884529050, 4255339440978927655211913099708439239541744749715858205450532296135993491711072531673546488130525220452788120740747243665720666392815530093014478271039742032112194171931906319993753445172382189426854066713529003995100528854075591430543823563496149091625019122021620407298536429119275536878732816760877148779834810333996516623906435500182034146675214175983106767418866525349482073016790959017939121229158782423051437153215, 9873893139520117327959006627839041532640596084122498183275311439807583416537326867898240112497398037831103133225780536794667751621338906594306093907094491162973280124466357134326208711961138712559043474881854410281347249860558412201637927695809309506382983697195652836773807770471078146063769391274295604089026631661057995193996447578694999955394342030970191038699379802329038272700169720344712485611198818958034826301237, 4765089917604817672113377465925141955529222421516223531063923657154702433478270434880545390917216534893263025759911541042026110573924335888049100333952299835341171480017258706209901577677469866704411013270064823075970967687971507570610839591584275076452847872481076324238205066797040752210320592563122318631044755701635637739646416025765614160810641418286841779812770371444583299208365194975180768006212895673072116522386, 6112224947687945480280239711320637787918908433138683424770734756570826229243307796646495301320885785370269249822669591195293264920047304899609677414526321546201923169183273630074677571673196655278790073365810828842079110549121344560176457524241399552011885247148188807289668163473493287160336470378903648449586092642655607573691920693404111756416187219108551575656506522734845257486376035264495521946081148938719828033544, 195388411930456292659004793034783822168552894119815825793239515251988057168890947473241809393054966668062312553975721264016843250888334146134794233076452609281861146295329070151936139818953601652277333969475084082043879066015009690415217938561659533862830515140741722462773302261048996453107340978194386484615281173964478851257661832707168812221430391245333553374969697275213417090199524308016415986232808953337791233555, 1244720792234771369080092658020249943250558558858543228087410218998345534662117779763183654722069027909843499722901164419943926229796467885376166352837320116084647482129514330031374427777713274658505472735592998618829380710477875259621314494025610959270630909513767438377166574595122721020642680480636508393782145457915510494406492704624711370382819548311152206515088909451187140041316879980487624305109667331613444702397, 17420521136158610155456592286731848541982479314642855401677490675166753515234198487007423812022874870146225072931804869494964153944097179858754058711975536064958198128181259089930184414024073207404745484941865020376185583612084575830698697473861393413223317543665696780708006419160734997175211056844409117770896148029948413413830070992404759100435183372428243532877202421584255843340950511372816896926816072148853459897597, 706903708472011058848699822306335654841601117402541259992980291382595513869156934281756720925440180372041334909766487263157124536984532709278378467802794655209393786719712770166975275570907988257884089016583036566222245762906544594817287350363157701978129672388011595734906479201562800232080436561292648589995413689187423799267922779667354879432847963481081819133273312642100271608294867632390722051556035070483171016618, 13588117928036525396131036929216722140727623626773457297456804642287761920269285941755714752389926502053635244735082938908723844163590227890370507021161665584070634134943166185409041414310104540858882424783436357851264149321701932666540464732095496709151056094385506784810633450577104530541976191745761226361392054647950122452702677055536328206478865891505902190711023934956429659436170984452323755148142827783946983689170, 13035612161448099569620637080527976769991099967659035134135726157510271293484224205316460392491491142810512547489719500384339641597134042306613279002050232752593558311676343579221779534892019944116141753798217189420843176613961166129335180457416469246554334190776482345258322812060613256769751208473952032112714346919765236132411088975889482598477817665407310561133545838921580753339246754910148949146829091161220277523800, 5061468190653798738267114315103277995240484866758940466674688031109170357205008555147400605884432466490013550324043153140916286904706720594942806466313925952519739861008671389738724448491617803723488014434597761423015360791986220671348427679576702646137192962379221866734759953356438405870464423279037434471697115717040170596343588013833231257338815360451128669119488799203334539631159855944659628348586189260831916846349, 310519211081224360436038529767369886079208063233638857045321280938913013264485831500988519083286823510448024911412774486006384354093058665586412478745091555621093880910291350060806527846380258780481452221805321697545098807534406639559969270790330318763674434212070131506363658570473180232691446781542261978745471405470147422634838558227017494138965139937056188221867200916092073501864711946128579149564779783995131812764, 7765454929386860718098457667571027065776365809087712130247806423210057380994819419379356255913567513855445325193098721224960552359712259673134202556374845746328084939006183410638772980553376342740123581295433206004604779839814416843588103144731533226288767681739309033321761816241055963854560413354103299523850186399263379947122808750960631330918177463573091711382789330104148605172305241880223088742424771925359262276961, 21279920209240501229319113350331584665790430778846094897524930483118106031814634260802903045495829850399437278182329574699963138929930179421992737117248479197193414157068700951767757037252093980620859984584071460503299890187279597588828028508209377280155232780973353085622102108867131114851476798667397114731024315266211677829660093151838411660005343321511262290101904600206044359113839043382769572874124915349587253828026, 9404384361847700092017917497360922914422495675694955197107944898045656929107075851201447292136561925215747086463268855004949841022671138446351748131867439799577663701934862965438385718226937668810306608404586652755516424859810792109427278538957262669803852485387086606698225561320268174451728686271748237597096162506211489602963953896833644360026423773017344347726848234574166701592970696201428964781400031197865618239089, 11473536515781570615295467590180776005414036990843757506218537332857260548916287699656257748679485492923976380438772031340714031903195664536413478729735501964060575660816573010818951724268030300190364858009842520160469005602716000106343559079229134105037981332746560515786853914884397058119553354501751785487490141582378799261378484951808914485153056302334467726453053631816737123137188339174736559611576619507335456442065, 6658209986765214576523603095408925684859819107411400320441704339845709232148546095393111386992961430272770760133826876144536472235021040569911199220002850001682157274254019940107808579210365324279421587725318046615758025182034807320964209281952211101801085038313213267840401921768361130482812244634047647201542664623820862660431801687169272410840936474148169852200351846151154823648248871251508145387214557197530965990966, 3662147743842078783350403504385983360536988791880409841594842856902008843747184249906408091065206792255852486983899949749040441757153766073770174862371596437255143770762330535544930819336506298143363720373654482508230603611719528450050592020391695607369389318359724713540160798965029351305356511671756157832414716675860595439627182073770194023818550160188620097391401855031574633727321506854349395990238905940067612856696, 7933293379259371913947753225829182973440327166821331624782742813667530306183685142511569661517697089303221887502895505020874247160719683710997562072608556098407772048528722269678632972762531765385931704290441640393166153819226767175593692496736619644331844236704817294952000150386014066539732697524646127418982668700056812006011572693231332529972933598812433064570022253850176804351568177341485541235602653505364414768080, 14070615118184600860551882213714094275919094443487489248696755809883503918195587018270172984608205938888536939875430264012942369576596527716679396096608215568698430682346516654899828724942187624877959402757540416078645260766852866647428645421972345262477895972147694258806702534022844164408377042363711608742060536759496086945857809612633396792905136739597255654549008843569173238058444402641970915726989105904551420858546, 15342946815132442226042116907050674991277073193801523392169239948932666433020608630679091801966034372511342999029292508497887755004306581018004584285609282795773152090001950867971092852778256889890353738132730167551173577706777310439847369540286505119147781133148801979251138693701919045904692041106260141920375686688488149802396671219316061485675475896415179620183729993314843987100325425615893137781286754296462178178342, 3740152297282187181815345820098735405456007044475540504111210108524926232502982744404912884880365972432141621724673777802787744807157725980349110691844313336431011685019041193074796249612246618677944456394104745372829079160559888495080142311688681340347875401650358392693131033779246448214818537452437421066622719432500713770985665015229700477055550680052280279789072242114276313112192777540668840785267601183144210396020, 10185332676507104923693600244914563536350322909616212746220121432434723035761182080872998830142207437310309114085510373952850103117757585120341980926754941337344093553857422551961676140723291586487782410700709958292644147040988012341985875728853255609738370894663167840784046951024718142033286281019071858182773531406479425092563184020268791578909132566309388794626911391615731256258486251046314500831039355225743436984975]</span><br><span class="line">S = 28856686525748125802152914172483571798453880654624111179873716369801238646447969551927508246737816822527579725991046201801262381722186539084044859241033407568422008911415092147086235301286167536726137372507078079415577358704181165698320539751269992479349480281465975374187246799267369957964807679383646749609694064517591097971225234359495013928292239934008888234863117359059334395043146949808360202225171337210959511092044766</span><br><span class="line"></span><br><span class="line">n = len(M)</span><br><span class="line">Ge = Matrix.identity(n)</span><br><span class="line">last_row = [0 for x in range(n)]</span><br><span class="line">Ge_last_row = Matrix(ZZ, 1, len(last_row), last_row)</span><br><span class="line"></span><br><span class="line">last_col = M[:]</span><br><span class="line">last_col.append(S)</span><br><span class="line">Ge_last_col = Matrix(ZZ, len(last_col), 1, last_col)</span><br><span class="line"></span><br><span class="line">Ge = Ge.stack(Ge_last_row)</span><br><span class="line">Ge = Ge.augment(Ge_last_col)</span><br><span class="line"></span><br><span class="line">X = Ge.LLL()[0]</span><br><span class="line">print(X)</span><br><span class="line">ans = []</span><br><span class="line">for i in X:</span><br><span class="line">    ans.append(abs(i))</span><br><span class="line">    </span><br><span class="line">print(bytes(ans))</span><br></pre></td></tr></table></figure>

<p>很典型的用LLL算法通杀背包密码</p>
<h2 id="MoeCTF2021——BBBBBBBackpack"><a href="#MoeCTF2021——BBBBBBBackpack" class="headerlink" title="MoeCTF2021——BBBBBBBackpack"></a>MoeCTF2021——BBBBBBBackpack</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import*</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">flag = xxxxx</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">backpack = [1]</span><br><span class="line">for i in range(160):</span><br><span class="line">    backpack = backpack + [random.randrange(backpack[-1]*2,backpack[-1]*4)]</span><br><span class="line">print(backpack)</span><br><span class="line"></span><br><span class="line">backpack = backpack[::-1]</span><br><span class="line">l_list = []</span><br><span class="line">for i in backpack:</span><br><span class="line">    l_list.append(m//i)</span><br><span class="line">    m = m % i </span><br><span class="line">print(l_list)</span><br><span class="line">print(m)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">[0, 0, 0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 0, 2, 1, 0, 1, 2, 1, 1, 1, 2, 0, 0, 2, 2, 2, 1, 2, 2, 1, 1, 1, 2, 2, 2, 0, 0, 2, 1, 0, 0, 1, 0, 1, 1, 1, 0, 2, 1, 3, 0, 2, 2, 0, 0, 2, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 2, 0, 0, 1, 0, 1, 3, 0, 2, 0, 0, 1, 1, 3, 1, 2, 2, 1, 0, 0, 0, 2, 1, 1, 0, 0, 0, 1, 0, 1, 2, 1, 0, 1, 2, 0, 1, 3, 1, 0, 2, 2, 0, 1, 0, 1, 2, 1, 2, 3, 1, 0, 2, 1, 1, 2, 1, 2, 1, 0, 2, 0, 2, 2, 2, 1, 2, 1, 1, 1, 2, 3, 0, 1, 1, 2, 0, 1, 0, 0, 2, 2, 3, 2, 1, 2, 1, 1, 1, 3, 1, 0]</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>已知$L_i &#x3D; \frac{m}{s_i}$，$m’ &#x3D; m \mod s_i$</p>
<p>我们可以从中推断，当$L_i&#x3D;0$时，$m$是不变的，当$L_i &#x3D; 1,2,3$时，$m’ \equiv m \mod s_i \longrightarrow m’ &#x3D; m - x×s_i$</p>
<p>而且最后$\frac{m}{1} &#x3D; 0$，说明最后$m&#x3D;0$</p>
<p>把$s_i$和$L_i$相乘求和就能得到$m$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">s = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">23</span>, <span class="number">81</span>, <span class="number">199</span>, <span class="number">670</span>, <span class="number">1844</span>, <span class="number">5535</span>, <span class="number">19547</span>, <span class="number">75437</span>, <span class="number">259056</span>, <span class="number">974664</span>, <span class="number">2399609</span>, <span class="number">7304021</span>, <span class="number">18537736</span>, <span class="number">38733276</span>, <span class="number">143785607</span>, <span class="number">300890806</span>, <span class="number">778420517</span>, <span class="number">3112554961</span>, <span class="number">9955080778</span>, <span class="number">34625138877</span>, <span class="number">103531993246</span>, <span class="number">294207209833</span>, <span class="number">632363887456</span>, <span class="number">2341888528510</span>, <span class="number">8736224869982</span>, <span class="number">33727228149167</span>, <span class="number">113026240109398</span>, <span class="number">334534210335245</span>, <span class="number">754812282783351</span>, <span class="number">2871232541211362</span>, <span class="number">7147990367228081</span>, <span class="number">16813142520913249</span>, <span class="number">62232346665698392</span>, <span class="number">132813746566508109</span>, <span class="number">436969187287191174</span>, <span class="number">1371311321857557068</span>, <span class="number">3465499917202578303</span>, <span class="number">10761115866584374884</span>, <span class="number">25998484366411649657</span>, <span class="number">81986464388691181616</span>, <span class="number">324842980726420787162</span>, <span class="number">1063428202306999892763</span>, <span class="number">3318046410585817603032</span>, <span class="number">12569059003729082352479</span>, <span class="number">29822650425811094387624</span>, <span class="number">89829868596281155601134</span>, <span class="number">207467076929560545986692</span>, <span class="number">424101883375592006882573</span>, <span class="number">1410057940679583010646572</span>, <span class="number">4795250448769489602371933</span>, <span class="number">12419955465903295439689190</span>, <span class="number">32127052925660652338148413</span>, <span class="number">121768246803017981541739592</span>, <span class="number">286293639144639999224246905</span>, <span class="number">876618562849333372078886060</span>, <span class="number">3495370549956845610130431964</span>, <span class="number">13777448384830441398471073019</span>, <span class="number">45339968634224370226443992856</span>, <span class="number">159636974047457043534720001443</span>, <span class="number">403806399587759901542286515690</span>, <span class="number">1190949464093267805434271517577</span>, <span class="number">2625636206558220580206955200643</span>, <span class="number">5447410189447132699195152662348</span>, <span class="number">13798370097217657917056458399390</span>, <span class="number">42652195271813913821236091812630</span>, <span class="number">87624112365004035907264763291796</span>, <span class="number">295833079631922620770335225824586</span>, <span class="number">717255284196409248439771704866883</span>, <span class="number">2119024457898120787521595829459142</span>, <span class="number">8097762744600097674390735606807128</span>, <span class="number">22990496332708170421088808438995636</span>, <span class="number">55268619563994680834441597248247582</span>, <span class="number">157779112538179073738464223501777499</span>, <span class="number">553561084981889545670380643023607621</span>, <span class="number">2094594867042850711386606235023415160</span>, <span class="number">7427564397983932982484534762285032864</span>, <span class="number">28541899514275079822011638819911534081</span>, <span class="number">59854615377110931361953157015440306520</span>, <span class="number">137071568336121640486639449884477676903</span>, <span class="number">434368553369190183317274206512577489165</span>, <span class="number">1607515956833802196435755021284640023303</span>, <span class="number">4247439813046769661567823675143526066989</span>, <span class="number">12252982336388472725165513300377051313644</span>, <span class="number">43586970358791422986656986286232849952290</span>, <span class="number">94754002216262928157061686798919700234151</span>, <span class="number">205403633516427560050027271636224615375855</span>, <span class="number">727922215919878343821825296552148942903123</span>, <span class="number">1541646353685774868780093433673052445519807</span>, <span class="number">5703469721749658936787093922654529457118594</span>, <span class="number">20762100689139896330208273986505541316962105</span>, <span class="number">80195197197818086812949239946286778357513961</span>, <span class="number">198522126001869063688321920177617046841212852</span>, <span class="number">719060816608760633741229682178956301630549900</span>, <span class="number">2171712751463320729665634385979825928332317622</span>, <span class="number">7968526190188064156742281507099763347000210904</span>, <span class="number">20302513556821857703528100337806260797703562338</span>, <span class="number">54967103106163860243927426134510653397499429384</span>, <span class="number">189866376897538250029834405810321956080892995934</span>, <span class="number">516088075785491414669664215795496674103100750375</span>, <span class="number">1531616665488077085604100033058238685259376456655</span>, <span class="number">4795563798371064843556375420641263389159268373753</span>, <span class="number">12715206263244537077480789152826620386135239585589</span>, <span class="number">45628223673569886022145657218662773486560769778049</span>, <span class="number">127988774487590162169660910342623736153210927472871</span>, <span class="number">429761810968391607465089641939438991272623610573254</span>, <span class="number">1694286408402338132220805654166083638884822137745848</span>, <span class="number">5577419986858786911316434594350519553014729018524982</span>, <span class="number">22146179230778265190752372551893625479326089828877879</span>, <span class="number">78983119075073724439850825731329386811892547014513513</span>, <span class="number">165805826557531832743325076551678254671357810872202277</span>, <span class="number">525687524776397669648788242907896052104054917192402349</span>, <span class="number">1596680185629512867035574394423929715498386636216930988</span>, <span class="number">3808351509446054183279144714875260973968494634290203802</span>, <span class="number">10792542598439044383994436390450612942036864538927761344</span>, <span class="number">31776077718298264756461043701077481610506447838959767949</span>, <span class="number">69483787236434708634666641366101673156349500969799745632</span>, <span class="number">212620878051727200345257734337176214877612639791408110401</span>, <span class="number">565705372069455623425268706185184158331866127768259060570</span>, <span class="number">2228971348185635371906791535156337404926063871528397270892</span>, <span class="number">4859328204121938264839760465087547752629065763656619388434</span>, <span class="number">14185348803209161448182653444177464165713091554806223414499</span>, <span class="number">44242932119616103779840255273986809836494122475150635493273</span>, <span class="number">156176016196847319874949580221731690886061627436916661422852</span>, <span class="number">472567672907289753186461661432798790751774534772655287936877</span>, <span class="number">1765317440470718113352833182911767208733594355879647245836603</span>, <span class="number">5835719030771522391675663002032404790451900100534570526468736</span>, <span class="number">14528961633147270325279483890277955669830128461595478399405580</span>, <span class="number">53503137764341373520101774208921450303897226002280491351371881</span>, <span class="number">153340302591307960181257267214621247064964249027062324798966650</span>, <span class="number">467036429085212303265974827129085622046910166509299763268535756</span>, <span class="number">1760478013800716951650816419888923889893355872867499404847043361</span>, <span class="number">4791886951911545137378952129838133145784256723738609871941913863</span>, <span class="number">19126760116038883506408830737976498053029475253123685318001466609</span>, <span class="number">51635927378821965754946959553487670084314385367430813170544188707</span>, <span class="number">203944552994591250724882161307279862158139878326498083669171922709</span>, <span class="number">718868928147325949276701359623063723395455731358210896767864810436</span>, <span class="number">2005627527854915017699090052821431775394584514441537184407714355949</span>, <span class="number">6108484926321410509000933490330125849664844216966621898372849074206</span>, <span class="number">15273733259375332107091552084526951416159646708621190826219429490015</span>, <span class="number">34145117254940196604842578208457005181132408450899191627170638987883</span>, <span class="number">120825229084143066199868275091825674337472013226784591902132114229359</span>, <span class="number">387687667198606192147021527980207738864855944986764666796629571317797</span>, <span class="number">1461874344207808204456192497546273455901754164965322967295868406627707</span>, <span class="number">3258300231591322626530795072101331694347928535549768492906530809069244</span>, <span class="number">8874418273687545553519370439384854004509761935319681848589844232674343</span>, <span class="number">26555971104148502495508475192114409958713364020252024170586326291995544</span>, <span class="number">56653286369586527413345416396708661964062474995701742952261047069623359</span>, <span class="number">154383566127721041301459355493059400704799197964228029280865862358894596</span>, <span class="number">341393868848806018386217706353404785528207249510734290203621418976352706</span>, <span class="number">1171362524761660822765817023463786914069613269413196584856696440695273738</span>, <span class="number">4194882148022101614597714583113090146333385168895367467002069867303753334</span>, <span class="number">10081717223153632058965668126630772845024206141591578024505075742926631137</span>, <span class="number">39590555580101758090745061229221178837429140073072263518741551403983751377</span>, <span class="number">124978669991117804453179514660098523434116842472570073354436333226196401318</span>, <span class="number">285677744249355467333640461312079508294900634926466871637187648581093663108</span>, <span class="number">685643590088926190360498081484403342771108281930489395367499236756131358960</span>, <span class="number">2509513194338799699151211958956210034789618340347017416940796124375457114430</span>, <span class="number">7869725510782496795692771133398729561144872690341264618424961946628895219979</span>]</span><br><span class="line">l = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">list</span>(s[::-<span class="number">1</span>])</span><br><span class="line">n = <span class="built_in">len</span>(l)</span><br><span class="line">m = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    m += s[i]*l[i]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>



<h2 id="2023天融信杯——easybog"><a href="#2023天融信杯——easybog" class="headerlink" title="2023天融信杯——easybog"></a>2023天融信杯——easybog</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import random</span><br><span class="line">from hashlib import md5</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">rr = os.urandom(10)</span><br><span class="line">flag = &quot;flag&#123;&quot;+rr.hex()+&quot;&#125;&quot;</span><br><span class="line">flag_md5 = md5(flag.encode()).hexdigest()</span><br><span class="line">print(flag)</span><br><span class="line"></span><br><span class="line">m = bin(bytes_to_long(rr))[2:].zfill(8 * len(rr))</span><br><span class="line">p = getPrime(256)</span><br><span class="line">def encrypt(m):</span><br><span class="line">    pubkey = [random.randint(2,p - 2) for i in range(len(m))]</span><br><span class="line">    enc = 0</span><br><span class="line">    for k,i in zip(pubkey,m):</span><br><span class="line">        enc += k * int(i)</span><br><span class="line">        enc %= p</span><br><span class="line">    return pubkey,enc</span><br><span class="line"></span><br><span class="line">pubkey,c = encrypt(m)</span><br><span class="line">f = open(&quot;output.txt&quot;,&quot;w&quot;)</span><br><span class="line">f.write(f&quot;p = &#123;p&#125;\n&quot;)</span><br><span class="line">f.write(f&quot;pubkey = &#123;pubkey&#125;\n&quot;)</span><br><span class="line">f.write(f&quot;c = &#123;c&#125;\n&quot;)</span><br><span class="line">f.write(f&quot;flag_md5 = &#123;flag_md5&#125;\n&quot;)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>从<code>encrypt(m)</code>，我们可以知道$c \equiv key_i×m_i \mod p \longrightarrow c &#x3D; key_i×m_i+kp$</p>
<p>$\therefore 0 &#x3D; \sum_{i&#x3D;1}^{80}key_im_i + kp - c$</p>
<p>一开始构造</p>
<p><img src="/../images/Lattice2/16.png"></p>
<p>规约后$(x_1,x_2,…,x_{80},k,\sum_{i&#x3D;1}^{80}key_ix_i+kp-tc)$就是第一行的向量。	</p>
<p>理想情况下，第一行向量的值应该是$(x_1,x_2,…,x_{80},k,0)$，其中$x_i \in \begin{Bmatrix}0,1\end{Bmatrix}$</p>
<p>发现规约后的向量不符合要求</p>
<p>改成</p>
<p>​	<img src="/../images/Lattice2/17.png"></p>
<p>两个格的区别在于行列式不同</p>
<p>exp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">p = 85766816683407427477074053090759168259205489535331001301483049660772943816017</span><br><span class="line">pubkey = [58890813098389592716367918664418237809399998613202441049117852003453550490043, 255886907973292033549191761914277947638378726729170162403000263307778539588, 43666147543837562983744529128391108960442814393989688186615627619841168438881, 2289339843351034938706095739069649849491797527322909177303809837660115875707, 41213482604182795008139260226694469358720652561587117539105919206178583341309, 85123975988270149359269904030278272256150702593339117634318036869051474541673, 38499515653492727036642516425661144597669644770181333309684190745152037999340, 20485509602350760468364550436683434882775269798789922529010411809186809838027, 66201868699675751260618542402171897519442339400362102112029773068389836772496, 5928498980938052035989976608996334019121526162545586177960440867589564370967, 50886730626726574520144515855606763616811548330471900085065588158010347676677, 64024533350992434764550819938965710849249693930938822302806256939206336927327, 38725701074483250591450474606717766666514853596721960873869603150079957176979, 79217343443391443055559755031159399927770013676937883189341106207746097977107, 61550584018851036114215415812034871024308694207855706560554908679054705909070, 18943452821091669663831772224349497605704279324611723330470460453532875854668, 19589987578009659601683539978459498259975975776374959927024576839483511789830, 30455762424330442645213719258885752997650973641135913878741104126501286615202, 58949965807078946897782791856062155685595594220625894016492979510745067947620, 62055731853485887582338078878228949009560282473783423335829652944841334703073, 9968050471897160901950463089357618812125361692340159762344476181267684171496, 82879622776859731032127240994822860125030485017752550449574280896284319539559, 4801338348200265259854446071344823901330707085102509710655971928319789477063, 45731791006706217374257923546738746982354369452894895184784691821888225473116, 67249651561046962535594292263727781436622305014470811080407605464069397278541, 74549581000796086938735007821116567870037873934415647996983670510761843574950, 53927163931460713770577528602376533863752551014779597870421933008696943680646, 56674817179749773825254339411582187056553125580899575215919582277873475282705, 46486618405288541635832334168373891479516241585245833202819962034096805786948, 33438500041468604615663063367413201369385488295864836452725688027946579037027, 67664099966578778667405575319488959391557099474146663546553930271609270514413, 45447815671440655615043306804023843286416205143693188321756314646855229497538, 11725972638697133812198141962081533057131109523301554105107846876476492922863, 64289489702331472745122326714411510149286883423778995697545620572730495023564, 57994575257987111046854716965859364231330618527165005046088441624813910607490, 14668229647185139513680523686559656096579435616501772089580139136432744069528, 17932811002316804580991874481669739042847138206519622106023735880404179858139, 5331195663859739712428554823168168360812478289288952467823046758773036202890, 74552793814948855649083379813894922159371588934498467412076815493098565156965, 44935994020454630627073800850452460158487760266394408710221643505798360283738, 56729956460199305019441584184914729272661532037080935244087594435220086006307, 62039396792619765440106521363503635264208869754554560630026111496679072778122, 2393458745997765849524009470841489934632527663821258015836036776013536950950, 35915327454351624449823951016325751779776476237317012289496757290655725512173, 32606524479615026657452402620774183996842863618201886022072527830448469143354, 63235637104235763521471020678482591762365962539497201272446150774560661623146, 62208964066864651499810642926855154855961192109426476051220581622874074871556, 56823425142073561606336827683244447153122191299012994793162957373419782442861, 60885675233604760515790987357657130734130927344692532134660791434444881730069, 70128263220978378037998154126965802527577393332688627564386146841574995052881, 71018980922731664798406835410011497130959699315348431777949257381109611662531, 12143164079299710577697191074655687226341720767219380493916347970636555672200, 13508918371738967514239962849170666297725816564248068619597724335815422874867, 35455956156846758401498039994914987477656410741995261921339242861566953715810, 69980758495467248406706658186358315365421963514406314839633132920772753269590, 40780609781497584108689952068487274243081363044494223353377248536197342087646, 44867942499383360300066493293729414921480295687316596135570022888723461284905, 82725154870798626926322339306353417520587153667878451856611421219700157524903, 25126631681527477467395254546272084567454410334950820629891182857858739056234, 6951466886617047161399523857762365328179011042304277010521273986635895511090, 76348861623318422648322072872825713398471251831589343473949016976971223635877, 56205107190224957419682681113714452084261733562014707901087589292788540501506, 18117892543394976645523077630904329147251317704285881519049138075260678609853, 44808031105096301006447146332872279574072682041430481888991436113801413524922, 49253422883319286749223459668126849556879848229728760990408851547046135426202, 84189814930926817953967035166781168797567323089104013113646102708978330223462, 47137140069594189485896203757476808738350291684312377044596204628988007490802, 40801572088832002265546622948401731702850273201235765228409527972304470614013, 66031049946459598112632104872606456117378438456948859102185817862671625118362, 81720181560222737179789740743588444616843925127263616533094516919384531350798, 22799062566507850812703708400514738660780510100747243720001217935586864713536, 19636898235593770858368519750634152409107475396982151534080287393055054087250, 29019136605948188309201641456999919579306004440518777086603961225647602320689, 79880698495154758609432245210109366091585969807890967815410904513080769679673, 9333444307040962156247586346311311869921891214405652789959336947220586492578, 5389291816105059661723219597627983160117906098832235782666626188832333763452, 80140247201709476779769310874536378021073864035213177889595402673752593492257, 10265989744904418075184606188771633319731922237097882332727796873595806941649, 28947186543573208323555611612621027283989204690818732739083074045376664847781, 76665830939598023116888796550932971936723367285838797618563918377195976634315]</span><br><span class="line">c = 1381426073179447662111620044316177635969142117258054810267264948634812447218</span><br><span class="line">flag_md5 = &quot;cae8243e01090ccd03a66e3a4c52b7ee&quot;</span><br><span class="line"></span><br><span class="line">n = len(pubkey)</span><br><span class="line"></span><br><span class="line">Ge = Matrix(ZZ,n+2,n+2)</span><br><span class="line">for i in range(n):</span><br><span class="line">    Ge[i,i] = 1</span><br><span class="line">    Ge[i,-1] = pubkey[i]</span><br><span class="line"></span><br><span class="line">Ge[-2,-2] = 1</span><br><span class="line">Ge[-2,-1] = c</span><br><span class="line">Ge[-1,-1] = p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">L = Ge.BKZ()</span><br><span class="line">ans = &#x27;&#x27;</span><br><span class="line">for i in Ge.BKZ():</span><br><span class="line">    if i[-1] == 0:</span><br><span class="line">        tmp = i[:-2]</span><br><span class="line">        for j in tmp:</span><br><span class="line">            if abs(j) == 1:</span><br><span class="line">                ans += &#x27;1&#x27;</span><br><span class="line">            else:</span><br><span class="line">                ans += &#x27;0&#x27;</span><br><span class="line">        flag = &quot;flag&#123;&quot; + hex(int(ans,2))[2:] + &quot;&#125;&quot;</span><br><span class="line">        flag_md51 = hashlib.md5(flag.encode()).hexdigest()</span><br><span class="line">        if flag_md51 == flag_md5:</span><br><span class="line">            print(flag)</span><br></pre></td></tr></table></figure>

<p>这里使用的是<code>BKZ</code>算法，暂时没有了解</p>
<p>sagemath中的<code>BKZ()</code>可以设置参数，例如<code>BKZ(block_size = 16)</code>，指定了<code>BKZ</code>算法中的块大小。默认情况下是<code>block_size = 20</code></p>
<h1 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h1><p><a href="https://harry0597.com/2022/07/21/bag/">CTF·背包问题相关 | Harry’s Blog (harry0597.com)</a></p>
<p><a href="https://jayxv.github.io/2020/06/08/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bknapsack/">密码学学习笔记 之 knapsack | Van1sh的小屋 (jayxv.github.io)</a></p>
<p><a href="https://www.ieice.org/publications/conference-FIT-DVDs/FIT2018/data/pdf/A-022.pdf">A-022.pdf (ieice.org)</a></p>
<p><a href="https://ctf-wiki.org/crypto/asymmetric/knapsack/knapsack/">背包加密 - CTF Wiki (ctf-wiki.org)</a></p>
]]></content>
      <categories>
        <category>格密码</category>
      </categories>
      <tags>
        <tag>Lattice</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔(一)</title>
    <url>/2023/07/04/%E9%9A%8F%E7%AC%94(%E4%B8%80)/</url>
    <content><![CDATA[<p>人生如逆旅，我亦是行人</p>
<span id="more"></span>

<p>时间：2023年7月4日，进入星盟预备队的第一天</p>
<p>​		今天是进入星盟预备队的第一天。也许这是我CTF生涯中一个向上重大的转折点，这个不好说，关键还是得看我够不够努力。</p>
<p>​		先说说今天的经历吧，早上起来先是处理了宿舍一起买洗衣机的事情，需要联系辅导员，安装师傅，快递师傅，第一次经历这种事情确实让我有点昏了头，不过好在算是解决了，很开心自己现在能处理挺多事情了。</p>
<p>​		早饭过后，来到图书馆，开始做昨天规划好的事情，即博客。第一次部署博客，碰壁的地方还是很多的，比如主题安装只会安装Fluid，配置文件也不大明白，只能在网上找各种教程慢慢摸索，好在下午起床的时候也是成功发布了第一篇博客，也就是这篇，写的不好的地方希望大家指出，以后会慢慢完善博客，例如赛题复现之类的。</p>
<p>​		从接触CTF到现在也差不多一年的时间了，中间大部分时间在碰壁，思考走什么方向，一直在犹豫徘徊。直到寒假，决定了走密码学方向，起步的时候，没有学习方向，一直是自己摸索，当时也没意识到时间的紧迫性。直到开学，才算是真正开始了Crypto学习之路，在这学习期间，任务也是挺重的，一方面学校的课程，以及一些乱七八糟的琐事。在此期间，看到同届的几位同学早已进入战队，有的甚至已经挣了大钱。当时从没想过自己也有进入战队的一天，不过现在算是迈出了一步。</p>
<p>​		讲讲和星盟的渊源吧</p>
<p>​		一次偶然的机会加上了星盟的一位师傅(当时对战队没概念，也没有询问过多，只是想着能和校外的师傅进行交流)。真正知道这位师傅是星盟的时间是打LitCTF的时候</p>
<p>，比赛结束后去问了题目，然后聊着聊着就聊到关于星盟的事情。师傅当时问我要不要进入战队，我抱着试试看的心态就让师傅拉进了群，然后就认识到了Harry师傅，了解了一下战队，和Harry师傅聊了很多，大多都是关于学习态度的问题，不过此时已经是期末月了，就把面试的时间拖到了7月初。</p>
<p>​		很幸运能够进入Hyperion，在接下来的一段时间，我会好好努力，争取晋升。</p>
<p>​		那么日记就记录到下午啦。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA1</title>
    <url>/2023/07/06/RSA1/</url>
    <content><![CDATA[<p><strong>世上无所谓正解，我们只是在做自己</strong></p>
<span id="more"></span>

<p><strong>记录笔者RSA学习过程</strong></p>
<h1 id="RSA算法原理简介"><a href="#RSA算法原理简介" class="headerlink" title="RSA算法原理简介"></a>RSA算法原理简介</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.选择两个大素数p和q，计算模n=p*q</span><br><span class="line">2.计算φ(n)=(p-1)*(q-1) 这里是因为，素数p的欧拉函数φ(p)=p-1，同理φ(q)=q-1，又因为n=p*q，所以φ(n)=(p-1)*(q-1)</span><br><span class="line">3.取e的模反数为d(逆元)，计算方法：e*d ≡ 1(mod φ(n))</span><br><span class="line">4.对明文m进行加密：</span><br><span class="line">	密文c = m^e (mod n)</span><br><span class="line"></span><br><span class="line">解密：</span><br><span class="line">m = c^d (mod n) </span><br></pre></td></tr></table></figure>

<p>欧拉函数另外一种算法：</p>
<p>若$n$可以分解为某个素数的$k$次方，即$n &#x3D; p^k$，则$\phi(n) &#x3D; p^{k-1}(p-1)$</p>
<p><strong>数论知识：</strong></p>
<p>欧拉定理：若$n,a$为正整数，且$n,a$互素，则$a^{\phi(n)} \equiv 1 \mod n$</p>
<p>费马小定理：若$p$是素数，且$a,p$互素，则$a^p \equiv a\mod p$，$a^{p-1} \equiv 1 \mod p$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">模运算：</span><br><span class="line">(a + b) % p = (a % p + b % p) % p</span><br><span class="line">(a - b) % p = (a % p - b % p) % p</span><br><span class="line">(a × b) % p = (a % p × b % p) % p</span><br><span class="line">a^b % p = ((a % p)^b) % p </span><br><span class="line">结合律：</span><br><span class="line">((a + b) % p + c) = (a + (b + c) % p) % p </span><br><span class="line">((a × b) % p × c) = (a × (b × c) % p) % p</span><br><span class="line">交换律：</span><br><span class="line">(a + b) % p = (b + a) % p</span><br><span class="line">(a * b) % p = (b * a) % p</span><br><span class="line">分配律：</span><br><span class="line">(a + b) % p = (a % p + b % p) % p</span><br><span class="line">((a + b) % p * c) % p = (((a * c) % p) + ((b * c) % p)) % p</span><br></pre></td></tr></table></figure>

<p>重要定理：</p>
<ol>
<li><p>若$a\equiv b \mod p$，对于任意的$c$，有$(a+c) \equiv (b+c) \mod p$</p>
</li>
<li><p>若$a \equiv b \mod p$，对于任意的$c$，有$(a×c) \equiv (b×c) \mod p$</p>
</li>
<li><p>若$a\equiv b \mod p$，$c \equiv d \mod p$。</p>
<p>有$(a±c) \equiv (b±d) \mod p$，$(a×c)\equiv (b×d) \mod p$，$\frac{a}{c}\equiv \frac{b}{d} \mod p$</p>
</li>
</ol>
<p><strong>逆元</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a mod p 的逆元，设为x，就是可以使得 a * x (mod p) = 1的最小x</span><br></pre></td></tr></table></figure>

<p>证明$m \equiv c^d \mod n$的正确性</p>
<p>$\because c \equiv m^e \mod n$，$m \equiv c^d \mod  n$</p>
<p>$\therefore m \equiv (m^e\mod n)^d \mod n \longrightarrow m \equiv (m^e)^d \mod n$</p>
<p>根据$(a \mod p)b \mod p \equiv a^b \mod p$</p>
<p>$\therefore m\equiv m^{ed} \mod n$，又$ed \equiv 1 \mod \phi(n) \longrightarrow ed &#x3D; k\phi(n)+1$</p>
<p>$\therefore m \equiv m ^{k\phi(n)+1} \mod n \longrightarrow m \equiv (m^{\phi(n)})^k×m \mod n$</p>
<p>由费马小定理得$m^{\phi(n)} \equiv 1 \mod n $</p>
<p>$\therefore m \equiv 1^k ×m \mod n$，$\therefore m \equiv c^d \mod n$</p>
<h1 id="一、基于分解n的题目"><a href="#一、基于分解n的题目" class="headerlink" title="一、基于分解n的题目"></a>一、基于分解n的题目</h1><h2 id="1-用yafu分解"><a href="#1-用yafu分解" class="headerlink" title="1.用yafu分解"></a>1.用yafu分解</h2><h2 id="2-网站分解"><a href="#2-网站分解" class="headerlink" title="2.网站分解"></a>2.网站分解</h2><h2 id="3-费马分解"><a href="#3-费马分解" class="headerlink" title="3.费马分解"></a>3.费马分解</h2><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = 12627644643778588563638920097915399454513514338804142285365906525498881036764131263143503359846189659273574532609463345820199502529021505655249992763681092637840409087205147095497477412031460598408163901210084467516709264700724398765301043908384308244747517893224665577128486689416162459250095126318456522046726204794830519283112518017007468770465828497144764208737754275011224549145753948172880930824906241704072415618131966725150546352452195727712056875106693907690990407658130836472884891082069644890044024145259903993177177196801509187283280149791400422260709944706691099262186583269852628892867781015062638406807</span><br><span class="line">e = 65537</span><br><span class="line">c = 3591154430994525075059034292233285219547469362782194889629270181283842636528606554393490851841066761509914849524082427752928544931823147005056532710833510595339404286404496491815089547021604266428940702481584786412593056050015881926826382036205406303525545716475450640777471292475111436226636460600345957363695624982558394414290121846251722500596533341384706714159205414604934501768918663557451374023537565102442827170460775303421150229829840660742855663501969208548706192593969737261023358057081741247088819534013372830024084918363322257487890942468889177188305118367719047889896681307253995123323963920988776643105</span><br></pre></td></tr></table></figure>

<p>分解个n就行了</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">n = <span class="number">12627644643778588563638920097915399454513514338804142285365906525498881036764131263143503359846189659273574532609463345820199502529021505655249992763681092637840409087205147095497477412031460598408163901210084467516709264700724398765301043908384308244747517893224665577128486689416162459250095126318456522046726204794830519283112518017007468770465828497144764208737754275011224549145753948172880930824906241704072415618131966725150546352452195727712056875106693907690990407658130836472884891082069644890044024145259903993177177196801509187283280149791400422260709944706691099262186583269852628892867781015062638406807</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c =<span class="number">3591154430994525075059034292233285219547469362782194889629270181283842636528606554393490851841066761509914849524082427752928544931823147005056532710833510595339404286404496491815089547021604266428940702481584786412593056050015881926826382036205406303525545716475450640777471292475111436226636460600345957363695624982558394414290121846251722500596533341384706714159205414604934501768918663557451374023537565102442827170460775303421150229829840660742855663501969208548706192593969737261023358057081741247088819534013372830024084918363322257487890942468889177188305118367719047889896681307253995123323963920988776643105</span></span><br><span class="line">p = <span class="number">112372793165332455233644051831703093065233917285171435667727396467617869514267375433546885241603527682450490525106056020927668059639131922631965832681267028908272712604839741417231722918220018271377173404939261706593582911881852334650278053606220270970895872789340580971511712537114765669110273199402053062671</span></span><br><span class="line">q = n//p</span><br><span class="line"></span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br></pre></td></tr></table></figure>



<h1 id="二、密钥生成和读取"><a href="#二、密钥生成和读取" class="headerlink" title="二、密钥生成和读取"></a>二、密钥生成和读取</h1><h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>通过<code>Crypto.PublicKey.RSA</code>中的<code>construct</code>函数可以生成公钥和私钥。</p>
<p>对于生成公钥，需要两个参数$n,e$，生成私钥需要$n,e,d$</p>
<p>需要配合<code>exprot_Key</code>使用</p>
<h3 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h3><p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">a = (n,e)</span><br><span class="line">publickey = RSA.construct(a)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;publickey.pem&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(publickey.export_key())</span><br></pre></td></tr></table></figure>

<p><strong>注意要先把n,e括起来</strong></p>
<h3 id="生成私钥"><a href="#生成私钥" class="headerlink" title="生成私钥"></a>生成私钥</h3><p>传入的数据是$n,e,d,p,q$	其中$p,q$可以不传</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">a = (n,e)</span><br><span class="line">b = (n,e,<span class="built_in">int</span>(d))</span><br><span class="line"></span><br><span class="line">publickey = RSA.construct(a)</span><br><span class="line">privatekey = RSA.construct(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;publickey.pem&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(publickey.export_key())</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;privatekey.pem&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f2:</span><br><span class="line">    f2.write(privatekey.export_key())</span><br></pre></td></tr></table></figure>

<p>这里注意要把d变成int型，因为invert出来的d是mpz数据</p>
<p><strong><code>mpz</code>是GMP（GNU Multiple Precision Arithmetic Library）库中的一个数据类型，表示任意精度整数（Arbitrary precision integer）。它可以表示任意大小的整数，不受机器字长的限制</strong></p>
<p>这样就成功生成了公私钥，试了一下把.pem改成.txt，也能运行</p>
<p>从gpt那里了解了一下pem文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PEM（Privacy-Enhanced Mail）是一种用于加密和解密电子邮件的加密标准，也是一种常用的加密文件格式，常用于存储各种类型的加密密钥和证书。</span><br><span class="line"></span><br><span class="line">PEM文件的格式是基于Base64编码的文本文件，通常以.pem、.crt、.cer、.key、.p12、.pfx等扩展名结尾。PEM文件可以存储各种类型的加密密钥和证书，包括RSA和DSA密钥、X.509证书、PKCS#7证书链、PKCS#8私钥等。</span><br></pre></td></tr></table></figure>

<h2 id="读取密钥"><a href="#读取密钥" class="headerlink" title="读取密钥"></a>读取密钥</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"></span><br><span class="line">key = RSA.import_Key(文件)</span><br></pre></td></tr></table></figure>

<p>key中有p,q,n,e,d五个属性</p>
<p>我感觉一般就用到n,e</p>
<h3 id="例题1-泄露私钥"><a href="#例题1-泄露私钥" class="headerlink" title="例题1 泄露私钥"></a>例题1 泄露私钥</h3><p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.PublicKey import RSA</span><br><span class="line">import libnum</span><br><span class="line">import gmpy2</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">print(flag)</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line"></span><br><span class="line">p = libnum.generate_prime(1024)</span><br><span class="line">q = gmpy2.next_prime(p)</span><br><span class="line">n = p * q</span><br><span class="line">e = 65537</span><br><span class="line">phi = (p - 1) * (q - 1)</span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">#</span><br><span class="line">c1 = libnum.n2s(int(c))</span><br><span class="line"></span><br><span class="line">with open(&quot;flag.pem&quot;, &quot;wb&quot;) as f:</span><br><span class="line">    f.write(c1)</span><br><span class="line"># 生成公钥</span><br><span class="line">rsa_components = (int(n), int(e), int(d))</span><br><span class="line">keypair = RSA.construct(rsa_components)</span><br><span class="line">with open(&#x27;pubckey.pem&#x27;, &#x27;wb&#x27;) as f:</span><br><span class="line">    f.write(keypair.exportKey())</span><br></pre></td></tr></table></figure>

<p><strong>题目中把d也传入数据了，所以可以直接把d提了</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">c = bytes_to_long(<span class="built_in">open</span>(<span class="string">&quot;flag.pem&quot;</span>,<span class="string">&quot;rb&quot;</span>).read())</span><br><span class="line">key = RSA.import_key(<span class="built_in">open</span>(<span class="string">&quot;publickey.pem&quot;</span>,<span class="string">&quot;rb&quot;</span>).read())</span><br><span class="line">e = key.e</span><br><span class="line">n = key.n</span><br><span class="line">d = key.d</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># flag&#123;947ce8a3-40ee-46c0-a00e-0026e583f8da&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="例题2-公钥分解"><a href="#例题2-公钥分解" class="headerlink" title="例题2 公钥分解"></a>例题2 公钥分解</h3><p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.PublicKey import RSA</span><br><span class="line">import libnum</span><br><span class="line">import gmpy2</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">print(flag)</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line"></span><br><span class="line">p = libnum.generate_prime(1024)</span><br><span class="line">q = gmpy2.next_prime(p)</span><br><span class="line">n = p * q</span><br><span class="line">e = 65537</span><br><span class="line">phi = (p - 1) * (q - 1)</span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">#</span><br><span class="line">c1 = libnum.n2s(int(c))</span><br><span class="line"></span><br><span class="line">with open(&quot;flag1.pem&quot;, &quot;wb&quot;) as f:</span><br><span class="line">    f.write(c1)</span><br><span class="line"># 生成公钥</span><br><span class="line">rsa_components = (int(n), int(e))</span><br><span class="line">keypair = RSA.construct(rsa_components)</span><br><span class="line">with open(&#x27;pubckey1.pem&#x27;, &#x27;wb&#x27;) as f:</span><br><span class="line">    f.write(keypair.exportKey())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>首选网站分解n，发现不大行</strong></p>
<p><strong>再试了一下开根号，发现还是不行</strong></p>
<p><strong>最后试了next_prime(开根号得到的值)，解成功</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">c = bytes_to_long(<span class="built_in">open</span>(<span class="string">&quot;flag1.pem&quot;</span>,<span class="string">&quot;rb&quot;</span>).read())</span><br><span class="line">key = RSA.import_key(<span class="built_in">open</span>(<span class="string">&quot;pubckey1.pem&quot;</span>,<span class="string">&quot;rb&quot;</span>).read())</span><br><span class="line">e = key.e</span><br><span class="line">n = key.n</span><br><span class="line"></span><br><span class="line">p1 = gmpy2.iroot(n,<span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">p = gmpy2.next_prime(p1)</span><br><span class="line">q = n//p</span><br><span class="line"></span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#flag&#123;a959ffca-06c5-47df-8313-4f9c38db4920&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="例题3-OAEP"><a href="#例题3-OAEP" class="headerlink" title="例题3 OAEP"></a>例题3 OAEP</h3><p>了解一下OAEP</p>
<p><strong>OAEP是一种用于公钥加密的填充方案，用来提供概率加密。</strong></p>
<p><strong>OAEP作为一种填充方案被开发出来，用于提供概率加密。它的工作原理是在加密之前向消息添加随机数据，使得攻击者更难确定原始消息。他应用于RSA加密算法，但不局限于RSA加密算法</strong></p>
<p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.PublicKey import RSA</span><br><span class="line">from Crypto.Cipher import PKCS1_OAEP</span><br><span class="line">import libnum</span><br><span class="line">import gmpy2</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">print(flag)</span><br><span class="line">flag = flag.encode()</span><br><span class="line"></span><br><span class="line">p = libnum.generate_prime(1024)</span><br><span class="line">q = gmpy2.next_prime(p)</span><br><span class="line">n = p * q</span><br><span class="line">e = 65537</span><br><span class="line">phi = (p - 1) * (q - 1)</span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># 生成公钥</span><br><span class="line">rsa_components = (int(n), int(e), int(d))</span><br><span class="line">keypair = RSA.construct(rsa_components)</span><br><span class="line">with open(&#x27;prikey2.pem&#x27;, &#x27;wb&#x27;) as f:</span><br><span class="line">    f.write(keypair.exportKey())</span><br><span class="line"></span><br><span class="line">rsa_components = (int(n), e,)</span><br><span class="line">arsa = RSA.construct(rsa_components)</span><br><span class="line">rsakey = RSA.importKey(arsa.exportKey())</span><br><span class="line">rsakey = PKCS1_OAEP.new(rsakey)</span><br><span class="line">c = rsakey.encrypt(flag)</span><br><span class="line">with open(&quot;flag2.pem&quot;, &quot;wb&quot;) as f:</span><br><span class="line">    f.write(c)</span><br></pre></td></tr></table></figure>

<p>了解了一下函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PKCS1_OAEP.new(key, hashAlgo=<span class="literal">None</span>, mgfunc=<span class="literal">None</span>, label=<span class="string">b&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>参数含义如下：</p>
<ul>
<li><code>key</code>: RSA密钥，可以是公钥或私钥；</li>
<li><code>hashAlgo</code>: 哈希算法，默认为SHA-1；</li>
<li><code>mgfunc</code>: 消息生成函数，默认为MGF1；</li>
<li><code>label</code>: 可选的附加数据，默认为空。</li>
</ul>
<p>key是必需参数</p>
<p>使用<code>PKCS1_OAEP.new</code>初始化后，可以调用其实例方法<code>encrypt</code>和<code>decrypt</code>实现RSA-OAEP算法的加密和解密操作</p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_OAEP</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey.RSA <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">c = <span class="built_in">open</span>(<span class="string">&quot;flag2.pem&quot;</span>,<span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line">key = import_key(<span class="built_in">open</span>(<span class="string">&quot;prikey2.pem&quot;</span>,<span class="string">&quot;rb&quot;</span>).read())</span><br><span class="line"></span><br><span class="line">newkey = PKCS1_OAEP.new(key)</span><br><span class="line">m = newkey.decrypt(c)</span><br><span class="line"><span class="built_in">print</span>(m).</span><br><span class="line"></span><br><span class="line"><span class="comment">#flag&#123;04bbaad0-9241-42a4-9fd4-7d6e0d8bc5f1&#125;</span></span><br></pre></td></tr></table></figure>

<p>解题中学到在这种题目中：</p>
<p><strong>c不需要转成整型</strong></p>
<p><strong>decrypt接受的数据是byte类型的密文</strong></p>
<h3 id="攻防世界——cr4-poor-rsa"><a href="#攻防世界——cr4-poor-rsa" class="headerlink" title="攻防世界——cr4-poor-rsa"></a>攻防世界——cr4-poor-rsa</h3><p>题目给了个无后缀的文件，拖到010发现里面有藏两个文件，于是把后缀改成了zip</p>
<p>打开后得到两个文件，<strong>分别是key.pub和flag.b64</strong></p>
<p>key.pub:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">ME0wDQYJKoZIhvcNAQEBBQADPAAwOQIyUqmeJJ7nzzwMv5Y6AJZhdyvJzfbh4/v8</span><br><span class="line">bkSgel4PiURXqfgcOuEyrFaD01soulwyQkMCAwEAAQ==</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure>

<p>flag.b64:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ni45iH4UnXSttNuf0Oy80+G5J7tm8sBJuDNN7qfTIdEKJow4siF2cpSbP/qIWDjSi+w=</span><br></pre></td></tr></table></figure>

<p>先试着读取公钥，发现n可以分解，于是就按常规流程做了</p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey.RSA <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">c = base64.b64decode(<span class="built_in">open</span>(<span class="string">&quot;flag.b64&quot;</span>,<span class="string">&quot;rb&quot;</span>).read())</span><br><span class="line">c = bytes_to_long(c)</span><br><span class="line">key = import_key(<span class="built_in">open</span>(<span class="string">&quot;key.pub&quot;</span>,<span class="string">&quot;rb&quot;</span>).read())</span><br><span class="line"></span><br><span class="line">p = <span class="number">863653476616376575308866344984576466644942572246900013156919</span></span><br><span class="line">q = <span class="number">965445304326998194798282228842484732438457170595999523426901</span></span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#XCTF&#123;SMALL_PRIMES_ARE_BAD&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="三、共模攻击"><a href="#三、共模攻击" class="headerlink" title="三、共模攻击"></a>三、共模攻击</h1><p>共模攻击：</p>
<p><strong>在对同一明文的加密过程中使用相同的模数n，对同一明文，用不同的密钥e（两个密钥是互素的）进行加密</strong></p>
<p><strong>结果是得到两个不同的c</strong></p>
<p>原理：</p>
<p>$c_1 \equiv m^{e_1} \mod n$，$c_2 \equiv m^{e_2}\mod n$，$gcd(e_1,e_2)&#x3D;1$</p>
<p><strong>根据欧几里得扩展算法</strong>：若$a,b$是两个不全为0的整数，则存在两个整数$x,y$使得$s×a+t×b &#x3D; gcd(a,b)$</p>
<p>在这里有$e_1x+e_2y &#x3D; 1$</p>
<p>$\therefore c_1^x×c_2^y \equiv (m^{e_1} \mod n)^x ×(m^{e_2} \mod n)^y \mod n$</p>
<p>$\therefore c_1^x×c_2^y \equiv m^{e_1x+e_2y} \mod n$</p>
<p>$\because e_1x+e_2y &#x3D; 1$</p>
<p>$\therefore c_1^x×c_2^y \equiv m \mod n$</p>
<h2 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import gmpy2</span><br><span class="line">import uuid</span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">p = libnum.generate_prime(1024)</span><br><span class="line">q = libnum.generate_prime(1024)</span><br><span class="line">n1 = p * q</span><br><span class="line">n2 = p * q</span><br><span class="line">e1 = 2333</span><br><span class="line">e2 = 23333</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">c1 = pow(m, e1, n1)</span><br><span class="line">c2 = pow(m, e2, n2)</span><br><span class="line">print(&quot;n1=&quot;, n1)</span><br><span class="line">print(&quot;n2=&quot;, n2)</span><br><span class="line">print(&quot;e1=&quot;, e1)</span><br><span class="line">print(&quot;e2=&quot;, e2)</span><br><span class="line">print(&quot;c1=&quot;, c1)</span><br><span class="line">print(&quot;c2=&quot;, c2)</span><br><span class="line"></span><br><span class="line">#n1 = 12023886737570921683430494088148056717464277480371493354080633886982376602419433228186314817561301719123238737516332784081267153425832030515178119047675516911098595227477026283152544604891747727831780305507300318674027062554009254728767714650522432836286987070040177863862115871377017779058128916872854380528430193235920536818893053943407063308419618772087299760070707222914961338101044775521373972076936552277418325268112523349134412986872504187930360266568935217397303420305220796347316727211659529079762169876950534044014924448371804442314283893083178368082712851107281302456671010073505430574108861981588149293779</span><br><span class="line">n2 = 12023886737570921683430494088148056717464277480371493354080633886982376602419433228186314817561301719123238737516332784081267153425832030515178119047675516911098595227477026283152544604891747727831780305507300318674027062554009254728767714650522432836286987070040177863862115871377017779058128916872854380528430193235920536818893053943407063308419618772087299760070707222914961338101044775521373972076936552277418325268112523349134412986872504187930360266568935217397303420305220796347316727211659529079762169876950534044014924448371804442314283893083178368082712851107281302456671010073505430574108861981588149293779</span><br><span class="line">e1 = 2333</span><br><span class="line">e2 = 23333</span><br><span class="line">    c1 = 1316116662134770690879814362103839780623420120527248536043840592146479052480574077985474161623763978563721124073172820410730492348846200098142706235343164470686127445583938273863894304189618247054649514955176136464273395879832878841555224421879457659795562326746943199675846414637238040550327393009642569894024250271081839428945999237716296592560124669418322569188493036148885333003876760965512925618500360394774816066758106739359762817644284120811162065280330204951295150904138010974815308787047834776406610525102814356091515999954110712767658162496023213125548829820563945272374105274832862682574678195529192009516</span><br><span class="line">c2 =6485241395763328009719746130709898541269729483150505308808259329749145687803066648274311801821624527910483266170666538736992203392620205417714840881369386852010836477498279266591695876758050686740322941452286584178315830797555697887040771666991377055060541491757349967338300117181859105577325308779010792879713808168285776399372981366988860647334022480774711504685240194804912592209253106123423232743785805952113875347267336118332317990496240807273787216894980604742600774512296661048914646776553393778079057461747246478299158814839681875752645552215714984659603917168300453505504140987829883479097467840565806608012</span><br></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n = <span class="number">12023886737570921683430494088148056717464277480371493354080633886982376602419433228186314817561301719123238737516332784081267153425832030515178119047675516911098595227477026283152544604891747727831780305507300318674027062554009254728767714650522432836286987070040177863862115871377017779058128916872854380528430193235920536818893053943407063308419618772087299760070707222914961338101044775521373972076936552277418325268112523349134412986872504187930360266568935217397303420305220796347316727211659529079762169876950534044014924448371804442314283893083178368082712851107281302456671010073505430574108861981588149293779</span></span><br><span class="line">e1 = <span class="number">2333</span></span><br><span class="line">e2 = <span class="number">23333</span></span><br><span class="line">c1 =<span class="number">1316116662134770690879814362103839780623420120527248536043840592146479052480574077985474161623763978563721124073172820410730492348846200098142706235343164470686127445583938273863894304189618247054649514955176136464273395879832878841555224421879457659795562326746943199675846414637238040550327393009642569894024250271081839428945999237716296592560124669418322569188493036148885333003876760965512925618500360394774816066758106739359762817644284120811162065280330204951295150904138010974815308787047834776406610525102814356091515999954110712767658162496023213125548829820563945272374105274832862682574678195529192009516</span></span><br><span class="line">c2 =<span class="number">6485241395763328009719746130709898541269729483150505308808259329749145687803066648274311801821624527910483266170666538736992203392620205417714840881369386852010836477498279266591695876758050686740322941452286584178315830797555697887040771666991377055060541491757349967338300117181859105577325308779010792879713808168285776399372981366988860647334022480774711504685240194804912592209253106123423232743785805952113875347267336118332317990496240807273787216894980604742600774512296661048914646776553393778079057461747246478299158814839681875752645552215714984659603917168300453505504140987829883479097467840565806608012</span></span><br><span class="line"></span><br><span class="line">s,x,y = gmpy2.gcdext(e1,e2)</span><br><span class="line">m = (<span class="built_in">pow</span>(c1,x,n)*<span class="built_in">pow</span>(c2,y,n))%n</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"><span class="comment">#flag&#123;01d80670b01b654fe4831a3e81870734&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>gcdext(e1,e2)</code>返回3个元素</p>
<p>第一个元素是$Boolean$类型的数据，判断存不存在$x,y$使得$e_1x+e_2y &#x3D; 1$</p>
<p>返回得第二个和第三个元素是$x,y$</p>
<h2 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from gmpy2 import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag  = &#x27;***************&#x27;</span><br><span class="line"></span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">m1 = bytes_to_long(bytes(flag.encode()))</span><br><span class="line"></span><br><span class="line">n = p*q</span><br><span class="line">e1 = getPrime(32)</span><br><span class="line">e2 = getPrime(32)</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">flag1 = pow(m1,e1,n)</span><br><span class="line">flag2 = pow(m1,e2,n)</span><br><span class="line">print(&#x27;flag1= &#x27;+str(flag1))</span><br><span class="line">print(&#x27;flag2= &#x27;+str(flag2))</span><br><span class="line">print(&#x27;e1= &#x27; +str(e1))</span><br><span class="line">print(&#x27;e2= &#x27;+str(e2))</span><br><span class="line">print(&#x27;n= &#x27;+str(n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#flag1= 100156221476910922393504870369139942732039899485715044553913743347065883159136513788649486841774544271396690778274591792200052614669235485675534653358596366535073802301361391007325520975043321423979924560272762579823233787671688669418622502663507796640233829689484044539829008058686075845762979657345727814280</span><br><span class="line">#flag2= 86203582128388484129915298832227259690596162850520078142152482846864345432564143608324463705492416009896246993950991615005717737886323630334871790740288140033046061512799892371429864110237909925611745163785768204802056985016447086450491884472899152778839120484475953828199840871689380584162839244393022471075</span><br><span class="line">#e1= 3247473589</span><br><span class="line">#e2= 3698409173</span><br><span class="line">#n= 103606706829811720151309965777670519601112877713318435398103278099344725459597221064867089950867125892545997503531556048610968847926307322033117328614701432100084574953706259773711412853364463950703468142791390129671097834871371125741564434710151190962389213898270025272913761067078391308880995594218009110313</span><br></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n = <span class="number">103606706829811720151309965777670519601112877713318435398103278099344725459597221064867089950867125892545997503531556048610968847926307322033117328614701432100084574953706259773711412853364463950703468142791390129671097834871371125741564434710151190962389213898270025272913761067078391308880995594218009110313</span></span><br><span class="line">e1 = <span class="number">3247473589</span></span><br><span class="line">e2 = <span class="number">3698409173</span></span><br><span class="line">c1 =<span class="number">100156221476910922393504870369139942732039899485715044553913743347065883159136513788649486841774544271396690778274591792200052614669235485675534653358596366535073802301361391007325520975043321423979924560272762579823233787671688669418622502663507796640233829689484044539829008058686075845762979657345727814280</span></span><br><span class="line">c2 =<span class="number">86203582128388484129915298832227259690596162850520078142152482846864345432564143608324463705492416009896246993950991615005717737886323630334871790740288140033046061512799892371429864110237909925611745163785768204802056985016447086450491884472899152778839120484475953828199840871689380584162839244393022471075</span></span><br><span class="line"></span><br><span class="line">s,x,y = gmpy2.gcdext(e1,e2)</span><br><span class="line">m = (<span class="built_in">pow</span>(c1,x,n)*<span class="built_in">pow</span>(c2,y,n))%n</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"><span class="comment">#NSSCTF&#123;xxxxx******xxxxx&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="四、低加密指数攻击"><a href="#四、低加密指数攻击" class="headerlink" title="四、低加密指数攻击"></a>四、低加密指数攻击</h1><p>原理：</p>
<p>加密指数e很小一般是3，导致出现两个情况</p>
<p>第一种情况：$m^e &lt; n $则$c \equiv m^{e} \mod  n \longrightarrow c &#x3D; m^e$这种情况下对c开e次方就可以得到m的值</p>
<p>第二种情况：$m^e &gt; n$则$m^e &#x3D; k*n + c$这种情况需要爆破k</p>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import gmpy2</span><br><span class="line">import uuid</span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">print(gmpy2.bit_length(m ** 3))</span><br><span class="line">while True:</span><br><span class="line">    p = libnum.generate_prime(504)</span><br><span class="line">    q = libnum.generate_prime(504)</span><br><span class="line">    n = p * q</span><br><span class="line">    phi_n = (p - 1) * (q - 1)</span><br><span class="line">    e = 3</span><br><span class="line">    if gmpy2.gcd(e, phi_n) == 1 and  phi_n%e !=0:</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(&quot;n=&quot;, n)</span><br><span class="line">print(&quot;e=&quot;, e)</span><br><span class="line">print(&quot;c=&quot;, c)</span><br><span class="line"></span><br><span class="line">#c= 17567615026662297423639652671128685098763112348521263232850922784902991105809108670614334001294254886850775709702759646022208238160649099765454315761185950859820327234504422026634432251632399712621439201146</span><br><span class="line">3091635444512796333373451321795475333496092463760390199602320265733668648810943598505902205569125</span><br><span class="line">n = 1101676297168703265566511587913652821222614528632844563918598090813090976948138058144049294690727841463413972173051671908835164088465174349647584948964206244648736138253802417241570633968307801570794459668533128958442296813160786428069813867034205462528763830205245218089660432399549540588101288362866463</span><br><span class="line">e = 3</span><br></pre></td></tr></table></figure>

<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n = <span class="number">1101676297168703265566511587913652821222614528632844563918598090813090976948138058144049294690727841463413972173051671908835164088465174349647584948964206244648736138253802417241570633968307801570794459668533128958442296813160786428069813867034205462528763830205245218089660432399549540588101288362866463</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">c = <span class="number">175676150266622974236396526711286850987631123485212632328509227849029911058091086706143340012942548868507757097027596460222082381606490997654543157611859508598203272345044220266344322516323997126214392011463091635444512796333373451321795475333496092463760390199602320265733668648810943598505902205569125</span></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">t = gmpy2.iroot(c,e)</span><br><span class="line"><span class="keyword">if</span> t[<span class="number">1</span>]:</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(t[<span class="number">0</span>]))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        m = gmpy2.iroot(k*n+c,e)</span><br><span class="line">        <span class="keyword">if</span> m[<span class="number">1</span>]:</span><br><span class="line">            <span class="built_in">print</span>(long_to_bytes(m[<span class="number">0</span>]))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="五、低加密指数广播攻击"><a href="#五、低加密指数广播攻击" class="headerlink" title="五、低加密指数广播攻击"></a>五、低加密指数广播攻击</h1><p>原理：</p>
<p>明文$m$用相同的密钥$e$和不同的模$n$进行加密</p>
<p>一般会得到几组不同的$n$和$c$</p>
<h2 id="第一种情况-多组n"><a href="#第一种情况-多组n" class="headerlink" title="第一种情况 多组n"></a>第一种情况 多组n</h2><p><strong>这些不同的n之间的最大公约数如果不是1的话，会泄露p，就是说最大公约数是p</strong></p>
<h3 id="例题-BUUCTF-RSA5"><a href="#例题-BUUCTF-RSA5" class="headerlink" title="例题 BUUCTF-RSA5"></a>例题 BUUCTF-RSA5</h3><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m = xxxxxxxx</span><br><span class="line">e = 65537</span><br><span class="line">========== n c ==========</span><br><span class="line">n = 20474918894051778533305262345601880928088284471121823754049725354072477155873778848055073843345820697886641086842612486541250183965966001591342031562953561793332341641334302847996108417466360688139866505179689516589305636902137210185624650854906780037204412206309949199080005576922775773722438863762117750429327585792093447423980002401200613302943834212820909269713876683465817369158585822294675056978970612202885426436071950214538262921077409076160417436699836138801162621314845608796870206834704116707763169847387223307828908570944984416973019427529790029089766264949078038669523465243837675263858062854739083634207</span><br><span class="line">c = 974463908243330865728978769213595400782053398596897741316275722596415018912929508637393850919224969271766388710025195039896961956062895570062146947736340342927974992616678893372744261954172873490878805483241196345881721164078651156067119957816422768524442025688079462656755605982104174001635345874022133045402344010045961111720151990412034477755851802769069309069018738541854130183692204758761427121279982002993939745343695671900015296790637464880337375511536424796890996526681200633086841036320395847725935744757993013352804650575068136129295591306569213300156333650910795946800820067494143364885842896291126137320</span><br><span class="line"></span><br><span class="line">n = 20918819960648891349438263046954902210959146407860980742165930253781318759285692492511475263234242002509419079545644051755251311392635763412553499744506421566074721268822337321637265942226790343839856182100575539845358877493718334237585821263388181126545189723429262149630651289446553402190531135520836104217160268349688525168375213462570213612845898989694324269410202496871688649978370284661017399056903931840656757330859626183773396574056413017367606446540199973155630466239453637232936904063706551160650295031273385619470740593510267285957905801566362502262757750629162937373721291789527659531499435235261620309759</span><br><span class="line">c = 15819636201971185538694880505120469332582151856714070824521803121848292387556864177196229718923770810072104155432038682511434979353089791861087415144087855679134383396897817458726543883093567600325204596156649305930352575274039425470836355002691145864435755333821133969266951545158052745938252574301327696822347115053614052423028835532509220641378760800693351542633860702225772638930501021571415907348128269681224178300248272689705308911282208685459668200507057183420662959113956077584781737983254788703048275698921427029884282557468334399677849962342196140864403989162117738206246183665814938783122909930082802031855</span><br><span class="line"></span><br><span class="line">n = 25033254625906757272369609119214202033162128625171246436639570615263949157363273213121556825878737923265290579551873824374870957467163989542063489416636713654642486717219231225074115269684119428086352535471683359486248203644461465935500517901513233739152882943010177276545128308412934555830087776128355125932914846459470221102007666912211992310538890654396487111705385730502843589727289829692152177134753098649781412247065660637826282055169991824099110916576856188876975621376606634258927784025787142263367152947108720757222446686415627479703666031871635656314282727051189190889008763055811680040315277078928068816491</span><br><span class="line">c = 4185308529416874005831230781014092407198451385955677399668501833902623478395669279404883990725184332709152443372583701076198786635291739356770857286702107156730020004358955622511061410661058982622055199736820808203841446796305284394651714430918690389486920560834672316158146453183789412140939029029324756035358081754426645160033262924330248675216108270980157049705488620263485129480952814764002865280019185127662449318324279383277766416258142275143923532168798413011028271543085249029048997452212503111742302302065401051458066585395360468447460658672952851643547193822775218387853623453638025492389122204507555908862</span><br><span class="line"></span><br><span class="line">n = 21206968097314131007183427944486801953583151151443627943113736996776787181111063957960698092696800555044199156765677935373149598221184792286812213294617749834607696302116136745662816658117055427803315230042700695125718401646810484873064775005221089174056824724922160855810527236751389605017579545235876864998419873065217294820244730785120525126565815560229001887622837549118168081685183371092395128598125004730268910276024806808565802081366898904032509920453785997056150497645234925528883879419642189109649009132381586673390027614766605038951015853086721168018787523459264932165046816881682774229243688581614306480751</span><br><span class="line">c = 4521038011044758441891128468467233088493885750850588985708519911154778090597136126150289041893454126674468141393472662337350361712212694867311622970440707727941113263832357173141775855227973742571088974593476302084111770625764222838366277559560887042948859892138551472680654517814916609279748365580610712259856677740518477086531592233107175470068291903607505799432931989663707477017904611426213770238397005743730386080031955694158466558475599751940245039167629126576784024482348452868313417471542956778285567779435940267140679906686531862467627238401003459101637191297209422470388121802536569761414457618258343550613</span><br><span class="line"></span><br><span class="line">n = 22822039733049388110936778173014765663663303811791283234361230649775805923902173438553927805407463106104699773994158375704033093471761387799852168337898526980521753614307899669015931387819927421875316304591521901592823814417756447695701045846773508629371397013053684553042185725059996791532391626429712416994990889693732805181947970071429309599614973772736556299404246424791660679253884940021728846906344198854779191951739719342908761330661910477119933428550774242910420952496929605686154799487839923424336353747442153571678064520763149793294360787821751703543288696726923909670396821551053048035619499706391118145067</span><br><span class="line">c = 15406498580761780108625891878008526815145372096234083936681442225155097299264808624358826686906535594853622687379268969468433072388149786607395396424104318820879443743112358706546753935215756078345959375299650718555759698887852318017597503074317356745122514481807843745626429797861463012940172797612589031686718185390345389295851075279278516147076602270178540690147808314172798987497259330037810328523464851895621851859027823681655934104713689539848047163088666896473665500158179046196538210778897730209572708430067658411755959866033531700460551556380993982706171848970460224304996455600503982223448904878212849412357</span><br><span class="line"></span><br><span class="line">n = 21574139855341432908474064784318462018475296809327285532337706940126942575349507668289214078026102682252713757703081553093108823214063791518482289846780197329821139507974763780260290309600884920811959842925540583967085670848765317877441480914852329276375776405689784571404635852204097622600656222714808541872252335877037561388406257181715278766652824786376262249274960467193961956690974853679795249158751078422296580367506219719738762159965958877806187461070689071290948181949561254144310776943334859775121650186245846031720507944987838489723127897223416802436021278671237227993686791944711422345000479751187704426369</span><br><span class="line">c = 20366856150710305124583065375297661819795242238376485264951185336996083744604593418983336285185491197426018595031444652123288461491879021096028203694136683203441692987069563513026001861435722117985559909692670907347563594578265880806540396777223906955491026286843168637367593400342814725694366078337030937104035993569672959361347287894143027186846856772983058328919716702982222142848848117768499996617588305301483085428547267337070998767412540225911508196842253134355901263861121500650240296746702967594224401650220168780537141654489215019142122284308116284129004257364769474080721001708734051264841350424152506027932</span><br><span class="line"></span><br><span class="line">n = 25360227412666612490102161131174584819240931803196448481224305250583841439581008528535930814167338381983764991296575637231916547647970573758269411168219302370541684789125112505021148506809643081950237623703181025696585998044695691322012183660424636496897073045557400768745943787342548267386564625462143150176113656264450210023925571945961405709276631990731602198104287528528055650050486159837612279600415259486306154947514005408907590083747758953115486124865486720633820559135063440942528031402951958557630833503775112010715604278114325528993771081233535247118481765852273252404963430792898948219539473312462979849137</span><br><span class="line">c = 19892772524651452341027595619482734356243435671592398172680379981502759695784087900669089919987705675899945658648623800090272599154590123082189645021800958076861518397325439521139995652026377132368232502108620033400051346127757698623886142621793423225749240286511666556091787851683978017506983310073524398287279737680091787333547538239920607761080988243639547570818363788673249582783015475682109984715293163137324439862838574460108793714172603672477766831356411304446881998674779501188163600664488032943639694828698984739492200699684462748922883550002652913518229322945040819064133350314536378694523704793396169065179</span><br><span class="line"></span><br><span class="line">n = 22726855244632356029159691753451822163331519237547639938779517751496498713174588935566576167329576494790219360727877166074136496129927296296996970048082870488804456564986667129388136556137013346228118981936899510687589585286517151323048293150257036847475424044378109168179412287889340596394755257704938006162677656581509375471102546261355748251869048003600520034656264521931808651038524134185732929570384705918563982065684145766427962502261522481994191989820110575981906998431553107525542001187655703534683231777988419268338249547641335718393312295800044734534761692799403469497954062897856299031257454735945867491191</span><br><span class="line">c = 6040119795175856407541082360023532204614723858688636724822712717572759793960246341800308149739809871234313049629732934797569781053000686185666374833978403290525072598774001731350244744590772795701065129561898116576499984185920661271123665356132719193665474235596884239108030605882777868856122378222681140570519180321286976947154042272622411303981011302586225630859892731724640574658125478287115198406253847367979883768000812605395482952698689604477719478947595442185921480652637868335673233200662100621025061500895729605305665864693122952557361871523165300206070325660353095592778037767395360329231331322823610060006</span><br><span class="line"></span><br><span class="line">n = 23297333791443053297363000786835336095252290818461950054542658327484507406594632785712767459958917943095522594228205423428207345128899745800927319147257669773812669542782839237744305180098276578841929496345963997512244219376701787616046235397139381894837435562662591060768476997333538748065294033141610502252325292801816812268934171361934399951548627267791401089703937389012586581080223313060159456238857080740699528666411303029934807011214953984169785844714159627792016926490955282697877141614638806397689306795328344778478692084754216753425842557818899467945102646776342655167655384224860504086083147841252232760941</span><br><span class="line">c = 5418120301208378713115889465579964257871814114515046096090960159737859076829258516920361577853903925954198406843757303687557848302302200229295916902430205737843601806700738234756698575708612424928480440868739120075888681672062206529156566421276611107802917418993625029690627196813830326369874249777619239603300605876865967515719079797115910578653562787899019310139945904958024882417833736304894765433489476234575356755275147256577387022873348906900149634940747104513850154118106991137072643308620284663108283052245750945228995387803432128842152251549292698947407663643895853432650029352092018372834457054271102816934</span><br><span class="line"></span><br><span class="line">n = 28873667904715682722987234293493200306976947898711255064125115933666968678742598858722431426218914462903521596341771131695619382266194233561677824357379805303885993804266436810606263022097900266975250431575654686915049693091467864820512767070713267708993899899011156106766178906700336111712803362113039613548672937053397875663144794018087017731949087794894903737682383916173267421403408140967713071026001874733487295007501068871044649170615709891451856792232315526696220161842742664778581287321318748202431466508948902745314372299799561625186955234673012098210919745879882268512656931714326782335211089576897310591491</span><br><span class="line">c = 9919880463786836684987957979091527477471444996392375244075527841865509160181666543016317634963512437510324198702416322841377489417029572388474450075801462996825244657530286107428186354172836716502817609070590929769261932324275353289939302536440310628698349244872064005700644520223727670950787924296004296883032978941200883362653993351638545860207179022472492671256630427228461852668118035317021428675954874947015197745916918197725121122236369382741533983023462255913924692806249387449016629865823316402366017657844166919846683497851842388058283856219900535567427103603869955066193425501385255322097901531402103883869</span><br><span class="line"></span><br><span class="line">n = 22324685947539653722499932469409607533065419157347813961958075689047690465266404384199483683908594787312445528159635527833904475801890381455653807265501217328757871352731293000303438205315816792663917579066674842307743845261771032363928568844669895768092515658328756229245837025261744260614860746997931503548788509983868038349720225305730985576293675269073709022350700836510054067641753713212999954307022524495885583361707378513742162566339010134354907863733205921845038918224463903789841881400814074587261720283879760122070901466517118265422863420376921536734845502100251460872499122236686832189549698020737176683019</span><br><span class="line">c = 1491527050203294989882829248560395184804977277747126143103957219164624187528441047837351263580440686474767380464005540264627910126483129930668344095814547592115061057843470131498075060420395111008619027199037019925701236660166563068245683975787762804359520164701691690916482591026138582705558246869496162759780878437137960823000043988227303003876410503121370163303711603359430764539337597866862508451528158285103251810058741879687875218384160282506172706613359477657215420734816049393339593755489218588796607060261897905233453268671411610631047340459487937479511933450369462213795738933019001471803157607791738538467</span><br><span class="line"></span><br><span class="line">n = 27646746423759020111007828653264027999257847645666129907789026054594393648800236117046769112762641778865620892443423100189619327585811384883515424918752749559627553637785037359639801125213256163008431942593727931931898199727552768626775618479833029101249692573716030706695702510982283555740851047022672485743432464647772882314215176114732257497240284164016914018689044557218920300262234652840632406067273375269301008409860193180822366735877288205783314326102263756503786736122321348320031950012144905869556204017430593656052867939493633163499580242224763404338807022510136217187779084917996171602737036564991036724299</span><br><span class="line">c = 21991524128957260536043771284854920393105808126700128222125856775506885721971193109361315961129190814674647136464887087893990660894961612838205086401018885457667488911898654270235561980111174603323721280911197488286585269356849579263043456316319476495888696219344219866516861187654180509247881251251278919346267129904739277386289240394384575124331135655943513831009934023397457082184699737734388823763306805326430395849935770213817533387235486307008892410920611669932693018165569417445885810825749609388627231235840912644654685819620931663346297596334834498661789016450371769203650109994771872404185770230172934013971</span><br><span class="line"></span><br><span class="line">n = 20545487405816928731738988374475012686827933709789784391855706835136270270933401203019329136937650878386117187776530639342572123237188053978622697282521473917978282830432161153221216194169879669541998840691383025487220850872075436064308499924958517979727954402965612196081404341651517326364041519250125036424822634354268773895465698920883439222996581226358595873993976604699830613932320720554130011671297944433515047180565484495191003887599891289037982010216357831078328159028953222056918189365840711588671093333013117454034313622855082795813122338562446223041211192277089225078324682108033843023903550172891959673551</span><br><span class="line">c = 14227439188191029461250476692790539654619199888487319429114414557975376308688908028140817157205579804059783807641305577385724758530138514972962209062230576107406142402603484375626077345190883094097636019771377866339531511965136650567412363889183159616188449263752475328663245311059988337996047359263288837436305588848044572937759424466586870280512424336807064729894515840552404756879590698797046333336445465120445087587621743906624279621779634772378802959109714400516183718323267273824736540168545946444437586299214110424738159957388350785999348535171553569373088251552712391288365295267665691357719616011613628772175</span><br><span class="line"></span><br><span class="line">n = 27359727711584277234897157724055852794019216845229798938655814269460046384353568138598567755392559653460949444557879120040796798142218939251844762461270251672399546774067275348291003962551964648742053215424620256999345448398805278592777049668281558312871773979931343097806878701114056030041506690476954254006592555275342579529625231194321357904668512121539514880704046969974898412095675082585315458267591016734924646294357666924293908418345508902112711075232047998775303603175363964055048589769318562104883659754974955561725694779754279606726358588862479198815999276839234952142017210593887371950645418417355912567987</span><br><span class="line">c = 3788529784248255027081674540877016372807848222776887920453488878247137930578296797437647922494510483767651150492933356093288965943741570268943861987024276610712717409139946409513963043114463933146088430004237747163422802959250296602570649363016151581364006795894226599584708072582696996740518887606785460775851029814280359385763091078902301957226484620428513604630585131511167015763190591225884202772840456563643159507805711004113901417503751181050823638207803533111429510911616160851391754754434764819568054850823810901159821297849790005646102129354035735350124476838786661542089045509656910348676742844957008857457</span><br><span class="line"></span><br><span class="line">n = 27545937603751737248785220891735796468973329738076209144079921449967292572349424539010502287564030116831261268197384650511043068738911429169730640135947800885987171539267214611907687570587001933829208655100828045651391618089603288456570334500533178695238407684702251252671579371018651675054368606282524673369983034682330578308769886456335818733827237294570476853673552685361689144261552895758266522393004116017849397346259119221063821663280935820440671825601452417487330105280889520007917979115568067161590058277418371493228631232457972494285014767469893647892888681433965857496916110704944758070268626897045014782837</span><br><span class="line">c = 14069112970608895732417039977542732665796601893762401500878786871680645798754783315693511261740059725171342404186571066972546332813667711135661176659424619936101038903439144294886379322591635766682645179888058617577572409307484708171144488708410543462972008179994594087473935638026612679389759756811490524127195628741262871304427908481214992471182859308828778119005750928935764927967212343526503410515793717201360360437981322576798056276657140363332700714732224848346808963992302409037706094588964170239521193589470070839790404597252990818583717869140229811712295005710540476356743378906642267045723633874011649259842</span><br><span class="line"></span><br><span class="line">n = 25746162075697911560263181791216433062574178572424600336856278176112733054431463253903433128232709054141607100891177804285813783247735063753406524678030561284491481221681954564804141454666928657549670266775659862814924386584148785453647316864935942772919140563506305666207816897601862713092809234429096584753263707828899780979223118181009293655563146526792388913462557306433664296966331469906428665127438829399703002867800269947855869262036714256550075520193125987011945192273531732276641728008406855871598678936585324782438668746810516660152018244253008092470066555687277138937298747951929576231036251316270602513451</span><br><span class="line">c = 17344284860275489477491525819922855326792275128719709401292545608122859829827462088390044612234967551682879954301458425842831995513832410355328065562098763660326163262033200347338773439095709944202252494552172589503915965931524326523663289777583152664722241920800537867331030623906674081852296232306336271542832728410803631170229642717524942332390842467035143631504401140727083270732464237443915263865880580308776111219718961746378842924644142127243573824972533819479079381023103585862099063382129757560124074676150622288706094110075567706403442920696472627797607697962873026112240527498308535903232663939028587036724</span><br><span class="line"></span><br><span class="line">n = 23288486934117120315036919418588136227028485494137930196323715336208849327833965693894670567217971727921243839129969128783853015760155446770590696037582684845937132790047363216362087277861336964760890214059732779383020349204803205725870225429985939570141508220041286857810048164696707018663758416807708910671477407366098883430811861933014973409390179948577712579749352299440310543689035651465399867908428885541237776143404376333442949397063249223702355051571790555151203866821867908531733788784978667478707672984539512431549558672467752712004519300318999208102076732501412589104904734983789895358753664077486894529499</span><br><span class="line">c = 10738254418114076548071448844964046468141621740603214384986354189105236977071001429271560636428075970459890958274941762528116445171161040040833357876134689749846940052619392750394683504816081193432350669452446113285638982551762586656329109007214019944975816434827768882704630460001209452239162896576191876324662333153835533956600295255158377025198426950944040643235430211011063586032467724329735785947372051759042138171054165854842472990583800899984893232549092766400510300083585513014171220423103452292891496141806956300396540682381668367564569427813092064053993103537635994311143010708814851867239706492577203899024</span><br><span class="line"></span><br><span class="line">n = 19591441383958529435598729113936346657001352578357909347657257239777540424811749817783061233235817916560689138344041497732749011519736303038986277394036718790971374656832741054547056417771501234494768509780369075443550907847298246275717420562375114406055733620258777905222169702036494045086017381084272496162770259955811174440490126514747876661317750649488774992348005044389081101686016446219264069971370646319546429782904810063020324704138495608761532563310699753322444871060383693044481932265801505819646998535192083036872551683405766123968487907648980900712118052346174533513978009131757167547595857552370586353973</span><br><span class="line">c = 3834917098887202931981968704659119341624432294759361919553937551053499607440333234018189141970246302299385742548278589896033282894981200353270637127213483172182529890495903425649116755901631101665876301799865612717750360089085179142750664603454193642053016384714515855868368723508922271767190285521137785688075622832924829248362774476456232826885801046969384519549385428259591566716890844604696258783639390854153039329480726205147199247183621535172450825979047132495439603840806501254997167051142427157381799890725323765558803808030109468048682252028720241357478614704610089120810367192414352034177484688502364022887</span><br><span class="line"></span><br><span class="line">n = 19254242571588430171308191757871261075358521158624745702744057556054652332495961196795369630484782930292003238730267396462491733557715379956969694238267908985251699834707734400775311452868924330866502429576951934279223234676654749272932769107390976321208605516299532560054081301829440688796904635446986081691156842271268059970762004259219036753174909942343204432795076377432107630203621754552804124408792358220071862369443201584155711893388877350138023238624566616551246804054720492816226651467017802504094070614892556444425915920269485861799532473383304622064493223627552558344088839860178294589481899206318863310603</span><br><span class="line">c = 6790553533991297205804561991225493105312398825187682250780197510784765226429663284220400480563039341938599783346724051076211265663468643826430109013245014035811178295081939958687087477312867720289964506097819762095244479129359998867671811819738196687884696680463458661374310994610760009474264115750204920875527434486437536623589684519411519100170291423367424938566820315486507444202022408003879118465761273916755290898112991525546114191064022991329724370064632569903856189236177894007766690782630247443895358893983735822824243487181851098787271270256780891094405121947631088729917398317652320497765101790132679171889</span><br><span class="line"></span><br><span class="line">n = 26809700251171279102974962949184411136459372267620535198421449833298448092580497485301953796619185339316064387798092220298630428207556482805739803420279056191194360049651767412572609187680508073074653291350998253938793269214230457117194434853888765303403385824786231859450351212449404870776320297419712486574804794325602760347306432927281716160368830187944940128907971027838510079519466846176106565164730963988892400240063089397720414921398936399927948235195085202171264728816184532651138221862240969655185596628285814057082448321749567943946273776184657698104465062749244327092588237927996419620170254423837876806659</span><br><span class="line">c = 386213556608434013769864727123879412041991271528990528548507451210692618986652870424632219424601677524265011043146748309774067894985069288067952546139416819404039688454756044862784630882833496090822568580572859029800646671301748901528132153712913301179254879877441322285914544974519727307311002330350534857867516466612474769753577858660075830592891403551867246057397839688329172530177187042229028685862036140779065771061933528137423019407311473581832405899089709251747002788032002094495379614686544672969073249309703482556386024622814731015767810042969813752548617464974915714425595351940266077021672409858645427346</span><br></pre></td></tr></table></figure>

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>每两个n求一次公约数，看看是否有不为1的一组n，如果有的话，p就是这个公约数，之后就可以求其他量了</p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">n = [n0,n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14,n15,n16,n17,n18,n19]</span><br><span class="line">c = [c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(n)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(n)):</span><br><span class="line">        <span class="keyword">if</span> (i!=j):</span><br><span class="line">            t = gmpy2.gcd(n[i],n[j])</span><br><span class="line">            <span class="keyword">if</span> t != <span class="number">1</span>:</span><br><span class="line">                p = t</span><br><span class="line">                q = n[i] // p</span><br><span class="line">                d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">                m = <span class="built_in">pow</span>(c[i],d,n[i])</span><br><span class="line">                <span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line">                </span><br><span class="line"><span class="comment">#flag&#123;abdcbe5fd94e23b3de429223ab9c2fdf&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="第二种情况-孙子定理"><a href="#第二种情况-孙子定理" class="headerlink" title="第二种情况 孙子定理"></a>第二种情况 孙子定理</h2><p><img src="/../images/RSA/8.png"></p>
<p><strong>在张秀平老师那里学的方法是列个表</strong></p>
<table>
<thead>
<tr>
<th align="center">除数</th>
<th align="center">余数</th>
<th align="center">最小公倍数</th>
<th align="center">衍数</th>
<th align="center">乘率</th>
<th align="center">各总</th>
<th align="center">答数</th>
<th align="center">最小答数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">105</td>
<td align="center">35</td>
<td align="center">2</td>
<td align="center">140</td>
<td align="center">233</td>
<td align="center">23</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">3</td>
<td align="center">105</td>
<td align="center">21</td>
<td align="center">1</td>
<td align="center">63</td>
<td align="center">233</td>
<td align="center">23</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">2</td>
<td align="center">105</td>
<td align="center">15</td>
<td align="center">1</td>
<td align="center">30</td>
<td align="center">233</td>
<td align="center">23</td>
</tr>
</tbody></table>
<p><strong>衍数</strong>：本除数之外的除数之和，eg:除数3的衍数为5×7<br>$$<br>衍数×x \equiv 1\mod 除数<br>$$<br><strong>乘率：</strong>是上式的解<br>$$<br>3的乘率是\\<br>$$</p>
<p>$$<br>35x \equiv 1\mod 3的解，即2<br>$$</p>
<p><strong>各总</strong>：衍数，乘率，余数之积。eg:3的各总是35×2×2&#x3D;140</p>
<p><strong>答数</strong>：各总之和</p>
<p><strong>最小答数：</strong>答数对最小公倍数的余数，eg:<br>$$<br>233 \equiv x \mod 105<br>$$<br><strong>其中x&#x3D;23</strong></p>
<h3 id="关于孙子定理的求解"><a href="#关于孙子定理的求解" class="headerlink" title="关于孙子定理的求解"></a>关于孙子定理的求解</h3><p>推广到一般情况</p>
<p><img src="/../images/RSA/9.png"></p>
<p>用同样的方法列个表</p>
<p><img src="/../images/RSA/%E5%88%97%E8%A1%A8%E8%A7%A3%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86.jpg"></p>
<p><img src="/../images/RSA/10.png"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Get_Mi</span>(<span class="params">m_list,m</span>):               <span class="comment">#求衍数</span></span><br><span class="line">    M_list = []</span><br><span class="line">    <span class="keyword">for</span> mi <span class="keyword">in</span> m_list:</span><br><span class="line">        M_list.append(m // mi)</span><br><span class="line">    <span class="keyword">return</span> M_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Get_resMi</span>(<span class="params">M_list,m_list</span>):       <span class="comment">#求乘率</span></span><br><span class="line">    resM_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(M_list)):</span><br><span class="line">        resM_list.append(gmpy2.invert(M_list[i],m_list[i]))</span><br><span class="line">    <span class="keyword">return</span> resM_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Get_result</span>(<span class="params">a_list</span>):				<span class="comment">#求答数</span></span><br><span class="line">    M_list = Get_Mi(m_list,m)</span><br><span class="line">    resM_list = Get_resMi(M_list,m_list)</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(M_list)):</span><br><span class="line">        result += M_list[i]*resM_list[i]*a_list[i]</span><br><span class="line">    result %= m						<span class="comment">#最小答数</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">m_list = [...]</span><br><span class="line">a_list = [...]</span><br><span class="line"></span><br><span class="line">m = <span class="number">1</span>								<span class="comment">#求最小公倍数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m_list:</span><br><span class="line">    m *= i</span><br><span class="line"></span><br><span class="line">result = Get_result(a_list)</span><br></pre></td></tr></table></figure>

<h3 id="例题1-1"><a href="#例题1-1" class="headerlink" title="例题1"></a>例题1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import gmpy2</span><br><span class="line">import random</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line"></span><br><span class="line">p = libnum.generate_prime(1024)</span><br><span class="line">q = libnum.generate_prime(1024)</span><br><span class="line">n1 = p * q</span><br><span class="line">p = libnum.generate_prime(1024)</span><br><span class="line">q = libnum.generate_prime(1024)</span><br><span class="line">n2 = p * q</span><br><span class="line">p = libnum.generate_prime(1024)</span><br><span class="line">q = libnum.generate_prime(1024)</span><br><span class="line">n3 = p * q</span><br><span class="line">while 1:</span><br><span class="line">    e = random.randint(10, 20)</span><br><span class="line">    print(e)</span><br><span class="line">    if gmpy2.is_prime(e):</span><br><span class="line">        break</span><br><span class="line">c1 = pow(m, e, n1)</span><br><span class="line">c2 = pow(m, e, n2)</span><br><span class="line">c3 = pow(m, e, n3)</span><br><span class="line"></span><br><span class="line">print(&quot;n1=&quot;, n1)</span><br><span class="line">print(&quot;n2=&quot;, n2)</span><br><span class="line">print(&quot;n3=&quot;, n3)</span><br><span class="line"></span><br><span class="line">print(&quot;c1=&quot;, c1)</span><br><span class="line">print(&quot;c2=&quot;, c2)</span><br><span class="line">print(&quot;c3=&quot;, c3)</span><br></pre></td></tr></table></figure>

<p><strong>先根据中国剩余定理求出$m^e$，这题的e只给范围，要爆破一下</strong></p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Get_Mi</span>(<span class="params">m_list,m</span>):               <span class="comment">#求衍数</span></span><br><span class="line">    M_list = []</span><br><span class="line">    <span class="keyword">for</span> mi <span class="keyword">in</span> m_list:</span><br><span class="line">        M_list.append(m // mi)</span><br><span class="line">    <span class="keyword">return</span> M_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Get_resMi</span>(<span class="params">M_list,m_list</span>):       <span class="comment">#求乘率</span></span><br><span class="line">    resM_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(M_list)):</span><br><span class="line">        resM_list.append(gmpy2.invert(M_list[i],m_list[i]))</span><br><span class="line">    <span class="keyword">return</span> resM_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Get_result</span>(<span class="params">a_list</span>):</span><br><span class="line">    M_list = Get_Mi(m_list,m)</span><br><span class="line">    resM_list = Get_resMi(M_list,m_list)</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(M_list)):</span><br><span class="line">        result += M_list[i]*resM_list[i]*a_list[i]</span><br><span class="line">    result %= m</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">n1 = <span class="number">16655230929893303490818415854457831426545038662809855283873228642358207995734291242944120042612699642460820594813654718158395826755230956722936107927889550129166619245152453353908373751380196656611349200623414836128383308653618062999595622747482867683840133843768870236300348203389275090871132570173650238774275209757683812077533989960172822335488251744796657926473009279723460304257252876756936524918018903158795894385111046938638194925881670388700872760201130485273663156422785999102754192840209476417602399017445296045070405343876349687582470436774316410697773759057621576657298096301937899052773787116133124199739</span></span><br><span class="line">n2 = <span class="number">17197151926745749646602149115445210421300330711044282276861045275221683290586877554048509794473112203880585601275129330843554946888863132721219683639579200702355880529569042889789589005950061966309684759066705732225014741164779016525568884409690021988879475589545329149547046975086877521757237117008484775731784935960191717287332176327498377273179740487245459081737196777751408106728622513560888261855065717079007065635401835089216224111969668029246916986663313301660909538148574652809266532053889578734157117390082522831069594417637550812101652367765364077901612478983024721669687150628356918237152414368862535409859</span></span><br><span class="line">n3 = <span class="number">18719461901666732419189610536735130974364055134601694187780706398369536769336080321122034942831217438281120989017698755904233940669427542442488330152862658754609065361849067002424120904308655036927580582916373684567047102601602588472175947665724244201887952599804681827419266055359412641159981152796138695901074514583606207162167385730873921563442166111892785482387108299191119048884993267729877797586421940344366636285656854837470348603688925980178978612114344024951042846249621559376348599687263736342957456838732355009637030035658212442442824658869094581324944034490700706979663405137522294780606800571433058912041</span></span><br><span class="line"></span><br><span class="line">c1 = <span class="number">3530761236149189046680124371485374220252032991305088864647979778627799354583229731576585900490173357726425570018182390597284149666834264690795437972634538596441103368165128688664787322126097802985602065455316693754513332761284857157982201975554297034291092099307950246864758375115838291339394148547902128382917596947095456178572561422004708150053706114994560773293625641699691472764190426577272488084620105693964419578988589192873196530900413833531923536786853211065167782657153004342018675666293830194703777994380600060782651326623229047839109994778831432598543154184891096335217588164509636922274833553782288823349</span></span><br><span class="line">c2 = <span class="number">7557835478962501903223351987016911891266554255050134264644805724502475848487138948948076311894495847429608136390014902405718084026208891531815323418707377349405409096779206918831458396991602033494429461919844309109113047361743133772636443322195238900874786548606687215969337920658068807801603115402783849082788527952834594443136756890747461628705174983562847145588532659589787532039981477468881131005056101092222499397893730056830156407331988257383965698358904379729558105489119604343081747549319382873235286788453435066434264212954607441597606413293491628299838317713381567250093086011058119721189087729804152444980</span></span><br><span class="line">c3 =<span class="number">8471234074077377509408346140986116360421840978074779990698043926601850838824365885362094731657766299393262223086536737448516669969503891677808275285733096884405583100485903641986516527279324847718603091709062689898441711907846902050004165404073776422495381050861998133576074526490209080137421773440295749900582039873013319584167081936219517593826232230971430937112005615502869367413205660317010303160932970748420125111225082886082306332340892549579826854620461821084886193470846195356695313518639669516456574134135244251956477677377976434266541164893562226872334598362396368708087248848222008201970781942468960022694</span></span><br><span class="line"></span><br><span class="line">m_list= [n1,n2,n3]</span><br><span class="line">a_list= [c1,c2,c3]</span><br><span class="line"></span><br><span class="line">m = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m_list:</span><br><span class="line">    m *= i</span><br><span class="line"></span><br><span class="line">result = Get_result(a_list)</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>,<span class="number">20</span>):</span><br><span class="line">    m = gmpy2.iroot(result,e)</span><br><span class="line">    <span class="keyword">if</span> m[<span class="number">1</span>]:</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(m[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<h3 id="例题2-鹤城杯2021——Crazy-Tech-RSA"><a href="#例题2-鹤城杯2021——Crazy-Tech-RSA" class="headerlink" title="例题2 鹤城杯2021——Crazy_Tech_RSA"></a>例题2 鹤城杯2021——Crazy_Tech_RSA</h3><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from Crypto.Util.Padding import *</span><br><span class="line"></span><br><span class="line">FLAG = bytes_to_long(pad(b&quot;flag&#123;??????&#125;&quot;,64))</span><br><span class="line">def init_key():</span><br><span class="line">    p, q = getPrime(512), getPrime(512)</span><br><span class="line">    n = p*q</span><br><span class="line">    e = 9</span><br><span class="line">    while(GCD((p-1)*(q-1),e)!=1):</span><br><span class="line">        p, q = getPrime(512), getPrime(512)</span><br><span class="line">        n = p*q</span><br><span class="line">    d = inverse(e,(p-1)*(q-1))</span><br><span class="line">    return n,e,d</span><br><span class="line"></span><br><span class="line">n_list=list()</span><br><span class="line">c_list=list()</span><br><span class="line">for i in range(9):</span><br><span class="line">    N,e,d=init_key()</span><br><span class="line">    n_list.append(N)</span><br><span class="line">    c=pow(FLAG,e,N)</span><br><span class="line">    c_list.append(pow(FLAG,e,N))</span><br><span class="line">    assert(pow(c,d,N)==FLAG)</span><br><span class="line">print(&quot;n_list:&quot;,n_list)</span><br><span class="line">print(&quot;c_list:&quot;,c_list)</span><br></pre></td></tr></table></figure>

<p>先用中国剩余定理解出$m^e$</p>
<p><strong>再开根号</strong></p>
<p>这道题的e是给出，如果e没有给出的话，需要爆破e</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Get_Mi</span>(<span class="params">m_list,m</span>):               <span class="comment">#求衍数</span></span><br><span class="line">    M_list = []</span><br><span class="line">    <span class="keyword">for</span> mi <span class="keyword">in</span> m_list:</span><br><span class="line">        M_list.append(m // mi)</span><br><span class="line">    <span class="keyword">return</span> M_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Get_resMi</span>(<span class="params">M_list,m_list</span>):       <span class="comment">#求乘率</span></span><br><span class="line">    resM_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(M_list)):</span><br><span class="line">        resM_list.append(gmpy2.invert(M_list[i],m_list[i]))</span><br><span class="line">    <span class="keyword">return</span> resM_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Get_result</span>(<span class="params">a_list</span>):</span><br><span class="line">    M_list = Get_Mi(m_list,m)</span><br><span class="line">    resM_list = Get_resMi(M_list,m_list)</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(M_list)):</span><br><span class="line">        result += M_list[i]*resM_list[i]*a_list[i]</span><br><span class="line">    result %= m</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">m_list=[<span class="number">71189786319102608575263218254922479901008514616376166401353025325668690465852130559783959409002115897148828732231478529655075366072137059589917001875303598680931962384468363842379833044123189276199264340224973914079447846845897807085694711541719515881377391200011269924562049643835131619086349617062034608799</span>, <span class="number">92503831027754984321994282254005318198418454777812045042619263533423066848097985191386666241913483806726751133691867010696758828674382946375162423033994046273252417389169779506788545647848951018539441971140081528915876529645525880324658212147388232683347292192795975558548712504744297104487514691170935149949</span>, <span class="number">100993952830138414466948640139083231443558390127247779484027818354177479632421980458019929149817002579508423291678953554090956334137167905685261724759487245658147039684536216616744746196651390112540237050493468689520465897258378216693418610879245129435268327315158194612110422630337395790254881602124839071919</span>, <span class="number">59138293747457431012165762343997972673625934330232909935732464725128776212729547237438509546925172847581735769773563840639187946741161318153031173864953372796950422229629824699580131369991913883136821374596762214064774480548532035315344368010507644630655604478651898097886873485265848973185431559958627423847</span>, <span class="number">66827868958054485359731420968595906328820823695638132426084478524423658597714990545142120448668257273436546456116147999073797943388584861050133103137697812149742551913704341990467090049650721713913812069904136198912314243175309387952328961054617877059134151915723594900209641163321839502908705301293546584147</span>, <span class="number">120940513339890268554625391482989102665030083707530690312336379356969219966820079510946652021721814016286307318930536030308296265425674637215009052078834615196224917417698019787514831973471113022781129000531459800329018133248426080717653298100515701379374786486337920294380753805825328119757649844054966712377</span>, <span class="number">72186594495190221129349814154999705524005203343018940547856004977368023856950836974465616291478257156860734574686154136925776069045232149725101769594505766718123155028300703627531567850035682448632166309129911061492630709698934310123778699316856399909549674138453085885820110724923723830686564968967391721281</span>, <span class="number">69105037583161467265649176715175579387938714721653281201847973223975467813529036844308693237404592381480367515044829190066606146105800243199497182114398931410844901178842049915914390117503986044951461783780327749665912369177733246873697481544777183820939967036346862056795919812693669387731294595126647751951</span>, <span class="number">76194219445824867986050004226602973283400885106636660263597964027139613163638212828932901192009131346530898961165310615466747046710743013409318156266326090650584190382130795884514074647833949281109675170830565650006906028402714868781834693473191228256626654011772428115359653448111208831188721505467497494581</span>]</span><br><span class="line">a_list=[<span class="number">62580922178008480377006528793506649089253164524883696044759651305970802215270721223149734532870729533611357047595181907404222690394917605617029675103788705320032707977225447998111744887898039756375876685711148857676502670812333076878964148863713993853526715855758799502735753454247721711366497722251078739585</span>, <span class="number">46186240819076690248235492196228128599822002268014359444368898414937734806009161030424589993541799877081745454934484263188270879142125136786221625234555265815513136730416539407710862948861531339065039071959576035606192732936477944770308784472646015244527805057990939765708793705044236665364664490419874206900</span>, <span class="number">85756449024868529058704599481168414715291172247059370174556127800630896693021701121075838517372920466708826412897794900729896389468152213884232173410022054605870785910461728567377769960823103334874807744107855490558726013068890632637193410610478514663078901021307258078678427928255699031215654693270240640198</span>, <span class="number">14388767329946097216670270960679686032536707277732968784379505904021622612991917314721678940833050736745004078559116326396233622519356703639737886289595860359630019239654690312132039876082685046329079266785042428947147658321799501605837784127004536996628492065409017175037161261039765340032473048737319069656</span>, <span class="number">1143736792108232890306863524988028098730927600066491485326214420279375304665896453544100447027809433141790331191324806205845009336228331138326163746853197990596700523328423791764843694671580875538251166864957646807184041817863314204516355683663859246677105132100377322669627893863885482167305919925159944839</span>, <span class="number">2978800921927631161807562509445310353414810029862911925227583943849942080514132963605492727604495513988707849133045851539412276254555228149742924149242124724864770049898278052042163392380895275970574317984638058768854065506927848951716677514095183559625442889028813635385408810698294574175092159389388091981</span>, <span class="number">16200944263352278316040095503540249310705602580329203494665614035841657418101517016718103326928336623132935178377208651067093136976383774189554806135146237406248538919915426183225265103769259990252162411307338473817114996409705345401251435268136647166395894099897737607312110866874944619080871831772376466376</span>, <span class="number">31551601425575677138046998360378916515711528548963089502535903329268089950335615563205720969393649713416910860593823506545030969355111753902391336139384464585775439245735448030993755229554555004154084649002801255396359097917380427525820249562148313977941413268787799534165652742114031759562268691233834820996</span>, <span class="number">25288164985739570635307839193110091356864302148147148153228604718807817833935053919412276187989509493755136905193728864674684139319708358686431424793278248263545370628718355096523088238513079652226028236137381367215156975121794485995030822902933639803569133458328681148758392333073624280222354763268512333515</span>]</span><br><span class="line"></span><br><span class="line">m = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m_list:</span><br><span class="line">    m *= i</span><br><span class="line"></span><br><span class="line">result = Get_result(a_list)</span><br><span class="line">e = <span class="number">9</span></span><br><span class="line">m = gmpy2.iroot(result,e)</span><br><span class="line"><span class="keyword">if</span> m[<span class="number">1</span>]:</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<h3 id="例题3-攻防世界——OldDriver"><a href="#例题3-攻防世界——OldDriver" class="headerlink" title="例题3 攻防世界——OldDriver"></a>例题3 攻防世界——OldDriver</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Get_Mi</span>(<span class="params">m_list,m</span>):               <span class="comment">#求衍数</span></span><br><span class="line">    M_list = []</span><br><span class="line">    <span class="keyword">for</span> mi <span class="keyword">in</span> m_list:</span><br><span class="line">        M_list.append(m // mi)</span><br><span class="line">    <span class="keyword">return</span> M_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Get_resMi</span>(<span class="params">M_list,m_list</span>):       <span class="comment">#求乘率</span></span><br><span class="line">    resM_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(M_list)):</span><br><span class="line">        resM_list.append(gmpy2.invert(M_list[i],m_list[i]))</span><br><span class="line">    <span class="keyword">return</span> resM_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Get_result</span>(<span class="params">a_list</span>):</span><br><span class="line">    M_list = Get_Mi(m_list,m)</span><br><span class="line">    resM_list = Get_resMi(M_list,m_list)</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(M_list)):</span><br><span class="line">        result += M_list[i]*resM_list[i]*a_list[i]</span><br><span class="line">    result %= m</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">m_list=[<span class="number">25162507052339714421839688873734596177751124036723831003300959761137811490715205742941738406548150240861779301784133652165908227917415483137585388986274803</span>,<span class="number">23976859589904419798320812097681858652325473791891232710431997202897819580634937070900625213218095330766877190212418023297341732808839488308551126409983193</span>,<span class="number">18503782836858540043974558035601654610948915505645219820150251062305120148745545906567548650191832090823482852604346478335353784501076761922605361848703623</span>,<span class="number">23383087478545512218713157932934746110721706819077423418060220083657713428503582801909807142802647367994289775015595100541168367083097506193809451365010723</span>,<span class="number">31775649089861428671057909076144152870796722528112580479442073365053916012507273433028451755436987054722496057749731758475958301164082755003195632005308493</span>,<span class="number">22246342022943432820696190444155665289928378653841172632283227888174495402248633061010615572642126584591103750338919213945646074833823905521643025879053949</span>,<span class="number">25395461142670631268156106136028325744393358436617528677967249347353524924655001151849544022201772500033280822372661344352607434738696051779095736547813043</span>,<span class="number">32056508892744184901289413287728039891303832311548608141088227876326753674154124775132776928481935378184756756785107540781632570295330486738268173167809047</span>,<span class="number">52849766269541827474228189428820648574162539595985395992261649809907435742263020551050064268890333392877173572811691599841253150460219986817964461970736553</span>,<span class="number">30415984800307578932946399987559088968355638354344823359397204419191241802721772499486615661699080998502439901585573950889047918537906687840725005496238621</span>]</span><br><span class="line">a_list=[<span class="number">7366067574741171461722065133242916080495505913663250330082747465383676893970411476550748394841437418105312353971095003424322679616940371123028982189502042</span>,<span class="number">21962825323300469151795920289886886562790942771546858500842179806566435767103803978885148772139305484319688249368999503784441507383476095946258011317951461</span>,<span class="number">6569689420274066957835983390583585286570087619048110141187700584193792695235405077811544355169290382357149374107076406086154103351897890793598997687053983</span>,<span class="number">4508246168044513518452493882713536390636741541551805821790338973797615971271867248584379813114125478195284692695928668946553625483179633266057122967547052</span>,<span class="number">22966105670291282335588843018244161552764486373117942865966904076191122337435542553276743938817686729554714315494818922753880198945897222422137268427611672</span>,<span class="number">17963313063405045742968136916219838352135561785389534381262979264585397896844470879023686508540355160998533122970239261072020689217153126649390825646712087</span>,<span class="number">1652417534709029450380570653973705320986117679597563873022683140800507482560482948310131540948227797045505390333146191586749269249548168247316404074014639</span>,<span class="number">15585771734488351039456631394040497759568679429510619219766191780807675361741859290490732451112648776648126779759368428205194684721516497026290981786239352</span>,<span class="number">8965123421637694050044216844523379163347478029124815032832813225050732558524239660648746284884140746788823681886010577342254841014594570067467905682359797</span>,<span class="number">13560945756543023008529388108446940847137853038437095244573035888531288577370829065666320069397898394848484847030321018915638381833935580958342719988978247</span>]</span><br><span class="line"></span><br><span class="line">m = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m_list:</span><br><span class="line">    m *= i</span><br><span class="line"></span><br><span class="line">result = Get_result(a_list)</span><br><span class="line">e = <span class="number">10</span></span><br><span class="line">m = gmpy2.iroot(result,e)</span><br><span class="line"><span class="keyword">if</span> m[<span class="number">1</span>]:</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<h1 id="六、维纳攻击"><a href="#六、维纳攻击" class="headerlink" title="六、维纳攻击"></a>六、维纳攻击</h1><p>需要运用到连分数的知识，暂时没学，先搁在这里</p>
<p>分享一个题目和脚本</p>
<h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import random</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line"># 生成随机素数</span><br><span class="line">p = libnum.generate_prime(512)</span><br><span class="line">q = libnum.generate_prime(512)</span><br><span class="line">m = &quot;flag&#123;20d6e2da95dcc1fa5f5432a436c4be18&#125;&quot;</span><br><span class="line"># 字符串转数字</span><br><span class="line">m = libnum.s2n(m)</span><br><span class="line">n = p * q</span><br><span class="line">phi_n = (p - 1) * (q - 1)</span><br><span class="line"></span><br><span class="line"># 计算d</span><br><span class="line">while True:</span><br><span class="line">    nbits = 1024</span><br><span class="line">    d = random.getrandbits(nbits // 4)</span><br><span class="line">    if (libnum.gcd(d, phi_n) == 1 and 36 * pow(d, 4) &lt; n):</span><br><span class="line">        break</span><br><span class="line"># 计算e</span><br><span class="line">e = libnum.invmod(d, phi_n)</span><br><span class="line"></span><br><span class="line">c = pow(m, e, n)</span><br><span class="line"></span><br><span class="line">print(&quot;n=&quot;, n)</span><br><span class="line">print(&quot;e=&quot;, e)</span><br><span class="line">print(&quot;c=&quot;, c)</span><br></pre></td></tr></table></figure>

<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">continuedFra</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算连分数</span></span><br><span class="line"><span class="string">    :param x: 分子</span></span><br><span class="line"><span class="string">    :param y: 分母</span></span><br><span class="line"><span class="string">    :return: 连分数列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cf = []</span><br><span class="line">    <span class="keyword">while</span> y:</span><br><span class="line">        cf.append(x // y)</span><br><span class="line">        x, y = y, x % y</span><br><span class="line">    <span class="keyword">return</span> cf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradualFra</span>(<span class="params">cf</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算传入列表最后的渐进分数</span></span><br><span class="line"><span class="string">    :param cf: 连分数列表</span></span><br><span class="line"><span class="string">    :return: 该列表最后的渐近分数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    numerator = <span class="number">0</span></span><br><span class="line">    denominator = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> cf[::-<span class="number">1</span>]:</span><br><span class="line">        <span class="comment"># 这里的渐进分数分子分母要分开</span></span><br><span class="line">        numerator, denominator = denominator, x * denominator + numerator</span><br><span class="line">    <span class="keyword">return</span> numerator, denominator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve_pq</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用韦达定理解出pq，x^2−(p+q)∗x+pq=0</span></span><br><span class="line"><span class="string">    :param a:x^2的系数</span></span><br><span class="line"><span class="string">    :param b:x的系数</span></span><br><span class="line"><span class="string">    :param c:pq</span></span><br><span class="line"><span class="string">    :return:p，q</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    par = gmpy2.isqrt(b * b - <span class="number">4</span> * a * c)</span><br><span class="line">    <span class="keyword">return</span> (-b + par) // (<span class="number">2</span> * a), (-b - par) // (<span class="number">2</span> * a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getGradualFra</span>(<span class="params">cf</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算列表所有的渐近分数</span></span><br><span class="line"><span class="string">    :param cf: 连分数列表</span></span><br><span class="line"><span class="string">    :return: 该列表所有的渐近分数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    gf = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(cf) + <span class="number">1</span>):</span><br><span class="line">        gf.append(gradualFra(cf[:i]))</span><br><span class="line">    <span class="keyword">return</span> gf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wienerAttack</span>(<span class="params">e, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param e:</span></span><br><span class="line"><span class="string">    :param n:</span></span><br><span class="line"><span class="string">    :return: 私钥d</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cf = continuedFra(e, n)</span><br><span class="line">    gf = getGradualFra(cf)</span><br><span class="line">    <span class="keyword">for</span> d, k <span class="keyword">in</span> gf:</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> (e * d - <span class="number">1</span>) % k != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        phi = (e * d - <span class="number">1</span>) // k</span><br><span class="line">        p, q = solve_pq(<span class="number">1</span>, n - phi + <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> p * q == n:</span><br><span class="line">            <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="number">113881698992379349039968368927979997900777221951663104697020683691495129639829918739755194174063944178083527489820939138302751895652076620380510013941997706327553964127612610209509889011613768847759318892303231846117914554931459295347697888260576901354448014917692680573408654658384481284699735788978230690197</span></span><br><span class="line">e = <span class="number">39068960413447607023613035707248214114819409621234801785480423979473767995171860917209502861408393208940683687475760366491413173744775811644295874981290403938714121977201901942939425294427737703229098649131737380098596135730392902019429964095866394165971291108245774407908011073271822915371753470010435225545</span></span><br><span class="line">c = <span class="number">32897925577913728659288168937025744709859960639901500169867896018406263110205704273203287172003057450591000201857719871686024077615520906540631374442504017489026298422189715372129838501090730593164075113452055617571409044743698645392909829425374093273187125709095368164744188182156849031225036001381531504057</span></span><br><span class="line"></span><br><span class="line">d = wienerAttack(e, n)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line"><span class="built_in">print</span>(libnum.n2s(m).decode())</span><br></pre></td></tr></table></figure>



<h1 id="七、共享素数"><a href="#七、共享素数" class="headerlink" title="七、共享素数"></a>七、共享素数</h1><p>两个n有相同的因子</p>
<h2 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h2><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">p = libnum.generate_prime(1024)</span><br><span class="line">q1 = libnum.generate_prime(1024)</span><br><span class="line">q2 = libnum.generate_prime(1024)</span><br><span class="line">n1 = p * q1</span><br><span class="line">n2 = p * q2</span><br><span class="line">e = 65537</span><br><span class="line">c1 = pow(m, e, n1)</span><br><span class="line">c2 = pow(m, e, n2)</span><br><span class="line">print(&quot;n1=&quot;, n1)</span><br><span class="line">print(&quot;n2=&quot;, n2)</span><br><span class="line">print(&quot;c1=&quot;, c1)</span><br><span class="line">print(&quot;c2=&quot;, c2)</span><br></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n1 =<span class="number">22036096414750333101406538757625812613248444424049684758772058140377463618250795867832853117902163257003301132932490853355450673043991381637053778653821758783435921283322439267628837074056789021611782010444749024512216306961829453158759193969454712080047205883631153040900193575534288719429526169135614695862857156639195562501217424283401364740789214390377624598500939079307163832197534297642842744345373413423859103414676878739674227554029537817890874031594311152843060524913028526429344172693584167398664817727426767686424415189580527939256633114120720308173788544194669684834369132677253418971615644691719536820433</span></span><br><span class="line">n2 =<span class="number">17251653165250011947306159769694143433212298910745609670733920118632739529605426957617875166211610794383631191273183964010346725508667657137931394653419082978603166138439632713627832321960586938891805262605225424775586397813147240201440036009395991700175612039074317131837185920131565272816639771739150718839592250080325774556601865770352479323350280393818365902570673799584200153846520860657815432981116910233453207519365604533077996449249223280685559491369393277114405166293011856168173778428700718404816038991911974902005969923746846815798515831172402122367026339135245751136695128279659872423027539333024854133659</span></span><br><span class="line">c1 =<span class="number">1408937404754902028814920445701404613476983383738408959873219805755187459225302977012340464647741276263048769176603562703588286152102079561897286480939341184453940846603761664643956274520695676061184610702912592321357240109665885587701906369214592438887065694062151546241739122722790261888290706296747328780758965559093085406877315628139811554345214347799361309288949307776501119359571116522001853935560023530705364795364624152061166945046882418058831567088890277747158775876953662285842999920594778445526224560016361787941610542255000514402493843548068271595134879195073239601085319795505131267697387692179944010772</span></span><br><span class="line">c2 =<span class="number">12175155463891225370775786368564999885751076529394005420368968241428058465831204925081389807872272508968531564921996276054143112205083003561546962102395368677755381589762565680900651699885381615975236663522025080384481537727180649424984636506390139648492522347366656322729441290553251505232488994951243521740296115895651926783520321289129993169836271218322014443396220481361007479796234525990954874013729001502984583162486353287639655447340498584591591009224750835072707121652727119580764546240945763088815277130694950594020142961659318737857067755125666395542079926757603295535345281657293981259718286213812909191174</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">t = gmpy2.gcd(n1,n2)</span><br><span class="line"><span class="keyword">if</span> t != <span class="number">1</span>:</span><br><span class="line">    p = t</span><br><span class="line">    q = n1 // p</span><br><span class="line">    d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c1,d,n1)))</span><br></pre></td></tr></table></figure>

<h2 id="例题2-1"><a href="#例题2-1" class="headerlink" title="例题2"></a>例题2</h2><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m1 = libnum.s2n(flag[:21])</span><br><span class="line">m2 = libnum.s2n(flag[21:])</span><br><span class="line">p = libnum.generate_prime(1024)</span><br><span class="line">q1 = libnum.generate_prime(1024)</span><br><span class="line">q2 = libnum.generate_prime(1024)</span><br><span class="line">n1 = p * q1</span><br><span class="line">n2 = p * q2</span><br><span class="line">e = 65537</span><br><span class="line">c1 = pow(m1, e, n1)</span><br><span class="line">c2 = pow(m2, e, n2)</span><br><span class="line">print(&quot;n1=&quot;, n1)</span><br><span class="line">print(&quot;n2=&quot;, n2)</span><br><span class="line">print(&quot;c1=&quot;, c1)</span><br><span class="line">print(&quot;c2=&quot;, c2)</span><br></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n1 =<span class="number">18278456416897540360396258822757262982555755869670901090552498586949101988114819983049973792228149331753714211829150091366507963407709639602249698787433863615316934241223748268055507819756435927605756487582004688515855293842338007617018726192787272178786187989919650031295017445246608913808150370396832979736966944101019341527689214911779109999636349425823878126859829147994819384548777027669606291738366823809278767708461221830670665255418591083090040274616328116968600117656658246421927767060728182402210035045881818025673807969254883542917548511100917885959250620704515582518997559286168715792883861074220598943791</span></span><br><span class="line">n2 =<span class="number">14718281935692942246514344466960823739043788561815140598178699003630478731051901387468570752239748871701513260441416821474763710775757545770047001681689286764572928181308278425603577448081174829594272045737613383467853857541067932138008740271004046748970111915370497637083205151943216917589213000669827068183128735055853090146367442283033992973854093411154488547740107755082193303785575614939069343199774715111804373406251308943619862703275132627574605543897680349862262913772613627719842043981943797101165701793459771726617487555152346999588560213302046402911610106668235901710477454671759962352749028587857389680857</span></span><br><span class="line">c1 =<span class="number">14897512957877985291073451370997229971431611442234246383959378368138383843838602186764200234176467559404370286570662411222496252433014380640842874696486877004925614788148596161632851280090237300707166430170067495353446298066772402105814072501891920041154576728250668160351771877215919279860070607769304225631648712101695757447443748349446067746844910191804121935748134960309518439864721866967284850597357412411606643356342075119302860193616589493080428754805797969067310700610860435816047860794169521102300081676745004651672196010599021308459569165202732261338157558377669701207385936984772269758652310839805490426436</span></span><br><span class="line">c2 =<span class="number">8964679463182022749797829546680381147968492022695080270157954224365732346700186653596903802305955380468152204793914476872234000593338240036398422292867781937160592148807729413972520261014124973472761268000048797126209010105345911203497254239189500567762324829782091374108165308434410235044784878269559848498007708005049415987165881413527082350625816180534142506509426576438823347406737583570228393620002029592018404347050644682030278682484606748950839477932988072925403147456191170453590581297805161865533569937880834249663768378358974835993063581854638638010548705670806550267429609766941078881760115520503213998478</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">t = gmpy2.gcd(n1,n2)</span><br><span class="line"><span class="keyword">if</span> t != <span class="number">1</span>:</span><br><span class="line">    p = t</span><br><span class="line">    q1 = n1 // p</span><br><span class="line">    q2 = n2 // p</span><br><span class="line">    d1 = gmpy2.invert(e,(p-<span class="number">1</span>)*(q1-<span class="number">1</span>))</span><br><span class="line">    d2 = gmpy2.invert(e,(p-<span class="number">1</span>)*(q2-<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c1,d1,n1))+long_to_bytes(<span class="built_in">pow</span>(c2,d2,n2)))</span><br></pre></td></tr></table></figure>

<h2 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h2><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from flag import *</span><br><span class="line"></span><br><span class="line">n1 = 103835296409081751860770535514746586815395898427260334325680313648369132661057840680823295512236948953370895568419721331170834557812541468309298819497267746892814583806423027167382825479157951365823085639078738847647634406841331307035593810712914545347201619004253602692127370265833092082543067153606828049061</span><br><span class="line">n2 = 115383198584677147487556014336448310721853841168758012445634182814180314480501828927160071015197089456042472185850893847370481817325868824076245290735749717384769661698895000176441497242371873981353689607711146852891551491168528799814311992471449640014501858763495472267168224015665906627382490565507927272073</span><br><span class="line">e = 65537</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = pow(m, e, n1)</span><br><span class="line">c = pow(c, e, n2)</span><br><span class="line"></span><br><span class="line">print(&quot;c = %d&quot; % c)</span><br><span class="line"></span><br><span class="line"># output</span><br><span class="line"># c = 60406168302768860804211220055708551816238816061772464557956985699400782163597251861675967909246187833328847989530950308053492202064477410641014045601986036822451416365957817685047102703301347664879870026582087365822433436251615243854347490600004857861059245403674349457345319269266645006969222744554974358264</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>这题不同之处是在于，m进行了两次加密过程</strong></p>
<p><strong>解密两次就可以了，注意两次密钥</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n1 =<span class="number">103835296409081751860770535514746586815395898427260334325680313648369132661057840680823295512236948953370895568419721331170834557812541468309298819497267746892814583806423027167382825479157951365823085639078738847647634406841331307035593810712914545347201619004253602692127370265833092082543067153606828049061</span></span><br><span class="line">n2 =<span class="number">115383198584677147487556014336448310721853841168758012445634182814180314480501828927160071015197089456042472185850893847370481817325868824076245290735749717384769661698895000176441497242371873981353689607711146852891551491168528799814311992471449640014501858763495472267168224015665906627382490565507927272073</span></span><br><span class="line">c = <span class="number">60406168302768860804211220055708551816238816061772464557956985699400782163597251861675967909246187833328847989530950308053492202064477410641014045601986036822451416365957817685047102703301347664879870026582087365822433436251615243854347490600004857861059245403674349457345319269266645006969222744554974358264</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">t = gmpy2.gcd(n1,n2)</span><br><span class="line"><span class="keyword">if</span> t != <span class="number">1</span>:</span><br><span class="line">    p = t</span><br><span class="line">    q1 = n1 // p</span><br><span class="line">    q2 = n2 // p</span><br><span class="line">    d1 = gmpy2.invert(e,(p-<span class="number">1</span>)*(q1-<span class="number">1</span>))</span><br><span class="line">    d2 = gmpy2.invert(e,(p-<span class="number">1</span>)*(q2-<span class="number">1</span>))</span><br><span class="line">    m = <span class="built_in">pow</span>(c,d2,n2)</span><br><span class="line">    flag = <span class="built_in">pow</span>(m,d1,n1)</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(flag))</span><br></pre></td></tr></table></figure>

<h1 id="八、dp泄露"><a href="#八、dp泄露" class="headerlink" title="八、dp泄露"></a>八、dp泄露</h1><p>通过dp &#x3D; d % (p-1)，以及数论知识求解p</p>
<h2 id="原理推导"><a href="#原理推导" class="headerlink" title="原理推导"></a>原理推导</h2><p>$\because dp \equiv d \mod (p-1)$</p>
<p>左右同乘$e$得</p>
<p>$dp×e \equiv d×e \mod (p-1)$，则$d×e &#x3D; k_1(p-1) +dp×e$</p>
<p>又$\because d×e \equiv 1 \mod \phi(n)$，$\therefore d×e &#x3D; k_2(p-1)(q-1)+1$</p>
<p>$\therefore k_1(p-1)+dp×e &#x3D; k_2(p-1)(q-1)+1$</p>
<p>化简得</p>
<p>$dp×e &#x3D; (p-1)[k_2(q-1)-k_1]$+1</p>
<p>$\because dp &lt; p-1$，$\therefore 0&lt; k_2(q-1)-k_1&lt;e$</p>
<p>遍历$i \in (0,e)$的所有值，如果$dp×e-1$能够整除$i$则，我们可以求得$p-1$</p>
<h3 id="例题1-2"><a href="#例题1-2" class="headerlink" title="例题1"></a>例题1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">print(flag)</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">p = libnum.generate_prime(1024)</span><br><span class="line">q = libnum.generate_prime(1024)</span><br><span class="line">e = 65537</span><br><span class="line">n = p * q</span><br><span class="line">phi = (p - 1) * (q - 1)</span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line">print(&quot;d=&quot;,d)</span><br><span class="line">dp = d % (p - 1)</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(&quot;n=&quot;, n)</span><br><span class="line">print(&quot;e=&quot;, e)</span><br><span class="line">print(&quot;c=&quot;, c)</span><br><span class="line">print(&quot;dp=&quot;, dp)</span><br></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n = <span class="number">17954000555185130679232377513216924086370205717680723426279833171815673097846434355592747466782173529597978954062272371758852339605432963940809244445748900431763988392120156128524694217746804744076348205536430811607694098089294013508111154514184079159181563040241302764793111632189829652065825442796716027051750043654503172469553222784393034067341575558782690547449884992414106322578261286526556856377419622164651917718772498388922129465042492616904419638034789576380038341882418547113136903862482397767904921157094396562770484669239932933837196899640811033424030302285885080504355934919967693498648701839252087380477</span></span><br><span class="line">c = <span class="number">1808490145328726635638705291306162339133116115672167390186563455429486046847680827004544020052978814401354685508506555963361065725012891622174617670820924531959433674273579973778657669162210657120785539629874456938159379512635932223403818177582242406964621317531188027900758868453176575753681627336133481701182056262584118645398172089436811174776978418919803975809158758707062473122656821152108292060156091196577573172937093806159669057467094718771367509856968694209472630329096814023864642219783061245777457366202879949123915168571990229277326042767587009623951348541055835347386485900505749475571895673653225741649</span></span><br><span class="line">dp =<span class="number">114993440308125678369350484461242628405806013372930792337329972720600942891053460367721272956155528263465552939386621554396883112994907299126303463171544968629898544811159986442249990975328659373544491636958873255689808151391606942912468529923159009459712396428051292828093059494024457367637991626193487727331</span></span><br><span class="line">e =<span class="number">65537</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,e):</span><br><span class="line">    t = (dp * e - <span class="number">1</span>) % i        <span class="comment">#这是p-1前面的系数</span></span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">        p = (dp * e - <span class="number">1</span>) // i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n % p == <span class="number">0</span>:</span><br><span class="line">            q = n // p</span><br><span class="line">            d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">            <span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br></pre></td></tr></table></figure>

<p>这里可以用m &#x3D; pow(c,dp,p)求解</p>
<h3 id="例题2-e很大"><a href="#例题2-e很大" class="headerlink" title="例题2 e很大"></a>例题2 e很大</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">p = libnum.generate_prime(1024)</span><br><span class="line">q = libnum.generate_prime(1024)</span><br><span class="line">e = libnum.generate_prime(128)</span><br><span class="line">n = p * q</span><br><span class="line">phi = (p - 1) * (q - 1)</span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line"></span><br><span class="line">dp = d % (p - 1)</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(&quot;n=&quot;, n)</span><br><span class="line">print(&quot;e=&quot;, e)</span><br><span class="line">print(&quot;c=&quot;, c)</span><br><span class="line">print(&quot;dp=&quot;, dp)</span><br></pre></td></tr></table></figure>

<p>$\because dp ×e &#x3D; k(p-1)+1$，$\therefore dp ×e \equiv 1 \mod (p-1)$</p>
<p>假如存在与$p$互素的常数$a$</p>
<p>则$a^{dp×e} \mod p \equiv a^{k(p-1)+1} \mod p \equiv a \mod p$</p>
<p>$\therefore a^{dp×e}-a &#x3D;kp$</p>
<p>同时模n得$a^{dp×e}  - a \equiv kp \mod n$</p>
<p><strong>思路：通过求kp和n的公因数得到p</strong></p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime,long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n= <span class="number">18150086749964030204952772593650655354407282168407543480518017821905322058792108409169209539752974177937328703466169798097779231540410352308736251888449285307132274903811942187361234788236374036493935354342502760429195828731474432692281516115002087485890105917067613983079156790015275611914738187418424730456416770000646598861170179898016595068557049151791620868027603590052357726580431487083778514163249201637184318559165989454489485258667170883129099757366657203826319909509544670881866298317938263281638296241860739828567999093491297970389142395080780768892194380031018324855383292685388767246393785705551231780899</span></span><br><span class="line">e= <span class="number">278817530653170259039233683650169866189</span></span><br><span class="line">c= <span class="number">10813189255953686674328168562592345253502176950586624384555229875947895107088800774325110599057171743065073092283651992594106863499561887773348061509184951920329015539552207920010924284253109754443530283215130327152416667309504455641730629770856098336299767661535526880065006664806270833698497579073641076473649621250873969544362062393319711114090739414415757921473984666129110213417578310035188480139392986280529932137364474426391469019554935239234968517869914506321750458197587849623935306068749435995413807906558975073047215241796461878288003366415184144140612947217041288538376514085070670565572628317388808356563</span></span><br><span class="line">dp= <span class="number">25015362092988139281045705051525732988903355826221062953430054346210238749256645995431509510448988062597830708438496723137288693056422683942336451600173722142331077900759633024803467824277121463213906905346623305038031660927650043841899168305106293747254814365869018331032172781810238397508103692878400636333</span></span><br><span class="line"></span><br><span class="line">a = getPrime(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">p = gmpy2.gcd(<span class="built_in">pow</span>(a,dp*e,n)-a,n)    <span class="comment">#pow(a,dp*e,n)-a 就是kp</span></span><br><span class="line">m = <span class="built_in">pow</span>(c,dp,p)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line">q = n // p</span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>

<p><strong>用两个密钥对都可以解出m</strong></p>
<h3 id="例题3-n未知"><a href="#例题3-n未知" class="headerlink" title="例题3 n未知"></a>例题3 n未知</h3><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnu</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">print(flag)</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">p = libnum.generate_prime(1024)</span><br><span class="line">q = libnum.generate_prime(1024)</span><br><span class="line">e = 65537</span><br><span class="line">n = p * q</span><br><span class="line">phi = (p - 1) * (q - 1)</span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line">dp = d % (p - 1)</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(&quot;e=&quot;, e)</span><br><span class="line">print(&quot;c=&quot;, c)</span><br><span class="line">print(&quot;dp=&quot;, dp)</span><br></pre></td></tr></table></figure>

<p>求出p之后用dp,e这对密钥解密即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes,isPrime</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">698357636567367558759711776580320719340933493084285009370699059680075963885649900991785743925476703612566177770615688140828294009342321248532528135717020321638633194236304071227376280469583784324554702187585633554583585613919643029910676079881346779693579198709927276845742333575135345002140882285105432861360786403309179432637837990636999378777874170745714808407518959616602571033295952904233401306613241319072606171376709797219789705532196258388768707986490052624356816398378517468828951464911099476954775258801172030116252779985789332801046195134582313214031366595004401717278610760829369314324849813940651309932</span></span><br><span class="line">dp = <span class="number">39896852438403708406984708916869979312352695661766157959550782921308613421683803903733849015989522374917508903612147241162520188920032456104881051889798874994032331870256031918606780154667124231064537682553043210245224684753512501513527050047942923719661361311254494006713834823643497048108777333495847434963</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,e):</span><br><span class="line">    <span class="keyword">if</span> (dp * e - <span class="number">1</span>) % i == <span class="number">0</span>:</span><br><span class="line">        p = (dp * e - <span class="number">1</span>) // i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(p):</span><br><span class="line">            m = <span class="built_in">pow</span>(c,dp,p)</span><br><span class="line">            <span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>



<h4 id="关于m-pow-c-dp-p-的证明"><a href="#关于m-pow-c-dp-p-的证明" class="headerlink" title="关于m &#x3D; pow(c,dp,p)的证明"></a>关于m &#x3D; pow(c,dp,p)的证明</h4><p>关于用dp和e也能解密做一个证明：</p>
<p><img src="/../images/RSA/13.png"><br>$$<br>即c^{dp}(mod \quad p)&#x3D;m<br>$$</p>
<h1 id="九、dp-dq泄露"><a href="#九、dp-dq泄露" class="headerlink" title="九、dp,dq泄露"></a>九、dp,dq泄露</h1><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>该题型的前提是m&lt;p，m&lt;q</p>
<h2 id="原理推导-1"><a href="#原理推导-1" class="headerlink" title="原理推导"></a>原理推导</h2><p><img src="/../images/RSA/14.png"><br>$$<br>\therefore m &#x3D; [((m_{2}-m_{1})×p^{-1}(mod \quad q))×p+m_{1}](mod \quad n)<br>$$</p>
<p>接下来的问题是如何通过dp,dq求m1,m2</p>
<p><img src="/../images/RSA/15.png"></p>
<p><strong>归纳一下所得条件</strong></p>
<p><img src="/../images/RSA/16.png"></p>
<p>接下来就是写代码了</p>
<h3 id="例题1-3"><a href="#例题1-3" class="headerlink" title="例题1"></a>例题1</h3><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">print(flag)</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">p = libnum.generate_prime(256)</span><br><span class="line">q = libnum.generate_prime(256)</span><br><span class="line">e = 65537</span><br><span class="line">n = p * q</span><br><span class="line">phi = (p - 1) * (q - 1)</span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line">print(&quot;d=&quot;, d)</span><br><span class="line">dp = d % (p - 1)</span><br><span class="line">dq = d % (q - 1)</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line"></span><br><span class="line">print(&quot;p=&quot;, p)</span><br><span class="line">print(&quot;q=&quot;, q)</span><br><span class="line">print(&quot;c=&quot;, c)</span><br><span class="line">print(&quot;dp=&quot;, dp)</span><br><span class="line">print(&quot;dq=&quot;, dq)</span><br></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = <span class="number">112454994630978850005784651276022327545786198205744597431888680937657203192943</span></span><br><span class="line">q = <span class="number">111081771780978300442208201256251933100607227308819156491182881723714968913833</span></span><br><span class="line">c = <span class="number">7847140580627012782899798457736961376953768684667159008470556786390887805253326211691923724846808704462396746105331991924048819814322540306282164012066426</span></span><br><span class="line">dp = <span class="number">99016059099144522019375365089687785694029213535292918424815544402513220169503</span></span><br><span class="line">dq = <span class="number">79504900574184798493105575420403885224379864982754477219462523963780735261625</span></span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line">m1 = <span class="built_in">pow</span>(c,dp,p)</span><br><span class="line">m2 = <span class="built_in">pow</span>(c,dq,q)</span><br><span class="line">P = gmpy2.invert(p,q)               <span class="comment">#p的逆元</span></span><br><span class="line">m = ((((m2-m1)*P)%q)*p+m1)%n</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>

<p><strong>关于m &#x3D; pow(c,dp,p)的条件是m&lt;p</strong></p>
<h1 id="十、n为p的r次方"><a href="#十、n为p的r次方" class="headerlink" title="十、n为p的r次方"></a>十、n为p的r次方</h1><p>当题型中n可以分解为一个素数的r次方，此时的欧拉函数有以下算法：</p>
<p>当$n &#x3D; p^{k}$，有$\phi(n) &#x3D; p^{k}-p^{k-1}$</p>
<h2 id="例题1-4"><a href="#例题1-4" class="headerlink" title="例题1"></a>例题1</h2><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">print(flag)</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">p = libnum.generate_prime(512)</span><br><span class="line">n = p ** 5</span><br><span class="line">e = 65537</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(&quot;n=&quot;, n)</span><br><span class="line">print(&quot;e=&quot;, e)</span><br><span class="line">print(&quot;c=&quot;, c)</span><br></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n = <span class="number">109671394618534156590716540772306636060550711465455829526382945168271125218007503161807386153286648328529071790130095763349089936429151343426469415497138306284842512691195220650548494501337831207724397925027651025644976364368511262187227825083865690186591571250267479440100917127211656877566179258870510690665025580200477574123634259670039152125607834855408269848826938902407472374892693266119859709658788565014195766992713646832624001067898323913639712284673673557898135411273837250194079399384826384835709060797351332323930309379071015140548478132323474993964925055399350661600068568602468295748573856804293659942047543032878436316918991716636681116631322082919386178460096115355963882313682994343822128626370850455024905542367255179074441679461101331332093019368492643</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">83166081100602571613112201467626632459949037182633475449066025299006894059443612622701975752551708249083077180755342065457682925338233793688583913228361068561515321097016501900442865692643652803949920987493441500744743553498018003210308290969303190355756775977367324120441564693220728163622472865572357639056734898022442794130514936425334924283145153496702507951466618177405870656868713199816223765264228006032228439676574053839549440372521050502986043855511540855864034336902304414848547480112182226920285820386643015671106933140105835060319823245206934565859078021518312305243997612804935774414840491355098017977514736057368000596388974956265042651277403519473262257945986199408278855335170546242641727930526697102351648388874227840119205560199015181257296591985205818</span></span><br><span class="line">p = <span class="number">10186351850605898834333098258639828910824016865517013383611935945131883947448223014077315468253377357594775340263769153442019216205089695821439736926082483</span></span><br><span class="line"></span><br><span class="line">phi = p**<span class="number">5</span>-p**<span class="number">4</span></span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br></pre></td></tr></table></figure>

<h2 id="例题2-2"><a href="#例题2-2" class="headerlink" title="例题2"></a>例题2</h2><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">p = libnum.generate_prime(512)</span><br><span class="line">q = libnum.generate_prime(512)</span><br><span class="line">n = p ** 3 * q</span><br><span class="line">e = 65537</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(&quot;q=&quot;, q)</span><br><span class="line">print(&quot;n=&quot;, n)</span><br><span class="line">print(&quot;e=&quot;, e)</span><br><span class="line">print(&quot;c=&quot;, c)</span><br></pre></td></tr></table></figure>

<p>$\because n &#x3D; p^{3}×q$</p>
<p>$\therefore \phi(n) &#x3D; (p^{3}-p^{2})×(q-1)$</p>
<p><strong>exp:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">q = <span class="number">13345672330679418443866848695749753384841350112452462690350565885192764753702964893062035116023096943358384379827500462723016224486435032522188166109529147</span></span><br><span class="line">n = <span class="number">4663711063632671446966617442890809468548735750386480905820144168615122369358088158709822723959108989276525102755551604204514586528122441075489492157644479194671784485228731421500391142158401889177506319977349707503678947872777602384171260874359045585814189677748712566088220734735479518470883541166059233676170283938881683675790979128058243582825012415020019043126740915522571217495119060031729061070896580899732991209113679151755713858497630999746612658308778711613697038750661479517187094033129979714688161348844542070263109259258937863241431480105798790363889436471998002323269704182369356300287043940743500087239</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">4050303218893912343776312253598257474375000778822229482734626960955864773175090306426885201033332266573903303684635688485414725284644108123459136702775991157244389086147955395682206311752151842740679445903864544823592773331496589661187968392779340028173948172003460012051289357755574536619241969492822938688821287700132262703677149526846356206143053559703859606442209340834979412336031660590507709503830013770022485005101363701272279629510056964018618212014677531338026866748075406283893942248599825641124694672878533987994699411744521757385858889763503705242690212615083634186373933214686193717950163215308138805348</span></span><br><span class="line"></span><br><span class="line">p = n // q </span><br><span class="line">phi = (p**<span class="number">3</span>-p**<span class="number">2</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br></pre></td></tr></table></figure>



<h1 id="十一、n分解为3个素数"><a href="#十一、n分解为3个素数" class="headerlink" title="十一、n分解为3个素数"></a>十一、n分解为3个素数</h1><h2 id="例题1-5"><a href="#例题1-5" class="headerlink" title="例题1"></a>例题1</h2><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">p = libnum.generate_prime(512)</span><br><span class="line">q = gmpy2.next_prime(p)</span><br><span class="line">r = libnum.generate_prime(512)</span><br><span class="line">n = p * q * r</span><br><span class="line">e = 65537</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(&quot;r=&quot;, r)</span><br><span class="line">print(&quot;n=&quot;, n)</span><br><span class="line">print(&quot;e=&quot;, e)</span><br><span class="line">print(&quot;c=&quot;, c)</span><br><span class="line"></span><br><span class="line">r = 12328943069972158868300333965019293732240349172933398867374450193780676916633106046545397891902123683693837126404908611670219604587587151306224914062663729</span><br><span class="line">n = 928445951911850156618541782850215900925329423880533465612155142015978599609287623859912813317551629221695490535012732781489396534420011145723987610606038091488823086647363964394753700158320900867101659445170118179077194271099520502633316318889163873291574934282498061117736456183503867870294570083013883365868242889035609602940685335912371326827533418614992221705810476710807373254363162373986374486325350746366851935451369892949745302442034805629514003196071631</span><br><span class="line">e = 65537</span><br><span class="line">c = 327716655224470059950709685055600963837116578216483343492948888372401723689223347212508532985781828794786448842515029515358422017875793926582832247025212149474404973170422295165602666360784347416812528617973764432916955654602356835327769633635513894485943553309743509322858937973710628023758816806471875016815994664897320150855163109437521642800230902661034555151514311149333258071668655344069451897282357234220538922127548822361859943829665459953651351620958628</span><br></pre></td></tr></table></figure>

<p>$\phi(n)&#x3D;(p-1)×(q-1)×(r-1)$</p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">r = <span class="number">12328943069972158868300333965019293732240349172933398867374450193780676916633106046545397891902123683693837126404908611670219604587587151306224914062663729</span></span><br><span class="line">n = <span class="number">928445951911850156618541782850215900925329423880533465612155142015978599609287623859912813317551629221695490535012732781489396534420011145723987610606038091488823086647363964394753700158320900867101659445170118179077194271099520502633316318889163873291574934282498061117736456183503867870294570083013883365868242889035609602940685335912371326827533418614992221705810476710807373254363162373986374486325350746366851935451369892949745302442034805629514003196071631</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">327716655224470059950709685055600963837116578216483343492948888372401723689223347212508532985781828794786448842515029515358422017875793926582832247025212149474404973170422295165602666360784347416812528617973764432916955654602356835327769633635513894485943553309743509322858937973710628023758816806471875016815994664897320150855163109437521642800230902661034555151514311149333258071668655344069451897282357234220538922127548822361859943829665459953651351620958628</span></span><br><span class="line"></span><br><span class="line">t = gmpy2.iroot(n//r,<span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">p = gmpy2.next_prime(t)</span><br><span class="line">q = n // p // r</span><br><span class="line"></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)*(r-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br></pre></td></tr></table></figure>

<h2 id="例题2-3"><a href="#例题2-3" class="headerlink" title="例题2"></a>例题2</h2><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">p = libnum.generate_prime(512)</span><br><span class="line">q = libnum.generate_prime(512)</span><br><span class="line">r = libnum.generate_prime(512)</span><br><span class="line">z = libnum.generate_prime(512)</span><br><span class="line">n = p * q * r * z</span><br><span class="line">e = 65537</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(&quot;p=&quot;, p)</span><br><span class="line">print(&quot;q=&quot;, q)</span><br><span class="line">print(&quot;r=&quot;, r)</span><br><span class="line">print(&quot;z=&quot;, z)</span><br><span class="line">print(&quot;n=&quot;, n)</span><br><span class="line">print(&quot;e=&quot;, e)</span><br><span class="line">print(&quot;c=&quot;, c)</span><br></pre></td></tr></table></figure>

<p>$\phi(n) &#x3D; (p-1)×(q-1)×(r-1)×(z-1)$</p>
<p><strong>exp:</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">p = <span class="number">12213843677002747766848780813863444765635042481765413051856941866086491788109497010943473273572566841660085356963998380859972440509623320585264570870882377</span></span><br><span class="line">q = <span class="number">10902490082251495426199569292732505400137675709524837939357515262329540011464655744129250363907196869656418112808846020897118146863902562367003327272321449</span></span><br><span class="line">r = <span class="number">8245419815086573989912567235897662412607561235885604814025447500079491044202192595152864571279969681042912188605024753854047024662013720379103778526236839</span></span><br><span class="line">z = <span class="number">10917615097508699827805276639030692194611453656058695332553958067645900726083779376328239937088149850336439698089338637703951122165530113430740915375254019</span></span><br><span class="line">n = <span class="number">11987223678888371522590014163574474585984194442215707213681942674682481521159615601278963653710214413966851484769697316184020225580354584969280759516304518930586023758786499707314773352093733555751516210440026493115763715594030219348717378054713330562469489929071833023251985410432681379225722515249114768069799538178471227684886585818611193385720863927599686403372685979041786980765941581357531078866173940675302211156740624961660458364870744891267336542629860728676639340370300143607766541999848139604816244471035977632825191833661785202909345705598016303539579822007932773115520022154167375759849411486420750385893</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">5395740155304669350813446148984001089577243830507792794817942379567952891169689187159605803584012696669416468262913205072505580096612689488031607303556309165510626352159994870224831746393515302036056276128780176510345937509694407306122459125905753373646070294254525528004397615098037040212875934172270348504386498501381675335673389883548268757941289932688918632949813634383348968682753785403890857910581199432899158400152800186245499719012819119582095532181336705889412130586102740186044306846473639210373743145249675886413163898094394917296889841622782268580482112735272818555859742460277831777444758731534129950815</span></span><br><span class="line"></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)*(r-<span class="number">1</span>)*(z-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br></pre></td></tr></table></figure>

<h1 id="十二、e-和phi-n-不互素"><a href="#十二、e-和phi-n-不互素" class="headerlink" title="十二、e 和phi_n 不互素"></a>十二、e 和phi_n 不互素</h1><p>当$e$与$\phi(n)$不互素时，则不存在模$\phi(n)$的逆元$d$使得$ed \equiv 1(mod \quad \phi(n))$</p>
<h2 id="情况处理方式1："><a href="#情况处理方式1：" class="headerlink" title="情况处理方式1："></a>情况处理方式1：</h2><p>令$t &#x3D; gcd(e,\phi(n))$</p>
<p>设$e &#x3D; e’×t$，则$e’ &#x3D; \frac{e}{t}$</p>
<p>则$c \equiv m^e \mod n \longrightarrow c \equiv (m ^t)^{e’} \mod n$</p>
<p>求$e’$对应的$d$，解出$m^t \equiv c^d \mod n$</p>
<p>在$m^t &lt; n$的情况下开根即可获得$m$</p>
<h3 id="例题1-常规"><a href="#例题1-常规" class="headerlink" title="例题1 常规"></a>例题1 常规</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import random</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">print(flag)</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line"></span><br><span class="line">while 1:</span><br><span class="line">    e = random.randint(100, 1000)</span><br><span class="line">    p = libnum.generate_prime(1024)</span><br><span class="line">    q = libnum.generate_prime(1024)</span><br><span class="line">    phi_n = (p - 1) * (q - 1)</span><br><span class="line">    t = gmpy2.gcd(e, phi_n)</span><br><span class="line">    if t == e:</span><br><span class="line">        continue</span><br><span class="line">    t1 = e // t</span><br><span class="line">    if gmpy2.invert(t1, phi_n) and t &gt; 1:</span><br><span class="line">        break</span><br><span class="line">n = p * q</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(&quot;p=&quot;, p)</span><br><span class="line">print(&quot;q=&quot;, q)</span><br><span class="line">print(&quot;e=&quot;, e)</span><br><span class="line">print(&quot;c=&quot;, c)</span><br></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">p = <span class="number">171854505164939390402295426493389586289972154851849140728417624619463988154808053805729538974688869671559032639921300088271234681410193379381085714252211392886408792711387524667824537369266846649573070209815436507363007636943912350208275895292853801665488228125846058987049326903498661007035974420392738723323</span></span><br><span class="line">q = <span class="number">145951936627745243523384785325963094339728144811023266133546816860787405503371056873662508073284279180417626507724315776654624382665743082805910036891739754019932290977071276850239245644056698685966997752654383650764557358649666141576105936215709831181842086893228254304235678475375978464394818353375373451573</span></span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">830</span></span><br><span class="line">c= <span class="number">4413268199893347044741276120215584703428167052744516280494996526431559720190092261631829389527634625276020346166956540800884139234489942113764564139232948414263452549927818365096023041932432723988241639527832673120924732407691135173154085803338322715604275530735968992726708155724384432557207264839248502158712330572704509492520346044648676055223193900826626346707083590815897507927683083455678855000344499804465073698745769989966769567497677402668725931090596642504740789789740965769347050166069295727209131555338513809368814890255851742010120871635378654904140016065148709710206173069000137023824698858539843753921</span></span><br><span class="line"></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">t = gmpy2.gcd(e,phi)</span><br><span class="line"><span class="keyword">if</span> t != <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(t)</span><br><span class="line">    e1 = e // t</span><br><span class="line">    d = gmpy2.invert(e1,phi)</span><br><span class="line">    m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(gmpy2.iroot(m,t)[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<h3 id="例题2-已知lcm-p-1-q-1"><a href="#例题2-已知lcm-p-1-q-1" class="headerlink" title="例题2 已知lcm((p-1),(q-1))"></a>例题2 已知lcm((p-1),(q-1))</h3><p>两个不为$0$的整数$p,q$有以下性质：</p>
<p>$p×q &#x3D; gcd(p,q)×lcm(p,q)$</p>
<p>即两个数的乘积为他们最小公倍数和最大公约数的乘积</p>
<p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import uuid</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line"># print(flag)</span><br><span class="line">m=libnum.s2n(flag)</span><br><span class="line"></span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">n=p*q</span><br><span class="line">hint = gmpy2.lcm(p - 1 , q - 1)</span><br><span class="line">e=54722</span><br><span class="line">c=pow(m,e,n)</span><br><span class="line"></span><br><span class="line">print(&quot;n=&quot;,n)</span><br><span class="line">print(&quot;e=&quot;,e)</span><br><span class="line">print(&quot;c=&quot;,c)</span><br><span class="line">print(&quot;hint=&quot;,hint)</span><br></pre></td></tr></table></figure>

<p>这道题已知$(p-1)$和$(q-1)$的最小公倍数，我们只要知道最大公约数就能求得$\phi(n)$即</p>
<p>首先$lcm((p-1),(q-1))$为$1021bit$，$n&#x3D;1024bit$，这说明$gcd((p-1),(q-1))$只有$3bit$</p>
<p>所以$gcd((p-1),(q-1))$的数值在$[4,8)$之间，只有几位，可以爆破得到$\phi(n)$</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">hint = <span class="number">12176993678498230245546088277872780304938463326256069551378199465489519085975397931056456171244584591828814093149962580899089636705985786379467779463476493219517172984909297814745438140651274778256117288586982848108213932163133817644505376344716130049020474232954521634539644016004694898461955741388897934560</span></span><br><span class="line">n = <span class="number">121769936784982302455460882778727803049384633262560695513781994654895190859753979310564561712445845918288140931499625808990896367059857863794677794634764954265917223929188027566735170858722793015537480829986990608756383815655534511937235703892950567493911917178761554143379884176240162037489989420552078127671</span></span><br><span class="line">e = <span class="number">54722</span></span><br><span class="line">c= <span class="number">68207327189131286430765764525947832439888346002213816928140706886898558628392596589715994944626609815778649728495478844245774029669442060829925589118748033844002399193350339069964179052517763638951854264605935062729791334189169468172816314672207667470048850163934061677572210757247460567864055270415151846298</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>,<span class="number">8</span>):</span><br><span class="line">    phi = hint*h</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        d = gmpy2.invert(e,phi)</span><br><span class="line">        m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            t = gmpy2.gcd(e,phi)</span><br><span class="line">            <span class="keyword">if</span> t != <span class="number">1</span>:</span><br><span class="line">                e1 = e // t</span><br><span class="line">                d = gmpy2.invert(e1,phi)</span><br><span class="line">                mt = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">                m = gmpy2.iroot(mt,t)[<span class="number">0</span>]</span><br><span class="line">                <span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>第二种解题：$k\phi(n)$当$\phi(n)$使用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">hint = <span class="number">12176993678498230245546088277872780304938463326256069551378199465489519085975397931056456171244584591828814093149962580899089636705985786379467779463476493219517172984909297814745438140651274778256117288586982848108213932163133817644505376344716130049020474232954521634539644016004694898461955741388897934560</span></span><br><span class="line">n = <span class="number">121769936784982302455460882778727803049384633262560695513781994654895190859753979310564561712445845918288140931499625808990896367059857863794677794634764954265917223929188027566735170858722793015537480829986990608756383815655534511937235703892950567493911917178761554143379884176240162037489989420552078127671</span></span><br><span class="line">e = <span class="number">54722</span></span><br><span class="line">c= <span class="number">68207327189131286430765764525947832439888346002213816928140706886898558628392596589715994944626609815778649728495478844245774029669442060829925589118748033844002399193350339069964179052517763638951854264605935062729791334189169468172816314672207667470048850163934061677572210757247460567864055270415151846298</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    d = gmpy2.invert(e,hint)</span><br><span class="line">    m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    t = gmpy2.gcd(e,hint)</span><br><span class="line">    e1 = e // t</span><br><span class="line">    d = gmpy2.invert(e1,hint)</span><br><span class="line">    mt = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">    m = gmpy2.iroot(mt,t)</span><br><span class="line">    <span class="keyword">if</span> m[<span class="number">1</span>]:</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(m[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<p>如果$ed \equiv 1 \mod k\phi(n)$</p>
<p>$m \equiv c^d \mod n \longrightarrow m \equiv m^{ed} \mod n \longrightarrow m \equiv m^{k_1×k\phi(n)+1} \mod n$</p>
<p>由费马定理得</p>
<p>$m \equiv (m^{\phi(n)})^{k_1×k}×m \mod n \longrightarrow m \equiv 1×m \mod n \longrightarrow m \equiv m \mod n$</p>
<p>所以$k\phi(n)$当作$\phi(n)$使用是正确的</p>
<p>不过，如果$k\phi(n)$小于$\phi(n)$的话，在一定范围中是可以代替$\phi(n)$的</p>
<h2 id="情况2：用中国剩余定理"><a href="#情况2：用中国剩余定理" class="headerlink" title="情况2：用中国剩余定理"></a>情况2：用中国剩余定理</h2><p>$$<br>如果m^{t}&gt;n，需要用到中国剩余定理<br>$$</p>
<h3 id="2022ctfshow卷王杯"><a href="#2022ctfshow卷王杯" class="headerlink" title="2022ctfshow卷王杯"></a>2022ctfshow卷王杯</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import bytes_to_long</span><br><span class="line">from secrets import p,q,r,s,t,flag</span><br><span class="line"></span><br><span class="line">n = p * q * r * s * t</span><br><span class="line">e = 2</span><br><span class="line">m = bytes_to_long(os.urandom(500) + flag)</span><br><span class="line">c = pow(m,e,n)</span><br><span class="line"></span><br><span class="line">print(p,q,r,s,t,sep=&#x27;\n&#x27;)</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">145332367700944303747548912160113939198078051436029477960348968315913956664143693347226702600438608693933768134575289286283267810723137895903153829001826223446477799895493265422562348917012216790077395795861238257357035152687833639085415763850743538206986781418939737511715957738982536382066693822159860701263</span><br><span class="line">116660458253067608044065523310547233337730583902133756095473339390057738510707447906971188577217274861047379404014140178165569604404468897712846876108444468370709141219302291601408652742006268186059762087155933131837323952675627966299810891805398890428420575425160696531236660480933905879208166090591482794763</span><br><span class="line">157931722402853245421436270609912823260313730941283152856444641969403238646482562190531038393124087232554754746464603598717356255570166081501573727336977292059427220330169044611674973569766966838498453232642731737958791706086957762244686953294662693939604300864961637325536379321027705854708492453330690705531</span><br><span class="line">100973451687449518854742673778783266158999451072058606348222018797891147675959983616210003484476577612134482311993701677242007759556951494382833070563369964294544839433671087037596159753825249018950693369209927951667775267086896180395776150188902057785214767230658487267587289809918132337927575673868568976679</span><br><span class="line">93960345071948255233882121683650797512129333868351496468898834736770441398743300745703393838320587998953678254272245400344928586394089488734271897540051673996675973642347859306921527430850673334243441180183460927865980713929789963587608547554858491264614271309608925634272282292964002897650355047792764365447</span><br><span class="line">9144597920381774885442906257311149465702295057238600973973598305004391534618770363098565074541384771979931799878381439264848137810353858418200992191234142740194489573540381681161219332611454834544291634628456257670178843484698324641739324687497388018406214041657278323855749902661752448796122517061920880552011343608609622885787617238758769398972009949575526258430282648817039091284796330585349957724522615105102735930258969562103112238020133587096826386028128471852377225525357348919204333121695432662339443004327748973224423132988376298843862056631045488285859621661802413201793962883794915513510467912312842687601478117040419013468059983777273699192408773551806581458197324620065210523913467414181480875280203580147077789063808832356486197271376615883221558265591069223727607585313240243619515521180600435114131162272519949101464089935441251751426683447701142156416866113627126765919641034042927519834229168536331952275698122511502745177547569813354280565828372968703810158857859460406828090199683324760956105682902577189283246483314689365570862217407333103243336691401424548702387876409228977278498691200028282744239512091373110111792177228979867318546462714521296256938374618636206565791541769138267080789842400796973226733816939794717596194090232425688504890234304977612220790858557639246367437740975495450011676714198668471438814299689325208882261918460708833888406187912527346628912894921059735420931656953236560178909180587372589456926690219114173193202048332172538564489660440225377822914097420807957784201785024166011709377791129</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>看似白给，其实$e$和$\phi(n)$不互素</p>
<p>而且在flag前面填充了一些数据，导致$m^e &gt; n$，所以直接开根号也不可取</p>
<p><strong>看到e&#x3D;2，应该是类似rabin，一般的rabin是两个素数，这里有5个，说明会有32个解</strong></p>
<p><img src="/../images/RSA/19.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sympy.ntheory.modular import crt</span><br><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">p = 145332367700944303747548912160113939198078051436029477960348968315913956664143693347226702600438608693933768134575289286283267810723137895903153829001826223446477799895493265422562348917012216790077395795861238257357035152687833639085415763850743538206986781418939737511715957738982536382066693822159860701263</span><br><span class="line">q = 116660458253067608044065523310547233337730583902133756095473339390057738510707447906971188577217274861047379404014140178165569604404468897712846876108444468370709141219302291601408652742006268186059762087155933131837323952675627966299810891805398890428420575425160696531236660480933905879208166090591482794763</span><br><span class="line">r = 157931722402853245421436270609912823260313730941283152856444641969403238646482562190531038393124087232554754746464603598717356255570166081501573727336977292059427220330169044611674973569766966838498453232642731737958791706086957762244686953294662693939604300864961637325536379321027705854708492453330690705531</span><br><span class="line">s = 100973451687449518854742673778783266158999451072058606348222018797891147675959983616210003484476577612134482311993701677242007759556951494382833070563369964294544839433671087037596159753825249018950693369209927951667775267086896180395776150188902057785214767230658487267587289809918132337927575673868568976679</span><br><span class="line">t = 93960345071948255233882121683650797512129333868351496468898834736770441398743300745703393838320587998953678254272245400344928586394089488734271897540051673996675973642347859306921527430850673334243441180183460927865980713929789963587608547554858491264614271309608925634272282292964002897650355047792764365447</span><br><span class="line">c = 9144597920381774885442906257311149465702295057238600973973598305004391534618770363098565074541384771979931799878381439264848137810353858418200992191234142740194489573540381681161219332611454834544291634628456257670178843484698324641739324687497388018406214041657278323855749902661752448796122517061920880552011343608609622885787617238758769398972009949575526258430282648817039091284796330585349957724522615105102735930258969562103112238020133587096826386028128471852377225525357348919204333121695432662339443004327748973224423132988376298843862056631045488285859621661802413201793962883794915513510467912312842687601478117040419013468059983777273699192408773551806581458197324620065210523913467414181480875280203580147077789063808832356486197271376615883221558265591069223727607585313240243619515521180600435114131162272519949101464089935441251751426683447701142156416866113627126765919641034042927519834229168536331952275698122511502745177547569813354280565828372968703810158857859460406828090199683324760956105682902577189283246483314689365570862217407333103243336691401424548702387876409228977278498691200028282744239512091373110111792177228979867318546462714521296256938374618636206565791541769138267080789842400796973226733816939794717596194090232425688504890234304977612220790858557639246367437740975495450011676714198668471438814299689325208882261918460708833888406187912527346628912894921059735420931656953236560178909180587372589456926690219114173193202048332172538564489660440225377822914097420807957784201785024166011709377791129</span><br><span class="line">e = 2</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(p))</span><br><span class="line">f = x^e - c</span><br><span class="line">f = f.monic()</span><br><span class="line">res1 = f.roots()</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(q))</span><br><span class="line">f = x^e - c</span><br><span class="line">f = f.monic()</span><br><span class="line">res2 = f.roots()</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(r))</span><br><span class="line">f = x^e - c</span><br><span class="line">f = f.monic()</span><br><span class="line">res3 = f.roots()</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(s))</span><br><span class="line">f = x^e - c</span><br><span class="line">f = f.monic()</span><br><span class="line">res4 = f.roots()</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(t))</span><br><span class="line">f = x^e - c</span><br><span class="line">f = f.monic()</span><br><span class="line">res5 = f.roots()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in res1:</span><br><span class="line">    for j in res2:</span><br><span class="line">        for k in res3:</span><br><span class="line">            for a in res4:</span><br><span class="line">                for b in res5:</span><br><span class="line">                    m_list = [int(i[0]),int(j[0]),int(k[0]),int(a[0]),int(b[0])]</span><br><span class="line">                    a_list= [p,q,r,s,t]</span><br><span class="line">                    solve = CRT_list(m_list,a_list)</span><br><span class="line">                    flag = long_to_bytes(solve)</span><br><span class="line">                    if b&#x27;ctfshow&#x27; in flag:</span><br><span class="line">                    	print(flag)</span><br><span class="line"># ctfshow&#123;D0_y0u_R3aLly_Kn0w_Ra8IN_alg0RI7HM?&#125;</span><br></pre></td></tr></table></figure>

<p>需要遍历$res1——res5$的所有组合</p>
<h3 id="2018高校运维挑战赛AzureRSA"><a href="#2018高校运维挑战赛AzureRSA" class="headerlink" title="2018高校运维挑战赛AzureRSA"></a>2018高校运维挑战赛AzureRSA</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n1=0xcfc59d54b4b2e9ab1b5d90920ae88f430d39fee60d18dddbc623d15aae645e4e50db1c07a02d472b2eebb075a547618e1154a15b1657fbf66ed7e714d23ac70bdfba4c809bbb1e27687163cb09258a07ab2533568192e29a3b8e31a5de886050b28b3ed58e81952487714dd7ae012708db30eaf007620cdeb34f150836a4b723L</span><br><span class="line">e1=0xfae3aL</span><br><span class="line">c1=0x81523a330fb15125b6184e4461dadac7601340960840c5213b67a788c84aecfcdc3caf0bf3e27e4c95bb3c154db7055376981972b1565c22c100c47f3fa1dd2994e56090067b4e66f1c3905f9f780145cdf8d0fea88a45bae5113da37c8879c9cdb8ee9a55892bac3bae11fbbabcba0626163d0e2e12c04d99f4eeba5071cbeaL</span><br><span class="line">n2=0xd45304b186dc82e40bd387afc831c32a4c7ba514a64ae051b62f483f27951065a6a04a030d285bdc1cb457b24c2f8701f574094d46d8de37b5a6d55356d1d368b89e16fa71b6603bd037c7f329a3096ce903937bb0c4f112a678c88fd5d84016f745b8281aea8fd5bcc28b68c293e4ef4a62a62e478a8b6cd46f3da73fa34c63L</span><br><span class="line">e2=0x1f9eaeL</span><br><span class="line">c2=0x4d7ceaadf5e662ab2e0149a8d18a4777b4cd4a7712ab825cf913206c325e6abb88954ebc37b2bda19aed16c5938ac43f43966e96a86913129e38c853ecd4ebc89e806f823ffb802e3ddef0ac6c5ba078d3983393a91cd7a1b59660d47d2045c03ff529c341f3ed994235a68c57f8195f75d61fc8cac37e936d9a6b75c4bd2347L</span><br><span class="line">assert pow(flag,e1,n1)==c1</span><br><span class="line">assert pow(flag,e2,n2)==c2</span><br><span class="line">assert gcd(e1,(p1-1)*(q1-1))==14</span><br><span class="line">assert gcd(e2,(p2-1)*(q2-1))==14</span><br></pre></td></tr></table></figure>

<p>有别于上题，这道题两个e和phi都不互素</p>
<p>设$e$和$\phi(n)$的公因数为$t$，则$e &#x3D; e’t$，$e’ &#x3D; \frac{e}{t}$，有$e’d \equiv 1 \mod \phi(n)$</p>
<p>$\therefore m^t \equiv c^d \mod n$</p>
<p>如果$t$不大的话，我们可以直接开根求得$m$，但是这题$t&#x3D;14$，所以我们考虑用中国剩余定理</p>
<p>于是我们有</p>
<p><img src="/../images/RSA/45.png"></p>
<p>用中国剩余定理解出其特解$res$，即$res \equiv m^{14} \mod lcm(n_1,n_2) \longrightarrow res \equiv m^{14} \mod pq_1q_2$</p>
<p>把它当作一个$e&#x3D;14$的RSA加密</p>
<p>然后重新走一遍上一步的过程，发现还是没解出来</p>
<p>看了大佬的思路是把模数换成$q_1q_2$，即$res \equiv m^{14} \mod q_1q_2$</p>
<p>$res &#x3D; m^{14} + kpq_1q_2$，两边同时模$q_1q_2$，得$res \equiv m^{14} \mod q_1q_2$</p>
<p>换完模数之后对应的$phi &#x3D; (q_1-1)(q_2-1)$</p>
<p>然后发现$e&#x3D;14$和$phi$依旧存在公因数，再套用第一步即可</p>
<p>exp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">n1=0xcfc59d54b4b2e9ab1b5d90920ae88f430d39fee60d18dddbc623d15aae645e4e50db1c07a02d472b2eebb075a547618e1154a15b1657fbf66ed7e714d23ac70bdfba4c809bbb1e27687163cb09258a07ab2533568192e29a3b8e31a5de886050b28b3ed58e81952487714dd7ae012708db30eaf007620cdeb34f150836a4b723L</span><br><span class="line">e1=0xfae3aL</span><br><span class="line">c1=0x81523a330fb15125b6184e4461dadac7601340960840c5213b67a788c84aecfcdc3caf0bf3e27e4c95bb3c154db7055376981972b1565c22c100c47f3fa1dd2994e56090067b4e66f1c3905f9f780145cdf8d0fea88a45bae5113da37c8879c9cdb8ee9a55892bac3bae11fbbabcba0626163d0e2e12c04d99f4eeba5071cbeaL</span><br><span class="line">n2=0xd45304b186dc82e40bd387afc831c32a4c7ba514a64ae051b62f483f27951065a6a04a030d285bdc1cb457b24c2f8701f574094d46d8de37b5a6d55356d1d368b89e16fa71b6603bd037c7f329a3096ce903937bb0c4f112a678c88fd5d84016f745b8281aea8fd5bcc28b68c293e4ef4a62a62e478a8b6cd46f3da73fa34c63L</span><br><span class="line">e2=0x1f9eaeL</span><br><span class="line">c2=0x4d7ceaadf5e662ab2e0149a8d18a4777b4cd4a7712ab825cf913206c325e6abb88954ebc37b2bda19aed16c5938ac43f43966e96a86913129e38c853ecd4ebc89e806f823ffb802e3ddef0ac6c5ba078d3983393a91cd7a1b59660d47d2045c03ff529c341f3ed994235a68c57f8195f75d61fc8cac37e936d9a6b75c4bd2347L</span><br><span class="line">p = gmpy2.gcd(n1,n2)</span><br><span class="line">q1 = n1//p</span><br><span class="line">q2 = n2//p</span><br><span class="line"></span><br><span class="line">phi1 = (p-1)*(q1-1)</span><br><span class="line">phi2 = (p-1)*(q2-1)</span><br><span class="line"></span><br><span class="line">def decrypt(c,e,phi,n):</span><br><span class="line">    t = gmpy2.gcd(e,phi)</span><br><span class="line">    if t != 1:</span><br><span class="line">        e1 = e // t</span><br><span class="line">        d = gmpy2.invert(e1,phi)</span><br><span class="line">        m = pow(c,d,n)</span><br><span class="line">        return m</span><br><span class="line">    </span><br><span class="line">res1 = decrypt(c1,e1,phi1,n1)</span><br><span class="line">res2 = decrypt(c2,e2,phi2,n2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = CRT_list([res1,res2],[n1,n2])</span><br><span class="line">e3 = 14</span><br><span class="line">phi = (q1-1)*(q2-1)</span><br><span class="line">print(gmpy2.gcd(e3,phi))</span><br><span class="line">m = decrypt(c,e3,phi,q1*q2)</span><br><span class="line">print(long_to_bytes(int(gmpy2.iroot(int(m),2)[0])))</span><br></pre></td></tr></table></figure>

<p>怎么说呢，这题目太怪了</p>
<h2 id="情况3："><a href="#情况3：" class="headerlink" title="情况3："></a>情况3：</h2><p>AMM开根</p>
<p>见下一篇博客</p>
<h1 id="十三、NC不互素"><a href="#十三、NC不互素" class="headerlink" title="十三、NC不互素"></a>十三、NC不互素</h1><p>类似于n不互素</p>
<p>这种题目，通过n和c存在公约数求p</p>
<h2 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h2><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import random</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">print(flag)</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line"></span><br><span class="line">p = libnum.generate_prime(1024)</span><br><span class="line">q = libnum.generate_prime(1024)</span><br><span class="line">print(p)</span><br><span class="line">print(q)</span><br><span class="line">n = p * q</span><br><span class="line">e = 65537</span><br><span class="line">c = pow(m*p, e, n)</span><br><span class="line">print(&quot;n=&quot;, n)</span><br><span class="line">print(&quot;c=&quot;, c)</span><br><span class="line">print(&quot;e=&quot;, e)</span><br></pre></td></tr></table></figure>

<p>$\because c \equiv (mp)^e \mod n$，$\therefore c &#x3D; kn + m^ep^e \longrightarrow c &#x3D; kpq + m^ep^e \longrightarrow c &#x3D; p(kq+m^ep^{e-1})$</p>
<p>所以可以通过n和c的最大公约数求出p</p>
<p>之后再求出mp,最后求出m</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"></span><br><span class="line">n =<span class="number">17483770234884142847456666352881633858141093959507406489438832657811880348544517317886235174580364402693136945332374390980468053811072776178864091768180166876221659675217180437370214612891072604883134760061297589091497848817124108984000363937311663848944163413212471490943544013729793140932153932722897244086933590069840634776188515344586162299372418033246808686151342011111253737930983815234958893340565218112060881945578082230607232140507764864201490541905951630320920698022711376246588071419161730102709168468030659029885654176255175171297966568656762020277408125453099365768353256668477237850688484624314512104837</span></span><br><span class="line">c = <span class="number">7756412419736534306267281137444055853970895832135119947012680801728368453412511898214833061840593207999925914861147437172775590961864429038538036044372917920901477955515874667827839423934284921039793035016663689671993982388770276121107464667278667672531024583000281458905472417802844581894023365347884859881069456113169832521363450118618605256637768282911914962650680421804219666243987097956602779278718190490013281291054728762585198175600573970428128728004843715806947600331454660689313029334295614495527134693874900019066579958992524583794853232795458791635025434351607697221423673529269965794629214578773549342054</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">t = gmpy2.gcd(n,c)</span><br><span class="line"><span class="keyword">if</span> t != <span class="number">1</span>:</span><br><span class="line">    p = t</span><br><span class="line">    q = n // p</span><br><span class="line">    d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">    mp = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(mp//p))</span><br></pre></td></tr></table></figure>



<h1 id="十四、Rabin"><a href="#十四、Rabin" class="headerlink" title="十四、Rabin"></a>十四、Rabin</h1><p>Rabin加密选取的加密密钥e &#x3D; 2</p>
<h2 id="密钥生成-1"><a href="#密钥生成-1" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>选取两个大素数p,q<br>$$<br>p,q满足：<br>$$<br>$$<br>p \equiv q \equiv 3(mod \quad 4)<br>$$</p>
<p>$$<br>计算n&#x3D;p×q<br>$$</p>
<p>则(p,q)作为私钥，n作为公钥</p>
<h2 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h2><p>$$<br>c \equiv  m^2(mod \quad n)<br>$$</p>
<h2 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h2><p>$\because c \equiv m^2 \mod n$</p>
<p>即</p>
<p><img src="/../images/RSA/0.png"></p>
<p>根据二次剩余得</p>
<p>$c^{\frac{p-1}{2}} \equiv 1 \mod p$同乘c得：$c^{\frac{p+1}{2}} \equiv c \mod p$，开根号得$c^{\frac{p+1}{4}} \mod p$，所以$m_p &#x3D;c^{\frac{p+1}{4}}$</p>
<p>同理$m_q &#x3D; c^{\frac{q+1}{4}}$</p>
<p>解中国剩余定理</p>
<p><img src="/../images/RSA/1.png"></p>
<p><img src="/../images/RSA/0.jpg" alt="Rabin中的孙子定理"></p>
<p> <img src="/../images/RSA/22.png"></p>
<h2 id="存疑"><a href="#存疑" class="headerlink" title="存疑"></a>存疑</h2><p>m3这个解不太理解，<strong>查了点资料，好像解是通过公式求得的：</strong></p>
<p><img src="/../images/RSA/1.webp" alt="1"></p>
<h2 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line">import random</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot; + str(uuid.uuid4()) + &quot;&#125;&quot;</span><br><span class="line">print(flag)</span><br><span class="line">m = libnum.s2n(flag)</span><br><span class="line">p = libnum.generate_prime(512)</span><br><span class="line">q = libnum.generate_prime(512)</span><br><span class="line">n = p * q</span><br><span class="line">e = 2</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(&quot;p=&quot;, p)</span><br><span class="line">print(&quot;q=&quot;, q)</span><br><span class="line">print(&quot;n=&quot;, n)</span><br><span class="line">print(&quot;c=&quot;, c)</span><br><span class="line">print(&quot;e=&quot;, e)</span><br></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p= <span class="number">13314362720917602133969793252481444316247612541287913579795797774897851142465370812511985605994998073433561235021924708067874236781706611485522371488232623</span></span><br><span class="line">q= <span class="number">10711516497864529822020903304369858958930042711451857859791558135232705853374332295320094676061294774680048276363750484537945067473851592618816785752809803</span></span><br><span class="line">n= <span class="number">142617015943661365869136488949628046624950745436416195175536421279851751774402291519010668496730147866462378904972514253007029491632653461771497495733152729212900224242492221133006321373540619376544526943204146111719397605460529531608654329571698129077171108416638061409327725762114841023226929126272738803269</span></span><br><span class="line">c= <span class="number">3136716033731857617369889733308430982192049734478834150612954276064433287574994581343168243135342097712334250357890492021703404008556737899236668582163912130637742227325170121650071435166332685070232329</span></span><br><span class="line">e= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">inv_p = gmpy2.invert(p, q)</span><br><span class="line">inv_q = gmpy2.invert(q, p)</span><br><span class="line">mp = <span class="built_in">pow</span>(c, (p + <span class="number">1</span>) // <span class="number">4</span>, p)</span><br><span class="line">mq = <span class="built_in">pow</span>(c, (q + <span class="number">1</span>) // <span class="number">4</span>, q)</span><br><span class="line">a = (inv_p * p * mq + inv_q * q * mp) % n</span><br><span class="line">b = n - <span class="built_in">int</span>(a)</span><br><span class="line">c = (inv_p * p * mq - inv_q * q * mp) % n</span><br><span class="line">d = n - <span class="built_in">int</span>(c)</span><br><span class="line"><span class="comment"># 因为rabin 加密有四种结果，全部列出。</span></span><br><span class="line">aa = [a, b, c, d]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> aa:</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(i)))</span><br></pre></td></tr></table></figure>

<h2 id="多次解Rabin"><a href="#多次解Rabin" class="headerlink" title="多次解Rabin"></a>多次解Rabin</h2><p>题目来源NSSCTF ROUND#11</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line"><span class="keyword">assert</span> p &gt; q</span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">65536</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">num1 = (<span class="built_in">pow</span>(p,e,n)-<span class="built_in">pow</span>(q,e,n)) % n</span><br><span class="line">num2 = <span class="built_in">pow</span>(p-q,e,n)</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;num1=&quot;</span>,num1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;num2=&quot;</span>,num2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&quot;</span>,c)</span><br></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">num1= <span class="number">134186458247304184975418956047750205959249518467116558944535042073046353646812210914711656218265319503240074967140027248278994209294869476247136854741631971975560846483033205230015783696055443897579440474585892990793595602095853960468928457703619205343030230201261058516219352855127626321847429189498666288452</span></span><br><span class="line">num2= <span class="number">142252615203395148320392930915384149783801592719030740337592034613073131106036364733480644482188684184951026866672011061092572389846929838149296357261088256882232316029199097203257003822750826537629358422813658558008420810100860520289261141533787464661186681371090873356089237613080052677646446751824502044253</span></span><br><span class="line">n= <span class="number">154128165952806886790805410291540694477027958542517309121222164274741570806324940112942356615458298064007096476638232940977238598879453357856259085001745763666030177657087772721079761302637352680091939676709372354103177660093164629417313468356185431895723026835950366030712541994019375251534778666996491342313</span></span><br><span class="line">c= <span class="number">9061020000447780498751583220055526057707259079063266050917693522289697419950637286020502996753375864826169562714946009146452528404466989211057548905704856329650955828939737304126685040898740775635547039660982064419976700425595503919207903099686497044429265908046033565745195837408532764433870408185128447965</span></span><br><span class="line"></span><br><span class="line">tmp = num1+num2</span><br><span class="line"></span><br><span class="line">p = gmpy2.gcd(n,tmp)</span><br><span class="line">q = n // p</span><br><span class="line"></span><br><span class="line">inv_p = gmpy2.invert(p, q)</span><br><span class="line">inv_q = gmpy2.invert(q, p)</span><br><span class="line"></span><br><span class="line">cs = [c]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    ps = []</span><br><span class="line">    <span class="keyword">for</span> c2 <span class="keyword">in</span> cs:</span><br><span class="line">        r = <span class="built_in">pow</span>(c2, (p + <span class="number">1</span>) // <span class="number">4</span>, p)</span><br><span class="line">        s = <span class="built_in">pow</span>(c2, (q + <span class="number">1</span>) // <span class="number">4</span>, q)</span><br><span class="line"></span><br><span class="line">        x = (r * inv_q * q + s * inv_p * p) % n</span><br><span class="line">        y = (r * inv_q * q - s * inv_p * p) % n</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> ps:</span><br><span class="line">            ps.append(x)</span><br><span class="line">        <span class="keyword">if</span> n - x <span class="keyword">not</span> <span class="keyword">in</span> ps:</span><br><span class="line">            ps.append(n - x)</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">not</span> <span class="keyword">in</span> ps:</span><br><span class="line">            ps.append(y)</span><br><span class="line">        <span class="keyword">if</span> n - y <span class="keyword">not</span> <span class="keyword">in</span> ps:</span><br><span class="line">            ps.append(n - y)</span><br><span class="line">    cs = ps</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> cs:</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>现代密码-非对称加密</category>
      </categories>
      <tags>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔(三)</title>
    <url>/2023/08/24/%E9%9A%8F%E7%AC%94(%E4%B8%89)/</url>
    <content><![CDATA[<p>近日心事较多，写点东西倾诉倾诉</p>
<span id="more"></span>

<p>过生日以来的这几天，学习状态并不是很好，有些心浮气躁，作息也有些乱了，也许是紧张开学前的攻防活动（纯小白，想着稍微接触点攻防的东西，便报了学长推的一个活动），或许也是紧张即将到来的NSSCTF二周年比赛，有幸参与出题，当时没有考虑太多便被劝说去参与出题了，上交题目后跟Harry师傅聊了以后才知道，出题得让选手们有所收获，而不是敷衍了事，因此我担忧以我目前的水准，出的题不太能让大家有所收获，也许会被人臭骂这题目简直是烂中烂吧。</p>
<p>此外，最近老是会想起过往的人与事。</p>
<p>睡前想起初中的一位女性朋友，当时一次偶然巧合加了好友，于是便开始了将近550天的聊天，在此期间也是确认过男女朋友关系，不过在我上高中后，这段感情不欢而散。讲到这，高二的时候也经历过一段半年的感情，事情应从高二的校运动会后讲起，运动会结束后，不知怎的便和这位女同学用起了情头，挺奇妙的，当时也没有考虑太多，就用了。2周后便确认了情侣关系，因为她我参与了晚自习，每晚一起写作业，这段时间还是挺美好的。转眼就来到了寒假，两人回了自己的家，寒假最后一天，一起去了电影院，我记得这是我们为数不多的一起出门的时间（也是我自己太废物了当时，不明白谈恋爱应该经常一起出去玩，有些许后悔），这也是我第一次来电影院。这段感情也是在5月1日后不欢而散。高三开学她便和班级另外一位同学在一起了，直到现在（怪让人羡慕的哈哈）。</p>
<p>想起这些往事，不禁感叹到，当时的生活真是美好啊。每天读读书，还能和人聊聊天，聊一些算是<del>暧昧</del>的话吧，也感叹当时每天竟有如此多话题可聊。而长大后，需要考虑的事情越来越多，因前途，学业，感情，焦虑也越来越多。老是在想着先提升自己，然后才有恋爱，可是，在现如今这样快节奏的社会中，我这种不爱主动的人，真的能有人主动接近吗？真的能在大学谈上恋爱吗？</p>
<p>最后祝读者心想事成。</p>
<p>记于2023年8月24日凌晨1点39分</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>题目收集</title>
    <url>/2023/07/17/%E9%A2%98%E7%9B%AE%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<p>记录一些长知识的题目</p>
<span id="more"></span>



<h1 id="三胞胎素数"><a href="#三胞胎素数" class="headerlink" title="三胞胎素数"></a>三胞胎素数</h1><p>题目来源[TSGCTF 2021]Beginner’s Crypto 2021</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from secret import e</span><br><span class="line">from Crypto.Util.number import getStrongPrime, isPrime</span><br><span class="line"></span><br><span class="line">p = getStrongPrime(1024)</span><br><span class="line">q = getStrongPrime(1024)</span><br><span class="line">N = p * q</span><br><span class="line">phi = (p - 1) * (q - 1)</span><br><span class="line"></span><br><span class="line">with open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;) as f:</span><br><span class="line">    flag = int.from_bytes(f.read(), &#x27;big&#x27;)</span><br><span class="line"></span><br><span class="line">assert(isPrime(e))</span><br><span class="line">assert(isPrime(e + 2))</span><br><span class="line">assert(isPrime(e + 4))</span><br><span class="line"></span><br><span class="line">e1 = pow(e, 0x10001, phi)</span><br><span class="line">e2 = pow(e + 2, 0x10001, phi)</span><br><span class="line">e3 = pow(e + 4, 0x10001, phi)</span><br><span class="line"></span><br><span class="line">c1 = pow(flag, e1, N)</span><br><span class="line">c2 = pow(flag, e2, N)</span><br><span class="line">c3 = pow(flag, e3, N)</span><br><span class="line"></span><br><span class="line">print(f&#x27;p = &#123;p&#125;&#x27;)</span><br><span class="line">print(f&#x27;q = &#123;q&#125;&#x27;)</span><br><span class="line">print(f&#x27;c1 = &#123;c1&#125;&#x27;)</span><br><span class="line">print(f&#x27;c2 = &#123;c2&#125;&#x27;)</span><br><span class="line">print(f&#x27;c3 = &#123;c3&#125;&#x27;)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">p = 167710954518007348037383082265231465648795974011761905177264545864288011527333715495850532989338171489309608848431113452814709692343039027970312735521415071265608660628968391884287240987858607818275329135585153511665148279408708087727501421558738163577629329044315775019460018956186674179846621352371150072281</span><br><span class="line">q = 130354329753344570838569091064852072757046774566775609047544069941246798511317343102715733555464772099991834579660053860799207243561908291522943696711982657846373844514551117658179060004064010647453939332217996817580433587341521331941287365948919907797478197717562721233289937471168288241937022054501586986443</span><br><span class="line">c1 = 2560344169447809042170685026483682125499025654554670516499742981486615082413150123244985585751880264831112089324011804397189638172356179296987581738515619297036118472798499254785110885662931526277474101787493114656242031264678448394380651657330967744585361662315313462698221954777506355498445242300193032704972074020068699180111637362566860530694807230108024167631423062629721393506643291591971626450262144814424411172618188943774725105690851574922374544865628890948773274109561622040022136970632948166009941425683576381155722191980954262373394704682297682490061906408535261437100820855976015526295573831744458528440</span><br><span class="line">c2 = 9041231631916227099296501948589424780380702196870972231114747229225732542137483840187783630590878594711315671224997985975031038623195921968945234067183003568830416719957054703139219879265482072634572699299971785171441858501409377942183918216246312330291820452436486171483461790388518159980027140392750222843449604265528929311978655519463562520038992870162220913137870017065557254099767583925177889051326144499369420594398043223307161794788085369471538477803421726790780799629276012701406231535048423554314287152404245482928538931953627397633165453319078105028671410039195670727134471011040601278722143504641171853743</span><br><span class="line">c3 = 3193069356811106774640161554961405075257002069448498144279061282023129342916422283816661697787316681475161942522570615456264481238277711114193792510286127129056376618422336477707825009085263623755329815306483253646072909132096678270667136193038337386976289222105363398033633185639402128949635525665502328717781718263894690234837016959581149138917064108193064639981137359869717065147934752707676203651598070046066514316196771853484143158367616177332902152347890310640338106015356361617700741042461419248117687350565094928451141103632305400493998164788411031832078388030194992306440474662871408938796429927990102583837</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assert(isPrime(e))</span><br><span class="line">assert(isPrime(e + 2))</span><br><span class="line">assert(isPrime(e + 4))</span><br></pre></td></tr></table></figure>

<p>满足这样条件的$e$只有$e&#x3D;3$</p>
<h2 id="一些定义："><a href="#一些定义：" class="headerlink" title="一些定义："></a>一些定义：</h2><h3 id="孪生素数"><a href="#孪生素数" class="headerlink" title="孪生素数"></a>孪生素数</h3><p><strong>指差等于2的两个素数。</strong></p>
<h3 id="三胞胎素数-1"><a href="#三胞胎素数-1" class="headerlink" title="三胞胎素数"></a>三胞胎素数</h3><p><strong>指三个连续素数，使得其中最大的一个减去最小一个的差不超过6</strong>。</p>
<p>事实上，除了最小的两组三胞胎素数：$(2, 3, 5)$ 和 $(3, 5, 7)$，其它的三胞胎素数都是相差达到<strong>6</strong>的三元数组。除了以上两个特例以外，三胞胎素数分为两类：</p>
<p>A类三胞胎素数，构成为$p$，$p+2$，$p+6$，相差2的两个孪生素数在前面，例如：$(5，7，11)$；$(11，13，17)$； $(17，19，23)$；等等。</p>
<p>B类三胞胎素数，构成为$p$，$p+4$，$p+6$，相差2的两个孪生素数在后面，例如：(7，11，13)；(13，17，19)；(37，41，43)；等等。</p>
<p>当素数p 大于3时，可以证明形同$p$，$p+2$，$p+4$的数组不可能是三胞胎素数。事实上，这三个数对3的模两两不同，所以必然有一个能被3整除。然而这三个数都比3要大，因此一定有一个是3的倍数，从而这个数不是素数。</p>
<p>详见：<a href="https://zh.wikibooks.org/wiki/%E4%B8%89%E8%83%9E%E8%83%8E%E7%B4%A0%E6%95%B0">三胞胎素数 - 维基教科书，自由的教学读本 (wikibooks.org)</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>知道$e&#x3D;3$之后就已知$e_1,e_2,e_3$，然后共模攻击</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">p = <span class="number">167710954518007348037383082265231465648795974011761905177264545864288011527333715495850532989338171489309608848431113452814709692343039027970312735521415071265608660628968391884287240987858607818275329135585153511665148279408708087727501421558738163577629329044315775019460018956186674179846621352371150072281</span></span><br><span class="line">q = <span class="number">130354329753344570838569091064852072757046774566775609047544069941246798511317343102715733555464772099991834579660053860799207243561908291522943696711982657846373844514551117658179060004064010647453939332217996817580433587341521331941287365948919907797478197717562721233289937471168288241937022054501586986443</span></span><br><span class="line">c1 = <span class="number">2560344169447809042170685026483682125499025654554670516499742981486615082413150123244985585751880264831112089324011804397189638172356179296987581738515619297036118472798499254785110885662931526277474101787493114656242031264678448394380651657330967744585361662315313462698221954777506355498445242300193032704972074020068699180111637362566860530694807230108024167631423062629721393506643291591971626450262144814424411172618188943774725105690851574922374544865628890948773274109561622040022136970632948166009941425683576381155722191980954262373394704682297682490061906408535261437100820855976015526295573831744458528440</span></span><br><span class="line">c2 = <span class="number">9041231631916227099296501948589424780380702196870972231114747229225732542137483840187783630590878594711315671224997985975031038623195921968945234067183003568830416719957054703139219879265482072634572699299971785171441858501409377942183918216246312330291820452436486171483461790388518159980027140392750222843449604265528929311978655519463562520038992870162220913137870017065557254099767583925177889051326144499369420594398043223307161794788085369471538477803421726790780799629276012701406231535048423554314287152404245482928538931953627397633165453319078105028671410039195670727134471011040601278722143504641171853743</span></span><br><span class="line">c3 = <span class="number">3193069356811106774640161554961405075257002069448498144279061282023129342916422283816661697787316681475161942522570615456264481238277711114193792510286127129056376618422336477707825009085263623755329815306483253646072909132096678270667136193038337386976289222105363398033633185639402128949635525665502328717781718263894690234837016959581149138917064108193064639981137359869717065147934752707676203651598070046066514316196771853484143158367616177332902152347890310640338106015356361617700741042461419248117687350565094928451141103632305400493998164788411031832078388030194992306440474662871408938796429927990102583837</span></span><br><span class="line"></span><br><span class="line">N = p * q</span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">e = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">e1 = <span class="built_in">pow</span>(e, <span class="number">0x10001</span>, phi)</span><br><span class="line">e2 = <span class="built_in">pow</span>(e + <span class="number">2</span>, <span class="number">0x10001</span>, phi)</span><br><span class="line">e3 = <span class="built_in">pow</span>(e + <span class="number">4</span>, <span class="number">0x10001</span>, phi)</span><br><span class="line"></span><br><span class="line">ee = [e1,e2,e3]</span><br><span class="line">cc = [c1,c2,c3]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ee)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ee)):</span><br><span class="line">        <span class="keyword">if</span> i != j:</span><br><span class="line">            s,x,y = gmpy2.gcdext(ee[i],ee[j])</span><br><span class="line">            m = <span class="built_in">pow</span>(cc[i],x,N) * <span class="built_in">pow</span>(cc[j],y,N) % N</span><br><span class="line">            <span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line">           </span><br></pre></td></tr></table></figure>

<h1 id="以下是有关论文的题目"><a href="#以下是有关论文的题目" class="headerlink" title="以下是有关论文的题目"></a>以下是有关论文的题目</h1><h2 id="N-ma-2-nb-2-mc-2-nd-2"><a href="#N-ma-2-nb-2-mc-2-nd-2" class="headerlink" title="N &#x3D; ma^2 + nb^2 &#x3D; mc^2 + nd^2"></a>N &#x3D; ma^2 + nb^2 &#x3D; mc^2 + nd^2</h2><p>论文：<a href="https://www.jstor.org/stable/0b4b4e65-c7fc-3c15-b716-723b58ec2b20?read-now=1&seq=1">A Note on Euler’s Factoring Problem on JSTOR</a></p>
<p>另外一个链接：[elementary number theory - A generalization of Euler Factorization with $N &#x3D; m a^2 + n b^2 &#x3D; m c^2 + n d^2$ - Mathematics Stack Exchange](<a href="https://math.stackexchange.com/questions/4712807/a-generalization-of-euler-factorization-with-n-m-a2-n-b2-m-c2-n-d2#:~:text=John">https://math.stackexchange.com/questions/4712807/a-generalization-of-euler-factorization-with-n-m-a2-n-b2-m-c2-n-d2#:~:text=John</a> Brillhart discusses a generalization of this method,%3D ma2 %2B nb2 %3D mc2 %2B nd2%2C)</p>
<h3 id="题目来源-NSSCTF-Round11——-ez-fac"><a href="#题目来源-NSSCTF-Round11——-ez-fac" class="headerlink" title="题目来源 NSSCTF#Round11——[ez_fac]"></a>题目来源 NSSCTF#Round11——[ez_fac]</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag,a0,a1,b0,b1</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">e = getPrime(<span class="number">128</span>)</span><br><span class="line">n = p*q</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">pow</span>(a0,<span class="number">2</span>) + e * <span class="built_in">pow</span>(b0,<span class="number">2</span>) == n</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">pow</span>(a1,<span class="number">2</span>) + e * <span class="built_in">pow</span>(b1,<span class="number">2</span>) == n</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&quot;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a0=&quot;</span>,a0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a1=&quot;</span>,a1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b0=&quot;</span>,b0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b1=&quot;</span>,b1)</span><br></pre></td></tr></table></figure>

<p>论文大体内容就是：</p>
<p>如果$N &#x3D; ma^2 + nb^2$，且$N&#x3D;mc^2+nd^2$</p>
<p>$N$即可分解为$N&#x3D; (N,ad-bc)×\frac{n}{(N,ad-bc)}$，括号就是最大公因数</p>
<p>所以$p &#x3D; gcd(N,ad-bc)$</p>
<p>本题还需要推导一下e</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">c= <span class="number">34007465638566836660852768374211870538357285529060206826620688555044780516477877596651414637089490522614456532732711803500304737160162560168303462221485961593760966240770414498297915175227814336224871400766371471776600674705757656616409870237891336752248110367865552469248343708419900511716030176178698949179</span></span><br><span class="line">n= <span class="number">70043427687738872803871163276488213173780425282753969243938124727004843810522473265066937344440899712569316720945145873584064860810161865485251816597432836666987134938760506657782143983431621481190009008491725207321741725979791393566155990005404328775785526238494554357279069151540867533082875900530405903003</span></span><br><span class="line">a0= <span class="number">8369195163678456889416121467476480674288621867182572824570660596055739410903686466334448920102666056798356927389728982948229326705483052970212882852055482</span></span><br><span class="line">a1= <span class="number">8369195163678456889416121462308686152524805984209312455308229689034789710117101859597220211456125364647704791637845189120538925088375209397006380815921158</span></span><br><span class="line">b0= <span class="number">25500181489306553053743739056022091355379036380919737553326529889338409847082228856006303427136881468093863020843230477979</span></span><br><span class="line">b1= <span class="number">31448594528370020763962343185054872105044827103889010592635556324009793301024988530934510929565983517651356856506719032859</span></span><br><span class="line"></span><br><span class="line">tmp = a0*b1 - a1*b0</span><br><span class="line">e = (n - <span class="built_in">pow</span>(a0,<span class="number">2</span>)) // <span class="built_in">pow</span>(b0,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p = gmpy2.gcd(tmp,n)</span><br><span class="line">q = n // p</span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>



<h2 id="n-p-r×q"><a href="#n-p-r×q" class="headerlink" title="n &#x3D; p^r×q"></a>n &#x3D; p^r×q</h2><h3 id="题目来源-D-3CTF-2022-——d3factor"><a href="#题目来源-D-3CTF-2022-——d3factor" class="headerlink" title="题目来源[D^3CTF 2022] ——d3factor"></a>题目来源[D^3CTF 2022] ——d3factor</h3><p>论文：<a href="https://eprint.iacr.org/2015/399.pdf">399.pdf (iacr.org)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import bytes_to_long, getPrime</span><br><span class="line">from secret import msg</span><br><span class="line">from sympy import nextprime</span><br><span class="line">from gmpy2 import invert</span><br><span class="line">from hashlib import md5</span><br><span class="line"></span><br><span class="line">flag = &#x27;d3ctf&#123;&#x27;+md5(msg).hexdigest()+&#x27;&#125;&#x27;</span><br><span class="line">p = getPrime(256)</span><br><span class="line">q = getPrime(256)</span><br><span class="line">assert p &gt; q</span><br><span class="line">n = p * q</span><br><span class="line">e = 0x10001</span><br><span class="line">m = bytes_to_long(msg)</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line"></span><br><span class="line">N = pow(p, 7) * q</span><br><span class="line">phi = pow(p, 6) * (p - 1) * (q - 1)</span><br><span class="line">d1 = getPrime(2000)</span><br><span class="line">d2 = nextprime(d1 + getPrime(1000))</span><br><span class="line">e1 = invert(d1, phi)</span><br><span class="line">e2 = invert(d2, phi)</span><br><span class="line"></span><br><span class="line">print(f&#x27;c = &#123;c&#125;&#x27;)</span><br><span class="line">print(f&#x27;N = &#123;N&#125;&#x27;)</span><br><span class="line">print(f&#x27;e1 = &#123;e1&#125;&#x27;)</span><br><span class="line">print(f&#x27;e2 = &#123;e2&#125;&#x27;)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">c = </span><br><span class="line">N = </span><br><span class="line">e1 = </span><br><span class="line">e2 = </span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="论文内容及证明过程"><a href="#论文内容及证明过程" class="headerlink" title="论文内容及证明过程"></a>论文内容及证明过程</h3><p><img src="/../images/paper/0.png"></p>
<p>论文大致内容就是<strong>对于</strong>$N &#x3D; p^rq$，<strong>当两个解密密钥</strong>$d_1$,$d_2$差值不超过$N^{\frac{r(r-1)}{(r+1)^2}}$</p>
<p>即$|d_1-d_2| &lt; N^{\frac{r(r-1)}{(r+1)^2}}$的时候，可以在多项式的时间内分解出$p$</p>
<p>其证明过程如下：</p>
<p>$\because N &#x3D;p^rq$，$\phi(N) &#x3D; p^{r-1}(p-1)(q-1)$</p>
<p>有<br>$$<br>\left{\begin{matrix}<br>e_1d_1 \equiv 1 \mod \phi(N) \quad ①\<br>e_2d_2 \equiv 1 \mod \phi(N) \quad ②\<br>\end{matrix}\right.\<br>$$<br>把①式乘$e_2$，②式乘$e_1$再相减得</p>
<p>$e_1e_2(d_1-d_2)-(e_2-e_1) \equiv 0 \mod \phi(N)$</p>
<p>根据论文，把$\phi(N)$用$p^{r-1}$替代掉</p>
<p>则有$e_1e_2(d_1-d_2)-(e_2-e_1) \equiv 0 \mod p^{r-1}$</p>
<p>$d_1-d_2$就是$e_1e_2x - (e_2-e_1) \equiv 0 \mod p^{r-1}$的根</p>
<p>可以用coppersmith求出$x$</p>
<p>然后计算$gcd(e_1e_2x - (e_2-e_1),N) &#x3D; gcd(k×p^{r-1}(p-1)(q-1),p^rq) &#x3D; g$</p>
<p>利用这个g<br>$$<br>p &#x3D;<br>\left{\begin{matrix}<br>g^{\frac{1}{r-1}},\quad if\quad  g &#x3D; p^{r-1}\<br>g^{\frac{1}{r}},\quad if \quad g &#x3D; p^r\<br>\frac{N}{g},\quad if\quad  g &#x3D; p^{r-1}q<br>\end{matrix}\right.<br>$$</p>
<h3 id="本题解答"><a href="#本题解答" class="headerlink" title="本题解答"></a>本题解答</h3><p>根据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="built_in">pow</span>(p, <span class="number">7</span>) * q</span><br><span class="line">phi = <span class="built_in">pow</span>(p, <span class="number">6</span>) * (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d1 = getPrime(<span class="number">2000</span>)</span><br><span class="line">d2 = nextprime(d1 + getPrime(<span class="number">1000</span>))</span><br></pre></td></tr></table></figure>

<p>可以判断出$|d_1-d_2|\approx 1000bit$，$N&#x3D; 2048bbit$，所以$|d_1-d_2|&lt;N^{\frac{r(r-1)}{(r+1)^2}} \approx 1344bit $</p>
<p>满足论文条件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">2420624631315473673388732074340410215657378096737020976722603529598864338532404224879219059105950005655100728361198499550862405660043591919681568611707967</span></span><br><span class="line">N = <span class="number">1476751427633071977599571983301151063258376731102955975364111147037204614220376883752032253407881568290520059515340434632858734689439268479399482315506043425541162646523388437842149125178447800616137044219916586942207838674001004007237861470176454543718752182312318068466051713087927370670177514666860822341380494154077020472814706123209865769048722380888175401791873273850281384147394075054950169002165357490796510950852631287689747360436384163758289159710264469722036320819123313773301072777844457895388797742631541101152819089150281489897683508400098693808473542212963868834485233858128220055727804326451310080791</span></span><br><span class="line">e1 = <span class="number">425735006018518321920113858371691046233291394270779139216531379266829453665704656868245884309574741300746121946724344532456337490492263690989727904837374279175606623404025598533405400677329916633307585813849635071097268989906426771864410852556381279117588496262787146588414873723983855041415476840445850171457530977221981125006107741100779529209163446405585696682186452013669643507275620439492021019544922913941472624874102604249376990616323884331293660116156782891935217575308895791623826306100692059131945495084654854521834016181452508329430102813663713333608459898915361745215871305547069325129687311358338082029</span></span><br><span class="line">e2 = <span class="number">1004512650658647383814190582513307789549094672255033373245432814519573537648997991452158231923692387604945039180687417026069655569594454408690445879849410118502279459189421806132654131287284719070037134752526923855821229397612868419416851456578505341237256609343187666849045678291935806441844686439591365338539029504178066823886051731466788474438373839803448380498800384597878814991008672054436093542513518012957106825842251155935855375353004898840663429274565622024673235081082222394015174831078190299524112112571718817712276118850981261489528540025810396786605197437842655180663611669918785635193552649262904644919</span></span><br><span class="line"></span><br><span class="line">a = e1 * e2</span><br><span class="line">b = (e2 - e1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(N))			</span><br><span class="line">f = a*x - b</span><br><span class="line">f = f.monic()</span><br><span class="line">res =  f.small_roots(<span class="number">2</span>^<span class="number">1000</span>,beta = <span class="number">0.4</span>)		<span class="comment">#根据d1-d2大概的范围确定上限</span></span><br><span class="line"></span><br><span class="line">ans = <span class="built_in">int</span>(res[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">g = gcd(a*ans - b,N)</span><br><span class="line"><span class="comment">#print(g.nbits())</span></span><br><span class="line"><span class="comment">#g = 1534bit</span></span><br><span class="line"></span><br><span class="line">p = gmpy2.iroot(g,<span class="number">6</span>)[<span class="number">0</span>]</span><br><span class="line">q = N // (p^<span class="number">7</span>)</span><br><span class="line">n = p*q</span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">msg = long_to_bytes(<span class="built_in">int</span>(m))</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;d3ctf&#123;&quot;</span> + md5(msg).hexdigest() + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<p>$\because g &#x3D; 1534bit$，$\therefore p &#x3D; g^{\frac{1}{6}}$</p>
<h2 id="RSA与格结合，且多组n-e-c"><a href="#RSA与格结合，且多组n-e-c" class="headerlink" title="RSA与格结合，且多组n,e,c"></a>RSA与格结合，且多组n,e,c</h2><h3 id="题目来源-NUSTCTF-2022-新生赛-——lattice"><a href="#题目来源-NUSTCTF-2022-新生赛-——lattice" class="headerlink" title="题目来源[NUSTCTF 2022 新生赛]——lattice"></a>题目来源[NUSTCTF 2022 新生赛]——lattice</h3><p>论文：<a href="https://www.ijcsi.org/papers/IJCSI-9-2-1-311-314.pdf">IJCSI-9-2-1-311-314.pdf</a></p>
<p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from random import randint</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">flag = bytes_to_long(flag)</span><br><span class="line">d = getPrime(randint(370, 390))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def enc(i):</span><br><span class="line">    print()</span><br><span class="line">    p = getPrime(512)</span><br><span class="line">    q = getPrime(512)</span><br><span class="line">    n = p * q</span><br><span class="line">    phi = (p - 1) * (q - 1)</span><br><span class="line">    e = inverse(d, phi)</span><br><span class="line">    c = pow(flag, e, n)</span><br><span class="line">    print(f&#x27;e_&#123;i&#125; =&#x27;, e)</span><br><span class="line">    print(f&#x27;n_&#123;i&#125; =&#x27;, n)</span><br><span class="line">    print(f&#x27;c_&#123;i&#125; =&#x27;, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    for i in range(3):</span><br><span class="line">        enc(i)</span><br><span class="line"></span><br><span class="line"># e_0 = 37389635736858807810703086504264263440188928763651776502954117173983775626039037008534821321761858567723984257427640816113325770208734640385635663643682102780255726244659849205653007212192504491177021176624605722718152646889627480051142935241036578957272339153039961711802753021931124235464986935316295647379</span><br><span class="line"># n_0 = 87704526707772151782606625126900349506318713860335977395824997219721333991491994027303721441548488339412359519408127174109547119019245873976917916080340858937125736650376514406944094998893225164676363063781400756374403299951466867573215964360920244878373810391250391475087527409213204756990192602517961590163</span><br><span class="line"># c_0 = 78656123855003406993963573497876652287109947684890741747390020445306861422604130132525802389554149844489256622057009394678814584233565675702142297935509191018145970589418173328145004732595569847696022333024124469320873194195223535859964387627938665526123562969554622541694399263934496631337485091067073489148</span><br><span class="line"></span><br><span class="line"># e_1 = 28535169211141109871379321582501492434722235009040085167442370469971731780018594508141105234950857774463438226249819106596920677559656398153362076685288045484306156454558741088396794170762527953573082734587618137075161676392362016474076363311708889307420903699720319611668580377903356783222664068961626803615</span><br><span class="line"># n_1 = 134298877057487865189085342936485527664167450453080897084604607959501054859295769447683135156167266222961308751016451904929475702646252122360203167489936020076488657815646993920082535307414536854323149177250531362615850689341066360635074886835720438532107976530111551202845697404444502476862934946146194420313</span><br><span class="line"># c_1 = 3208711484494445700905074340207543865325589037128163311082565190422756093807236786011349707275838139469873445326457948489588753029946395247710197747538418278782966047404435385208682596795152082296050804126524129644617710791433973098499266439604632728957505961744280687343384601998774018570047292904007768763</span><br><span class="line"></span><br><span class="line"># e_2 = 27653153186459366670449283776658896188717513017934031993526241644501850206894800647711159987946276669184047769965182746812351757618147642060630769822810070480507035319320426666128599562714143342910248758055424582501972900763786232170145957578683616604737178839977216709381529813768748145393798635858691196687</span><br><span class="line"># n_2 = 82113192811251631639012300385672674439485256963081847790431181633372052788107703751257606763043873164706839243919206719171536710944060815484051324239120708906418093409305166299531826404505861042666985630956832163750255358332156122245372899824101210233079028706971698312018388678352739819636695333269309456613</span><br><span class="line"># c_2 = 79145689398302968140315554300835109898158799236562716569497147385375487041207363302776833573990584370222316102267792795080448018216133931915984139305260191001847394275311719986838969706049641052337337102739487620502723651258075501409442088938776353037366614208693030741599888985069155346722608948495955447606</span><br></pre></td></tr></table></figure>



<p>令$M &#x3D; \sqrt{N_{max}}$，$M$是一组$N$中最大的$N$并且开根号。这组$N$满足：$N_1&lt;N_2&lt;\dots&lt;N_r &lt;2N_1$</p>
<p>又$\because e_id \equiv 1 (\mod \phi(N_i))$</p>
<p>这里把它写成$e_id &#x3D; 1+k_i\phi{N_i}$</p>
<p>假设$\phi(N_i)$可以写成$k_i(N_i-s_i)$的形式。其中$|s_i&lt;3N_i^{\frac{1}{2}}|$</p>
<p>则$e_id &#x3D; 1 + k_i(N_i-s_i)$</p>
<p>化简得$e_id-k_iN_i &#x3D; 1-k_is_i$</p>
<p>所以我们有$r+1$个等式:</p>
<p><img src="/../images/Lattice2/10.png"></p>
<p>写成矩阵相乘的形式</p>
<p><img src="/../images/Lattice2/11.png"></p>
<p>因为最后的目标向量满足LLL算法，所以我们可以得到$dM$</p>
<p>求得$dM$之后，我们可以求得$d$</p>
<p>exp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import libnum</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">e0 = 37389635736858807810703086504264263440188928763651776502954117173983775626039037008534821321761858567723984257427640816113325770208734640385635663643682102780255726244659849205653007212192504491177021176624605722718152646889627480051142935241036578957272339153039961711802753021931124235464986935316295647379</span><br><span class="line">n0 = 87704526707772151782606625126900349506318713860335977395824997219721333991491994027303721441548488339412359519408127174109547119019245873976917916080340858937125736650376514406944094998893225164676363063781400756374403299951466867573215964360920244878373810391250391475087527409213204756990192602517961590163</span><br><span class="line">c0 = 78656123855003406993963573497876652287109947684890741747390020445306861422604130132525802389554149844489256622057009394678814584233565675702142297935509191018145970589418173328145004732595569847696022333024124469320873194195223535859964387627938665526123562969554622541694399263934496631337485091067073489148</span><br><span class="line"></span><br><span class="line">e1 = 28535169211141109871379321582501492434722235009040085167442370469971731780018594508141105234950857774463438226249819106596920677559656398153362076685288045484306156454558741088396794170762527953573082734587618137075161676392362016474076363311708889307420903699720319611668580377903356783222664068961626803615</span><br><span class="line">n1 = 134298877057487865189085342936485527664167450453080897084604607959501054859295769447683135156167266222961308751016451904929475702646252122360203167489936020076488657815646993920082535307414536854323149177250531362615850689341066360635074886835720438532107976530111551202845697404444502476862934946146194420313</span><br><span class="line">c1 = 3208711484494445700905074340207543865325589037128163311082565190422756093807236786011349707275838139469873445326457948489588753029946395247710197747538418278782966047404435385208682596795152082296050804126524129644617710791433973098499266439604632728957505961744280687343384601998774018570047292904007768763</span><br><span class="line"></span><br><span class="line">e2 = 27653153186459366670449283776658896188717513017934031993526241644501850206894800647711159987946276669184047769965182746812351757618147642060630769822810070480507035319320426666128599562714143342910248758055424582501972900763786232170145957578683616604737178839977216709381529813768748145393798635858691196687</span><br><span class="line">n2 = 82113192811251631639012300385672674439485256963081847790431181633372052788107703751257606763043873164706839243919206719171536710944060815484051324239120708906418093409305166299531826404505861042666985630956832163750255358332156122245372899824101210233079028706971698312018388678352739819636695333269309456613</span><br><span class="line">c2 = 79145689398302968140315554300835109898158799236562716569497147385375487041207363302776833573990584370222316102267792795080448018216133931915984139305260191001847394275311719986838969706049641052337337102739487620502723651258075501409442088938776353037366614208693030741599888985069155346722608948495955447606</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = [n0,n1,n2]</span><br><span class="line">M = isqrt(max(n))</span><br><span class="line"></span><br><span class="line">ge = [[M,e0,e1,e2],</span><br><span class="line">    [0,-n0,0,0],</span><br><span class="line">    [0,0,-n1,0],</span><br><span class="line">    [0,0,0,-n2]]</span><br><span class="line">Ge = Matrix(ZZ,ge)</span><br><span class="line"></span><br><span class="line">dM = Ge.LLL()[0][0]</span><br><span class="line">d = abs(dM) // M</span><br><span class="line">m = pow(c0,d,n0)</span><br><span class="line">print(libnum.n2s(int(m)))</span><br></pre></td></tr></table></figure>

<h2 id="cve-of-RSA"><a href="#cve-of-RSA" class="headerlink" title="cve of RSA"></a>cve of RSA</h2><p>论文：<a href="https://crocs.fi.muni.cz/_media/public/papers/nemec_roca_ccs17_preprint.pdf">The Return of Coppersmith’s Attack:Practical Factorization of Widely Used RSA Moduli (muni.cz)</a></p>
<p>如果p,q是以$p &#x3D; k×M + 65537^a \mod M$的形式产生的，M是个光滑数</p>
<p>攻击脚本：<a href="https://github.com/jvdsn/crypto-attacks">jvdsn&#x2F;crypto-attacks: Python implementations of cryptographic attacks and utilities. (github.com)</a></p>
<p>根据结论调参</p>
<p><img src="/../images/paper/1.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kbits = <span class="number">37</span></span><br><span class="line">abit = <span class="number">62</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">M = <span class="number">962947420735983927056946215901134429196419130606213075415963491270</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    k = getRandomNBitInteger(kbits)</span><br><span class="line">    a = getRandomNBitInteger(abit)</span><br><span class="line">    p = k * M + <span class="built_in">pow</span>(<span class="number">0x10001</span>, a, M)</span><br><span class="line">    <span class="keyword">if</span> isPrime(p):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    l = getRandomNBitInteger(kbits)</span><br><span class="line">    b = getRandomNBitInteger(abit)</span><br><span class="line">    q = l * M + <span class="built_in">pow</span>(<span class="number">0x10001</span>, b, M)</span><br><span class="line">    <span class="keyword">if</span> isPrime(q):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">N = p * q</span><br><span class="line">c = <span class="built_in">pow</span>(m, <span class="number">0x10001</span>, N)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;N =&#x27;</span>, N)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c =&#x27;</span>, c)</span><br><span class="line"><span class="comment"># N = 10375505512698590697230540440656541719204263636911186773264796164624307537559854575146689396086897683887657357280574643827597720286007334491967184402911331</span></span><br><span class="line"><span class="comment"># c = 9452671754308991307639149928469686004498992794878178108851267184995226471125632100149955622693448809888842182351036616823747409631021412523576720606919605</span></span><br></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log2</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> Zmod</span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> factor</span><br><span class="line"></span><br><span class="line">path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.realpath(os.path.abspath(__file__)))))</span><br><span class="line"><span class="keyword">if</span> sys.path[<span class="number">1</span>] != path:</span><br><span class="line">    sys.path.insert(<span class="number">1</span>, path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> shared.small_roots <span class="keyword">import</span> howgrave_graham</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_prime_power_divisors</span>(<span class="params">M</span>):</span><br><span class="line">    divisors = []</span><br><span class="line">    <span class="keyword">for</span> p, e <span class="keyword">in</span> factor(M):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, e + <span class="number">1</span>):</span><br><span class="line">            divisors.append(p ** i)</span><br><span class="line"></span><br><span class="line">    divisors.sort()</span><br><span class="line">    <span class="keyword">return</span> divisors</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Algorithm 2.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_max_M_</span>(<span class="params">M, ord_</span>):</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> _prime_power_divisors(M):</span><br><span class="line">        ordp = Zmod(p)(<span class="number">65537</span>).multiplicative_order()</span><br><span class="line">        <span class="keyword">if</span> ord_ % ordp != <span class="number">0</span>:</span><br><span class="line">            M //= p</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> M</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Section 2.7.2.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_greedy_find_M_</span>(<span class="params">n, M</span>):</span><br><span class="line">    <span class="built_in">ord</span> = Zmod(M)(<span class="number">65537</span>).multiplicative_order()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        best_r = <span class="number">0</span></span><br><span class="line">        best_ord_ = <span class="built_in">ord</span></span><br><span class="line">        best_M_ = M</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> _prime_power_divisors(<span class="built_in">ord</span>):</span><br><span class="line">            ord_ = <span class="built_in">ord</span> // p</span><br><span class="line">            M_ = compute_max_M_(M, ord_)</span><br><span class="line">            r = (log2(<span class="built_in">ord</span>) - log2(ord_)) / (log2(M) - log2(M_))</span><br><span class="line">            <span class="keyword">if</span> r &gt; best_r:</span><br><span class="line">                best_r = r</span><br><span class="line">                best_ord_ = ord_</span><br><span class="line">                best_M_ = M_</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> log2(best_M_) &lt; log2(n) / <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> M</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ord</span> = best_ord_</span><br><span class="line">        M = best_M_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorize</span>(<span class="params">N, M, m, t, g=<span class="number">65537</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Recovers the prime factors from a modulus using the ROCA method.</span></span><br><span class="line"><span class="string">    More information: Nemec M. et al., &quot;The Return of Coppersmith’s Attack: Practical Factorization of Widely Used RSA Moduli&quot;</span></span><br><span class="line"><span class="string">    :param N: the modulus</span></span><br><span class="line"><span class="string">    :param M: the primorial used to generate the primes</span></span><br><span class="line"><span class="string">    :param m: the m parameter for Coppersmith&#x27;s method</span></span><br><span class="line"><span class="string">    :param t: the t parameter for Coppersmith&#x27;s method</span></span><br><span class="line"><span class="string">    :param g: the generator value (default: 65537)</span></span><br><span class="line"><span class="string">    :return: a tuple containing the prime factors</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    logging.info(<span class="string">&quot;Generating M&#x27;...&quot;</span>)</span><br><span class="line">    M_ = _greedy_find_M_(N, M)</span><br><span class="line">    zmodm_ = Zmod(M_)</span><br><span class="line">    g = zmodm_(g)</span><br><span class="line">    c_ = zmodm_(N).log(g)</span><br><span class="line">    ord_ = g.multiplicative_order()</span><br><span class="line"></span><br><span class="line">    x = Zmod(N)[<span class="string">&quot;x&quot;</span>].gen()</span><br><span class="line">    X = <span class="built_in">int</span>(<span class="number">2</span> * N ** <span class="number">0.5</span> // M_)</span><br><span class="line">    logging.info(<span class="string">&quot;Starting exhaustive a&#x27; search...&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> a_ <span class="keyword">in</span> <span class="built_in">range</span>(c_ // <span class="number">2</span>, (c_ + ord_) // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">        f = M_ * x + <span class="built_in">int</span>(g ** a_)</span><br><span class="line">        <span class="keyword">for</span> k_, <span class="keyword">in</span> howgrave_graham.modular_univariate(f, N, m, t, X):</span><br><span class="line">            p = <span class="built_in">int</span>(f(k_))</span><br><span class="line">            <span class="keyword">if</span> N % p == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> p, N // p</span><br><span class="line">      </span><br><span class="line">N=<span class="number">10375505512698590697230540440656541719204263636911186773264796164624307537559854575146689396086897683887657357280574643827597720286007334491967184402911331</span></span><br><span class="line">M=<span class="number">962947420735983927056946215901134429196419130606213075415963491270</span></span><br><span class="line">m = <span class="number">5</span></span><br><span class="line">t = <span class="number">6</span></span><br><span class="line">p,q = factorize(N,M,m,t)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p=&quot;</span>,p)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;q=&quot;</span>,q)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个脚本我是在sagemath跑的</p>
<p>得到p,q后有手就行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">p=<span class="number">85179386137518452231354185509698113331528483782580002217930594759662020757433</span></span><br><span class="line">q=<span class="number">121807704694511224555991770528701515984374557330058194205583818929517699002107</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">9452671754308991307639149928469686004498992794878178108851267184995226471125632100149955622693448809888842182351036616823747409631021412523576720606919605</span></span><br><span class="line"></span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,p*q)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>



<h1 id="多项式分解"><a href="#多项式分解" class="headerlink" title="多项式分解"></a>多项式分解</h1><h2 id="2021强网拟态——OnlyRSA"><a href="#2021强网拟态——OnlyRSA" class="headerlink" title="2021强网拟态——OnlyRSA"></a>2021强网拟态——OnlyRSA</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">n = </span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># c = </span></span><br></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = </span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">digits = n.digits(<span class="number">11</span>)</span><br><span class="line">f = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, each <span class="keyword">in</span> <span class="built_in">enumerate</span>(digits):</span><br><span class="line">    f += each * x ^ i</span><br><span class="line"></span><br><span class="line">factors = f.factor_list()</span><br><span class="line"></span><br><span class="line">p = factors[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">q = factors[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">p = p(x=<span class="number">11</span>)</span><br><span class="line">q = q(x=<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">d = inverse_mod(<span class="number">65537</span>,(p-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,p)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br></pre></td></tr></table></figure>







<h1 id="coppersmith"><a href="#coppersmith" class="headerlink" title="coppersmith"></a>coppersmith</h1><h2 id="comedy（先搁着）"><a href="#comedy（先搁着）" class="headerlink" title="comedy（先搁着）"></a>comedy（先搁着）</h2><p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2, libnum</span><br><span class="line">from secret import flag1, flag2</span><br><span class="line"></span><br><span class="line">m = libnum.s2n(flag1)</span><br><span class="line">assert m.bit_length() &lt; 200</span><br><span class="line">B = gmpy2.next_prime(libnum.s2n(flag2))</span><br><span class="line">A = (2022 - 2023 * m) % B</span><br><span class="line">leak = pow(2, 2023, B)</span><br><span class="line">print(A)</span><br><span class="line">print(leak)</span><br><span class="line"># 493275281479560936332761096886786925792234184811353209227551802099268192839677496844153534128991899414803550843408607188612593757622064753867565869035222715177143938385039508273050267347710495512806264863554858016145161165422812554800693811328453743229819656381224407015421235005940088439590887928051969351426291843586132741521121351667152673680122929827805479163871436776753859965413192837591532468372</span><br><span class="line"># 238829196127128263156194898141748280130190920343265228257398802867203846004703877952990524473329125233083096275276064071930416561616135910190674099345267027039386328203653489152769309498199556401574021633071022874689081585677578010276529507102304828451681000682208089162940529052283763507244593173690786957816545746540436261888398732172965945762569416702401859253725696471593023885944262561159982327952</span><br></pre></td></tr></table></figure>

<h2 id="高位攻击"><a href="#高位攻击" class="headerlink" title="高位攻击"></a>高位攻击</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from secrets import flag</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">p = getPrime(1024)</span><br><span class="line">q = getPrime(1024)</span><br><span class="line">n = p*q</span><br><span class="line">e = 65537</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = pow(m,e,n)</span><br><span class="line">print(&#x27;n =&#x27;, n)</span><br><span class="line">print(&#x27;c =&#x27;, c)</span><br><span class="line">print(&#x27;p0 =&#x27;, ((p&gt;&gt;128)&lt;&lt;128))</span><br><span class="line"># n = 12722276084782012506939748218137061976694333623308770803193278921311358642857520720238223717188895787376761058057320570031791633540549052360890626849683959794619430207976509336964838302913532815872846936103400538093765972176693960613553754981804951861018999147210521057815783304998144581807982126753283124281516688846477783545704858051397854514128591265938874177108889498151756070102637171159497913559176230984485047937009449456335164657258487948113487961895079102836099947427765851897399603733885367848305266219390271858890481731238036781050541110612526113637880146841891893392904381138771618976655066294938275191591</span><br><span class="line"># c = 7016802271682704586027412586496213357494728781654536670879262263911645812024904159932204545849316301445405237966933240237035426118442003499546014556123485534516682277683392394418823209992176414301314576069643211825678886511259850322068086838470004809816539278374905405029448429356654864943156018053547494263664714952593505357117355251742922245508277007069593675629222770814317602710615647062020095140444497647478051326857816298790397174877223117345612840890905447851689835046066164443064435495141117872095457539285213399905708851752673701650986197704683439495235659865937503527178246189185724246027890778434827868479</span><br><span class="line"># p0 = 121612618057439377491893234820394610861816815559052233952438700644930219565204914707604533201740057532331014637555250302342831261394993528125583478630623993361944114671033382653887624385660705353904988324932092635052885387222723368916634052933090217574600695084708857274271614116870074627080278200070403260416</span><br></pre></td></tr></table></figure>

<p><strong>p高位泄露，未知位是128bit</strong></p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n = <span class="number">12722276084782012506939748218137061976694333623308770803193278921311358642857520720238223717188895787376761058057320570031791633540549052360890626849683959794619430207976509336964838302913532815872846936103400538093765972176693960613553754981804951861018999147210521057815783304998144581807982126753283124281516688846477783545704858051397854514128591265938874177108889498151756070102637171159497913559176230984485047937009449456335164657258487948113487961895079102836099947427765851897399603733885367848305266219390271858890481731238036781050541110612526113637880146841891893392904381138771618976655066294938275191591</span></span><br><span class="line">c = <span class="number">7016802271682704586027412586496213357494728781654536670879262263911645812024904159932204545849316301445405237966933240237035426118442003499546014556123485534516682277683392394418823209992176414301314576069643211825678886511259850322068086838470004809816539278374905405029448429356654864943156018053547494263664714952593505357117355251742922245508277007069593675629222770814317602710615647062020095140444497647478051326857816298790397174877223117345612840890905447851689835046066164443064435495141117872095457539285213399905708851752673701650986197704683439495235659865937503527178246189185724246027890778434827868479</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">high_p = <span class="number">121612618057439377491893234820394610861816815559052233952438700644930219565204914707604533201740057532331014637555250302342831261394993528125583478630623993361944114671033382653887624385660705353904988324932092635052885387222723368916634052933090217574600695084708857274271614116870074627080278200070403260416</span></span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = high_p + x</span><br><span class="line">x = f.small_roots(X = <span class="number">2</span>^<span class="number">128</span>,beta = <span class="number">0.4</span>)</span><br><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">    p = high_p + <span class="built_in">int</span>(x[<span class="number">0</span>])</span><br><span class="line">    q = n // p</span><br><span class="line">    d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">    m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#flag&#123;W0W_y0u_rea1ly_go0d_at_us3_s4g3!&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="在异或基础上夹杂移位"><a href="#在异或基础上夹杂移位" class="headerlink" title="在异或基础上夹杂移位"></a>在异或基础上夹杂移位</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from secret import flag</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p, q = getPrime(1024), getPrime(1024)</span><br><span class="line">N = p * q</span><br><span class="line">p0 = p ^ (bytes_to_long(flag)&lt;&lt;444)</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = pow(m, 65537, N)</span><br><span class="line">print(len(flag))</span><br><span class="line">print(&#x27;c=&#x27;,c)</span><br><span class="line">print(&#x27;N=&#x27;,N)</span><br><span class="line">print(&#x27;p0=&#x27;,p0)</span><br><span class="line"></span><br><span class="line"># 54</span><br><span class="line"># c= 6187845844052645335477666563187579997555293403110620879123121166924703361821847984760733842049752886698011561451715570810292323756091403783920480396052120046379755571530451812078574368413924390017994278703794257118954968480994077586245800902748815905644287545189605031883291488844527496906890127546594960138582150272568163575590734246290813150131949296550974206595456421136190026954855755623761557179760444906148376433584795779131477110538212742401420633087881506416368853221110426491868881029814841479615979710066371796507692025126150957315754738584387325388998533227577023142894876376702128870643448600352603905149</span><br><span class="line"># N= 14195810221536708489210274086946022255792382922322850338983263099316341767896809249586174293795778082892237356582757544364274847341220303582304283372889068290282580493623042441421715338444710303281638639785784613434328659529884972238348336971186339482788748316527376410510261228354155806341136524162787121212184386900663470590652770503564816948407257603737938414126069053610568675347826390537145556511048774030823322301932088595499671755944744816524811272617200683384649389274196659297432212847319503330409792704612575414010711158873031786577877685578976140462539734553598745329712188216200905451774357282278403189943</span><br><span class="line"># p0= 111984935426070810628244029907949697819351004665202173622240566580193974673163315128983603277856218378729883402496424467491406698035050254407170555432448523469880166015507303737468316933545613178461925283040643344197452758878116752692499745309765526523083790825015522124083482964296662782850606081657447935191</span><br></pre></td></tr></table></figure>

<p><strong>看到异或就想起LitCTF那道Babyxor，但这题不大一样，因为把m进行了左移操作</strong></p>
<p><strong>因为m左移444位，这样子m后面444位都是0，所以异或之后，不影响p低位444值</strong></p>
<p><strong>而且54长度的flag转成int型数据是432，左移444位后是876位，异或之后p高(1024-876)&#x3D;148位也是不变的</strong></p>
<p><strong>所以考点就是p部分高位和部分低位泄露</strong></p>
<p><strong>先取了444低位：<code>plow = p0 % 2^445</code></strong></p>
<p><strong>然后得到148高位：<code>phigh = (p0 &gt;&gt; 876) &lt;&lt; 876</code></strong></p>
<p><strong>exp:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">p0 = 111984935426070810628244029907949697819351004665202173622240566580193974673163315128983603277856218378729883402496424467491406698035050254407170555432448523469880166015507303737468316933545613178461925283040643344197452758878116752692499745309765526523083790825015522124083482964296662782850606081657447935191</span><br><span class="line">c = 6187845844052645335477666563187579997555293403110620879123121166924703361821847984760733842049752886698011561451715570810292323756091403783920480396052120046379755571530451812078574368413924390017994278703794257118954968480994077586245800902748815905644287545189605031883291488844527496906890127546594960138582150272568163575590734246290813150131949296550974206595456421136190026954855755623761557179760444906148376433584795779131477110538212742401420633087881506416368853221110426491868881029814841479615979710066371796507692025126150957315754738584387325388998533227577023142894876376702128870643448600352603905149</span><br><span class="line">n = 14195810221536708489210274086946022255792382922322850338983263099316341767896809249586174293795778082892237356582757544364274847341220303582304283372889068290282580493623042441421715338444710303281638639785784613434328659529884972238348336971186339482788748316527376410510261228354155806341136524162787121212184386900663470590652770503564816948407257603737938414126069053610568675347826390537145556511048774030823322301932088595499671755944744816524811272617200683384649389274196659297432212847319503330409792704612575414010711158873031786577877685578976140462539734553598745329712188216200905451774357282278403189943</span><br><span class="line">e = 65537</span><br><span class="line"></span><br><span class="line">phigh = (p0&gt;&gt;876)&lt;&lt;876</span><br><span class="line">plow = p0 % 2**444</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line"></span><br><span class="line">f = phigh + x*2**444 + plow</span><br><span class="line">f = f.monic()</span><br><span class="line">root = f.small_roots(X=2^432,beta=0.4)</span><br><span class="line">if root:</span><br><span class="line">    p = int(phigh + root[0]*2**444+plow)</span><br><span class="line">    print(&quot;p=&quot;,p)</span><br><span class="line">    q = n // p</span><br><span class="line">    d = gmpy2.invert(e,(p-1)*(q-1))</span><br><span class="line">    m = pow(c,d,n)</span><br><span class="line">    print(long_to_bytes(int(m)))</span><br><span class="line">else:</span><br><span class="line">    print(0)</span><br></pre></td></tr></table></figure>

<h2 id="高位攻击结合加法"><a href="#高位攻击结合加法" class="headerlink" title="高位攻击结合加法"></a>高位攻击结合加法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import random</span><br><span class="line">with open(&#x27;flag.txt&#x27;, &#x27;r&#x27;) as f:</span><br><span class="line">    flag = f.read().encode()</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_Prime(nbits):</span><br><span class="line">    cnt = random.randint(1, 50)</span><br><span class="line">    a = 678649776854118956235519899207445775941738710575390362283588104409625449204123832879</span><br><span class="line">    b = 782005138760169933127526591821947364276106050094468540051784488164681554419515591399</span><br><span class="line">    n = 959495185099860764003383321572335140174084694495020493292570101529012627928646710561</span><br><span class="line">    if nbits &gt; n.bit_length():</span><br><span class="line">        n = n &lt;&lt; (nbits - n.bit_length())</span><br><span class="line">    seed = m</span><br><span class="line"></span><br><span class="line">    while cnt != 0:</span><br><span class="line">        while not isPrime(seed % pow(2, nbits)):</span><br><span class="line">            seed = (a * seed + b) % n</span><br><span class="line">        cnt -= 1</span><br><span class="line"></span><br><span class="line">    return seed % pow(2, nbits)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = getPrime(1024)</span><br><span class="line">q = get_Prime(1024)</span><br><span class="line">r = get_Prime(256)</span><br><span class="line"></span><br><span class="line">leak1 = p * q</span><br><span class="line">leak2 = p + r</span><br><span class="line">print(&#x27;leak1 =&#x27;, leak1)</span><br><span class="line">print(&quot;leak2 =&quot;, leak2)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">leak1 = 1726975620674482360213233806170947389541096108697994658733084655845389659114785301178576637466986314063371421235058595065888582231342820140568936192868977804603369486433318090941058139588565791324218134357184323086216185739954390473991279905043631888896016473122377727070109213645260572190927015695514811455255973089661406134295506499664743661249339253830939615669712520262820531049038976606781161641581457130675569478698323490748401496084828842168678572095280512663203781775164764035921218962082539851900388875197643683923415508978600441502826319004922595635629466742721341100368916333951643193549875170423774879551</span><br><span class="line">leak2 = 112318855182255283836167471766806168213410186797367822915324918687801558224308427598350852972681526722686984900181855405532137931103674353513321543274324576313279396633244245181304978516377298223713109442863413211695328144733089915971055510790022499917701465412122183985372344800810303472010586670294890532292</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>先从p,r入手，因为p(1024bit)的比特远大于r(256bit)的比特，即p的前768位(并不一定是这么多)并不受到r的影响，可用coppersmith恢复p</strong></p>
<p><strong>得到p后，看定义的函数，就是一个不知道多少次的lcg加密过程</strong></p>
<p><code> n = n &lt;&lt; (nbits - n.bit_length())</code><strong>这里保证了模数n足够大，因为再加密过程中，如果n不够大的话，会导致明文的数据丢失一些</strong></p>
<p><strong>再用q解密，需要注意的是用q解密的时候，这个n已经是移位过后的n</strong></p>
<p><strong>exp:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">a = 678649776854118956235519899207445775941738710575390362283588104409625449204123832879</span><br><span class="line">b = 782005138760169933127526591821947364276106050094468540051784488164681554419515591399</span><br><span class="line">n = 959495185099860764003383321572335140174084694495020493292570101529012627928646710561</span><br><span class="line">leak1 = 1726975620674482360213233806170947389541096108697994658733084655845389659114785301178576637466986314063371421235058595065888582231342820140568936192868977804603369486433318090941058139588565791324218134357184323086216185739954390473991279905043631888896016473122377727070109213645260572190927015695514811455255973089661406134295506499664743661249339253830939615669712520262820531049038976606781161641581457130675569478698323490748401496084828842168678572095280512663203781775164764035921218962082539851900388875197643683923415508978600441502826319004922595635629466742721341100368916333951643193549875170423774879551</span><br><span class="line">leak2 = 112318855182255283836167471766806168213410186797367822915324918687801558224308427598350852972681526722686984900181855405532137931103674353513321543274324576313279396633244245181304978516377298223713109442863413211695328144733089915971055510790022499917701465412122183985372344800810303472010586670294890532292</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(leak1))</span><br><span class="line"></span><br><span class="line">high = (leak2&gt;&gt;256)&lt;&lt;256</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = high + x</span><br><span class="line">x = f.small_roots(X=2^256,beta=0.4)</span><br><span class="line">if x:</span><br><span class="line">    p = high + x[0]</span><br><span class="line">    print(p)</span><br><span class="line">    q = leak1 // int(p)</span><br><span class="line">    seed = q</span><br><span class="line">    n = n &lt;&lt; (1024 - 729)</span><br><span class="line">    while 1:</span><br><span class="line">        ani = gmpy2.invert(a,n)</span><br><span class="line">        seed = ani*(seed - b) % n</span><br><span class="line">        flag = long_to_bytes(seed)</span><br><span class="line">        if b&#x27;flag&#x27; in flag:</span><br><span class="line">            print(flag)</span><br><span class="line">            break</span><br></pre></td></tr></table></figure>



<h1 id="二元copper"><a href="#二元copper" class="headerlink" title="二元copper"></a>二元copper</h1><p>参考：<a href="https://www.cnblogs.com/11YEAGER11/p/17269139.html">二元coppersmith - 顶真珍珠 - 博客园 (cnblogs.com)</a></p>
<p>代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">        d = f.degree()</span><br><span class="line"></span><br><span class="line">    R = f.base_ring()</span><br><span class="line">    N = R.cardinality()</span><br><span class="line"></span><br><span class="line">    f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">    f = f.change_ring(ZZ)</span><br><span class="line"></span><br><span class="line">    G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        base = N ^ (m - i) * f ^ i</span><br><span class="line">        <span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">            g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">            G.append(g)</span><br><span class="line"></span><br><span class="line">    B, monomials = G.coefficient_matrix()</span><br><span class="line">    monomials = vector(monomials)</span><br><span class="line"></span><br><span class="line">    factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, factor)</span><br><span class="line"></span><br><span class="line">    B = B.dense_matrix().LLL()</span><br><span class="line"></span><br><span class="line">    B = B.change_ring(QQ)</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, <span class="number">1</span> / factor)</span><br><span class="line"></span><br><span class="line">    H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B * monomials):</span><br><span class="line">        H.append(h)</span><br><span class="line">        I = H.ideal()</span><br><span class="line">        <span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">            H.pop()</span><br><span class="line">        <span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">            roots = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">                root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">                roots.append(root)</span><br><span class="line">            <span class="keyword">return</span> roots</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<p>其中m为移位（shifts），d 为多项式中的最高幂。</p>
<h2 id="CISCN-2021华南-small"><a href="#CISCN-2021华南-small" class="headerlink" title="[CISCN 2021华南]small"></a>[CISCN 2021华南]small</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random, hashlib</span><br><span class="line">from Crypto.Util.number import getPrime</span><br><span class="line">from secret import x, y, flag</span><br><span class="line"></span><br><span class="line">BITS = 70</span><br><span class="line"></span><br><span class="line">assert(2**BITS &lt; x &lt; 2**(BITS+1))</span><br><span class="line">assert(2**BITS &lt; y &lt; 2**(BITS+1))</span><br><span class="line"></span><br><span class="line">m = str(x) + str(y)</span><br><span class="line">h = hashlib.sha256()</span><br><span class="line">h.update(m.encode())</span><br><span class="line">assert(flag == &quot;flag&#123;&quot; + h.hexdigest() + &quot;&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = getPrime(512)</span><br><span class="line">a = getPrime(510)</span><br><span class="line">b = getPrime(510)</span><br><span class="line">c = (1 + a * x * y ** 2 + b * x ** 2 * y) % p</span><br><span class="line">print(&quot;p = &quot; + str(p))</span><br><span class="line">print(&quot;a = &quot; + str(a))</span><br><span class="line">print(&quot;b = &quot; + str(b))</span><br><span class="line">print(&quot;c = &quot; + str(c))</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">p = </span><br><span class="line">a = </span><br><span class="line">b = </span><br><span class="line">c = </span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>题目给出$x,y$都介于$2^{70}$和$2^{71}$之间</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">p = <span class="number">8813834626918693034209829623386418111935369643440896703895290043343199520112218432639643684400534953548489779045914955504743423765099014797611981422650409</span></span><br><span class="line">a = <span class="number">2817275225516767613658440250260394873529274896419346861054126128919212362519165468003171950475070788320195398302803745633617864408366174315471102773073469</span></span><br><span class="line">b = <span class="number">1763620527779958060718182646420541623477856799630691559360944374374235694750950917040727594731391703184965719358552775151767735359739899063298735788999711</span></span><br><span class="line">c = <span class="number">2298790980294663527827702586525963981886518365072523836572440106026473419042192180086308154346777239817235315513418426401278994450805667292449334757693881</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">        d = f.degree()</span><br><span class="line"></span><br><span class="line">    R = f.base_ring()</span><br><span class="line">    N = R.cardinality()</span><br><span class="line"></span><br><span class="line">    f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">    f = f.change_ring(ZZ)</span><br><span class="line"></span><br><span class="line">    G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        base = N ^ (m - i) * f ^ i</span><br><span class="line">        <span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">            g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">            G.append(g)</span><br><span class="line"></span><br><span class="line">    B, monomials = G.coefficient_matrix()</span><br><span class="line">    monomials = vector(monomials)</span><br><span class="line"></span><br><span class="line">    factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, factor)</span><br><span class="line"></span><br><span class="line">    B = B.dense_matrix().LLL()</span><br><span class="line"></span><br><span class="line">    B = B.change_ring(QQ)</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, <span class="number">1</span> / factor)</span><br><span class="line"></span><br><span class="line">    H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B * monomials):</span><br><span class="line">        H.append(h)</span><br><span class="line">        I = H.ideal()</span><br><span class="line">        <span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">            H.pop()</span><br><span class="line">        <span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">            roots = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">                root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">                roots.append(root)</span><br><span class="line">            <span class="keyword">return</span> roots</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">R.&lt;x,y&gt;=PolynomialRing(Zmod(p))</span><br><span class="line"></span><br><span class="line">f = (<span class="number">1</span> + a * x * y ** <span class="number">2</span> + b * x ** <span class="number">2</span> * y) - c</span><br><span class="line"><span class="comment">#print(small_roots(f,bounds=(2^70,2^71)))</span></span><br><span class="line">x,y = small_roots(f,bounds=(<span class="number">2</span>^<span class="number">70</span>,<span class="number">2</span>^<span class="number">71</span>))[<span class="number">0</span>]</span><br><span class="line">m = <span class="built_in">str</span>(x) + <span class="built_in">str</span>(y)</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;NSSCTF&#123;&quot;</span> + hashlib.sha256(m.encode()).hexdigest() + <span class="string">&quot;&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>





<h1 id="P，Q产生方式由拼接而成"><a href="#P，Q产生方式由拼接而成" class="headerlink" title="P，Q产生方式由拼接而成"></a>P，Q产生方式由拼接而成</h1><p>这里只是做个记录</p>
<p>原文：<a href="https://ctftime.org/writeup/29693">CTFtime.org &#x2F; Crypto CTF 2021 &#x2F; Hamul &#x2F; Writeup</a></p>
<h2 id="Hamul"><a href="#Hamul" class="headerlink" title="Hamul"></a>Hamul</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">nbit = <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p, q = getPrime(nbit), getPrime(nbit)</span><br><span class="line">    P = <span class="built_in">int</span>(<span class="built_in">str</span>(p) + <span class="built_in">str</span>(q))</span><br><span class="line">    Q = <span class="built_in">int</span>(<span class="built_in">str</span>(q) + <span class="built_in">str</span>(p))</span><br><span class="line">    PP = <span class="built_in">int</span>(<span class="built_in">str</span>(P) + <span class="built_in">str</span>(Q))</span><br><span class="line">    QQ = <span class="built_in">int</span>(<span class="built_in">str</span>(Q) + <span class="built_in">str</span>(P))</span><br><span class="line">    <span class="keyword">if</span> isPrime(PP) <span class="keyword">and</span> isPrime(QQ):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">n = PP * QQ</span><br><span class="line">m = bytes_to_long(flag.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="keyword">if</span> m &lt; n:</span><br><span class="line">    c = <span class="built_in">pow</span>(m, <span class="number">65537</span>, n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;n =&#x27;</span>, n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;c =&#x27;</span>, c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># n = 98027132963374134222724984677805364225505454302688777506193468362969111927940238887522916586024601699661401871147674624868439577416387122924526713690754043</span></span><br><span class="line"><span class="comment"># c = 42066148309824022259115963832631631482979698275547113127526245628391950322648581438233116362337008919903556068981108710136599590349195987128718867420453399</span></span><br></pre></td></tr></table></figure>

<p>注意到，PP,QQ的产生方式：</p>
<p>令$x&#x3D;str(P),y&#x3D;str(Q)$，于是能把P,Q写成这样的形式：$P&#x3D;10^xp + q$，$Q&#x3D;10^yq+p$</p>
<p>再令$x’ &#x3D; str(PP),y’&#x3D;str(QQ)$，于是$PP &#x3D; 10^{x’}P+Q$，$Q&#x3D;10^{y’}Q+P$</p>
<p>$\because N &#x3D; PP×QQ$，这个N可以写成$10^{x+x’+y+y’}pq+…+pq$，每一项都含有pq。</p>
<p>因为$x+x’+y+y’$很大，所以存在$str(N)[:?]&#x3D;str(pq)[:?]$，$str(N)[?:]&#x3D;str(pq)[?:]$</p>
<p>测试发现$str(N)[:18]&#x3D;str(pq)[:18]$,$str(N)[-18:]&#x3D;str(pq)[-18:]$</p>
<p>也有出现前18位，后19位一样，前19位，后18位一样的情况</p>
<p>因为$len(str(pq))&#x3D;38或39$，可以爆破两位的方式求得pq</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_RSA</span>(<span class="params">c, e, p, q</span>):</span><br><span class="line">    phi = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line">    d = inverse(e, phi)</span><br><span class="line">    m = <span class="built_in">pow</span>(c, d, p*q)</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br><span class="line"></span><br><span class="line">n = </span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line">low = <span class="built_in">str</span>(n)[-<span class="number">18</span>:]</span><br><span class="line">high = <span class="built_in">str</span>(n)[:<span class="number">18</span>]</span><br><span class="line">pq_prob = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        pq_prob.append(<span class="built_in">int</span>(high + <span class="built_in">str</span>(i) + <span class="built_in">str</span>(j)+ low))</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> tqdm(pq_prob):</span><br><span class="line">    f = factor(x)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(f) == <span class="number">2</span> <span class="keyword">and</span> f[<span class="number">0</span>][<span class="number">0</span>].nbits() == <span class="number">64</span>):</span><br><span class="line">        p, q = f[<span class="number">0</span>][<span class="number">0</span>], f[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">P = <span class="built_in">int</span>(<span class="built_in">str</span>(p) + <span class="built_in">str</span>(q))</span><br><span class="line">Q = <span class="built_in">int</span>(<span class="built_in">str</span>(q) + <span class="built_in">str</span>(p))</span><br><span class="line">PP = <span class="built_in">int</span>(<span class="built_in">str</span>(P) + <span class="built_in">str</span>(Q))</span><br><span class="line">QQ = <span class="built_in">int</span>(<span class="built_in">str</span>(Q) + <span class="built_in">str</span>(P))</span><br><span class="line">N = PP * QQ</span><br><span class="line"><span class="built_in">print</span>(N == n)</span><br><span class="line">decrypt_RSA(c, <span class="number">65537</span>, PP, QQ)</span><br></pre></td></tr></table></figure>

<h2 id="HamburgerRSA"><a href="#HamburgerRSA" class="headerlink" title="HamburgerRSA"></a>HamburgerRSA</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">flag = <span class="built_in">open</span>(<span class="string">&#x27;flag.txt&#x27;</span>).read()</span><br><span class="line">nbit = <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p, q = getPrime(nbit), getPrime(nbit)</span><br><span class="line">    PP = <span class="built_in">int</span>(<span class="built_in">str</span>(p) + <span class="built_in">str</span>(p) + <span class="built_in">str</span>(q) + <span class="built_in">str</span>(q))</span><br><span class="line">    QQ = <span class="built_in">int</span>(<span class="built_in">str</span>(q) + <span class="built_in">str</span>(q) + <span class="built_in">str</span>(p) + <span class="built_in">str</span>(p))</span><br><span class="line">    <span class="keyword">if</span> isPrime(PP) <span class="keyword">and</span> isPrime(QQ):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">n = PP * QQ</span><br><span class="line">m = bytes_to_long(flag.encode())</span><br><span class="line">c = <span class="built_in">pow</span>(m, <span class="number">65537</span>, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;n =&#x27;</span>, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c =&#x27;</span>, c)</span><br></pre></td></tr></table></figure>

<p>类似上面那道题</p>
<p>不同的是爆破位数变成了1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_RSA</span>(<span class="params">c, e, p, q</span>):</span><br><span class="line">    phi = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line">    d = inverse(e, phi)</span><br><span class="line">    m = <span class="built_in">pow</span>(c, d, p*q)</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br><span class="line"></span><br><span class="line">n = <span class="number">177269125756508652546242326065138402971542751112423326033880862868822164234452280738170245589798474033047460920552550018968571267978283756742722231922451193</span></span><br><span class="line">c = <span class="number">47718022601324543399078395957095083753201631332808949406927091589044837556469300807728484035581447960954603540348152501053100067139486887367207461593404096</span></span><br><span class="line"></span><br><span class="line">low = <span class="built_in">str</span>(n)[-<span class="number">18</span>:]</span><br><span class="line">high = <span class="built_in">str</span>(n)[:<span class="number">18</span>]</span><br><span class="line">pq_prob = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">boom1</span>(<span class="params">low,high</span>):    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        pq_prob.append(<span class="built_in">int</span>(high + <span class="built_in">str</span>(i)+ low))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> tqdm(pq_prob):</span><br><span class="line">        f = factor(x)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(f) == <span class="number">2</span> <span class="keyword">and</span> f[<span class="number">0</span>][<span class="number">0</span>].nbits() == <span class="number">64</span>):</span><br><span class="line">            p, q = f[<span class="number">0</span>][<span class="number">0</span>], f[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            P = <span class="built_in">int</span>(<span class="built_in">str</span>(p) + <span class="built_in">str</span>(p))</span><br><span class="line">            Q = <span class="built_in">int</span>(<span class="built_in">str</span>(q) + <span class="built_in">str</span>(q))</span><br><span class="line">            PP = <span class="built_in">int</span>(<span class="built_in">str</span>(P) + <span class="built_in">str</span>(Q))</span><br><span class="line">            QQ = <span class="built_in">int</span>(<span class="built_in">str</span>(Q) + <span class="built_in">str</span>(P))</span><br><span class="line">            N = PP * QQ</span><br><span class="line">            <span class="keyword">if</span> (N == n):</span><br><span class="line">                decrypt_RSA(c, <span class="number">65537</span>, PP, QQ)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">boom2</span>(<span class="params">low,high</span>):    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            pq_prob.append(<span class="built_in">int</span>(high + <span class="built_in">str</span>(i)+ <span class="built_in">str</span>(j)+low))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> tqdm(pq_prob):</span><br><span class="line">        f = factor(x)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(f) == <span class="number">2</span> <span class="keyword">and</span> f[<span class="number">0</span>][<span class="number">0</span>].nbits() == <span class="number">64</span>):</span><br><span class="line">            p, q = f[<span class="number">0</span>][<span class="number">0</span>], f[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            P = <span class="built_in">int</span>(<span class="built_in">str</span>(p) + <span class="built_in">str</span>(p))</span><br><span class="line">            Q = <span class="built_in">int</span>(<span class="built_in">str</span>(q) + <span class="built_in">str</span>(q))</span><br><span class="line">            PP = <span class="built_in">int</span>(<span class="built_in">str</span>(P) + <span class="built_in">str</span>(Q))</span><br><span class="line">            QQ = <span class="built_in">int</span>(<span class="built_in">str</span>(Q) + <span class="built_in">str</span>(P))</span><br><span class="line">            N = PP * QQ</span><br><span class="line">            <span class="keyword">if</span> (N == n):</span><br><span class="line">                decrypt_RSA(c, <span class="number">65537</span>, PP, QQ)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">boom3</span>(<span class="params">low,high</span>):    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">                pq_prob.append(<span class="built_in">int</span>(high + <span class="built_in">str</span>(i) + <span class="built_in">str</span>(j) + <span class="built_in">str</span>(k)+ low))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> tqdm(pq_prob):</span><br><span class="line">        f = factor(x)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(f) == <span class="number">2</span> <span class="keyword">and</span> f[<span class="number">0</span>][<span class="number">0</span>].nbits() == <span class="number">64</span>):</span><br><span class="line">            p, q = f[<span class="number">0</span>][<span class="number">0</span>], f[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            P = <span class="built_in">int</span>(<span class="built_in">str</span>(p) + <span class="built_in">str</span>(p))</span><br><span class="line">            Q = <span class="built_in">int</span>(<span class="built_in">str</span>(q) + <span class="built_in">str</span>(q))</span><br><span class="line">            PP = <span class="built_in">int</span>(<span class="built_in">str</span>(P) + <span class="built_in">str</span>(Q))</span><br><span class="line">            QQ = <span class="built_in">int</span>(<span class="built_in">str</span>(Q) + <span class="built_in">str</span>(P))</span><br><span class="line">            N = PP * QQ</span><br><span class="line">            <span class="keyword">if</span> (N == n):</span><br><span class="line">                decrypt_RSA(c, <span class="number">65537</span>, PP, QQ)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">boom1(low,high)</span><br><span class="line">boom2(low,high)</span><br><span class="line">boom3(low,high)</span><br></pre></td></tr></table></figure>

<p>根据题目改点东西</p>
<h2 id="黑盾杯2020-Change"><a href="#黑盾杯2020-Change" class="headerlink" title="黑盾杯2020 Change"></a>黑盾杯2020 Change</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> FLAG</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p = <span class="built_in">int</span>(gmpy2.next_prime(random.randint(<span class="number">10</span>**<span class="number">399</span>, <span class="number">10</span>**<span class="number">400</span>-<span class="number">1</span>)))</span><br><span class="line">    q = <span class="built_in">int</span>(<span class="built_in">str</span>(p)[<span class="number">200</span>:]+<span class="built_in">str</span>(p)[:<span class="number">200</span>])</span><br><span class="line">    <span class="keyword">if</span> gmpy2.is_prime(q):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">m = bytes_to_long(FLAG)</span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;enc&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="built_in">str</span>(c))</span><br><span class="line">    f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    f.write(<span class="built_in">str</span>(n))</span><br></pre></td></tr></table></figure>

<p>记$p$的高位为$ph$，低位为$pl$，易知$ph$,$pl$都是$10^{200}$左右的数</p>
<p>则$p &#x3D; ph×10^{200}+pl$，$q &#x3D; pl×10^{200}+ph$</p>
<p>于是$n &#x3D; (ph×pl)×10^{400}+ph^2×10^{200}+pl^2×10^{200}+ph×pl$</p>
<p>因为$n$大概是$10^{800}$大小的数</p>
<p>记$ph×pl$的高位为$pph$，低位为$ppl$，都是$10^{200}$左右的数</p>
<p>$pph &#x3D; \frac{n}{10^{600}}$，$ppl &#x3D; n % 10^{200}$</p>
<p>求出$pph$和$ppl$后，即可求得$ph×pl$</p>
<p>再联立$n &#x3D; (ph×pl)×10^{400}+ph^2×10^{200}+pl^2×10^{200}+ph×pl$</p>
<p>求解$pl和ph$</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> symbols,solve</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">c = </span><br><span class="line">n = </span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line"></span><br><span class="line">pph = n // <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">600</span>)</span><br><span class="line">ppl = n % <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">200</span>)</span><br><span class="line">phpl = pph*<span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">200</span>) + ppl</span><br><span class="line"></span><br><span class="line">n -= <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">400</span>)*phpl + phpl</span><br><span class="line"></span><br><span class="line">tmp = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">ph = symbols(<span class="string">&#x27;ph&#x27;</span>)</span><br><span class="line">pl = symbols(<span class="string">&#x27;pl&#x27;</span>)</span><br><span class="line">s = solve([ph*pl-phpl, tmp*ph*ph + tmp*pl*pl - n], [ph, pl])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    ph,pl = <span class="built_in">int</span>(i[<span class="number">0</span>]), <span class="built_in">int</span>(i[<span class="number">1</span>])</span><br><span class="line">    p = ph*tmp + pl</span><br><span class="line">    q = pl*tmp + ph</span><br><span class="line">    <span class="keyword">if</span> p &gt; <span class="number">0</span> <span class="keyword">and</span> q &gt; <span class="number">0</span> <span class="keyword">and</span> gmpy2.is_prime(p) <span class="keyword">and</span> gmpy2.is_prime(q):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">d = gmpy2.invert(e, (p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c, d, p*q)))</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>古典密码-代换密码</title>
    <url>/2023/07/10/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81-%E4%BB%A3%E6%8D%A2%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>对古典密码学中代换密码做个粗浅的了解</p>
<span id="more"></span>

<p><img src="/../../images/Ancient/17.png"></p>
<p><img src="/../../images/Ancient/18.png"></p>
<p><strong>代换密码分为单表代换和多表代换</strong></p>
<h2 id="一、单表代换"><a href="#一、单表代换" class="headerlink" title="一、单表代换"></a>一、单表代换</h2><p><strong>在单表替换加密中，所有的加密方式几乎都有一个共性，那就是明密文一一对应。所以说，一般有以下两种方式来进行破解</strong></p>
<h3 id="1-凯撒密码"><a href="#1-凯撒密码" class="headerlink" title="1.凯撒密码"></a>1.凯撒密码</h3><p>凯撒密码（Caesar）加密时会将明文中的 <strong>每个字母</strong> 都按照其在字母表中的顺序向后（或向前）移动固定数目（<strong>循环移动</strong>）作为密文</p>
<p><strong>eg：偏移量为3</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明文：ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line">密文：DEFGHIJKLMNOPQRSTUVWXYZABC</span><br></pre></td></tr></table></figure>

<p>根据偏移量的不同，还存在<strong>若干特定的恺撒密码名称</strong>：</p>
<ul>
<li>偏移量为 10： Avocat （A→K）</li>
<li>偏移量为 13： <a href="https://zh.wikipedia.org/wiki/ROT13">ROT13</a></li>
<li>偏移量为 -5： Cassis （K 6）</li>
<li>偏移量为 -6： Cassette （K 7）</li>
</ul>
<p><strong>加密脚本:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_caesar_cipher</span>(<span class="params">plaintext</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shift</span>(<span class="params">text, n</span>):</span><br><span class="line">        result = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> text:</span><br><span class="line">            <span class="keyword">if</span> char.isalpha():</span><br><span class="line">                shift = <span class="built_in">ord</span>(char) + n</span><br><span class="line">                <span class="keyword">if</span> char.islower():</span><br><span class="line">                    <span class="keyword">if</span> shift &gt; <span class="built_in">ord</span>(<span class="string">&quot;z&quot;</span>):</span><br><span class="line">                        shift -= <span class="number">26</span></span><br><span class="line">                    <span class="keyword">elif</span> shift &lt; <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>):</span><br><span class="line">                        shift += <span class="number">26</span></span><br><span class="line">                <span class="keyword">elif</span> char.isupper():</span><br><span class="line">                    <span class="keyword">if</span> shift &gt; <span class="built_in">ord</span>(<span class="string">&quot;Z&quot;</span>):</span><br><span class="line">                        shift -= <span class="number">26</span></span><br><span class="line">                    <span class="keyword">elif</span> shift &lt; <span class="built_in">ord</span>(<span class="string">&quot;A&quot;</span>):</span><br><span class="line">                        shift += <span class="number">26</span></span><br><span class="line">                result += <span class="built_in">chr</span>(shift)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result += char</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;尝试所有可能的位移：&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">26</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;位移 <span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;shift(plaintext, +i)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    plaintext = <span class="built_in">input</span>(<span class="string">&quot;请输入凯撒密码的明文：&quot;</span>)</span><br><span class="line">    encrypt_caesar_cipher(plaintext)</span><br></pre></td></tr></table></figure>

<p><strong>解密脚本:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_caesar_cipher</span>(<span class="params">ciphertext</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shift</span>(<span class="params">text, n</span>):</span><br><span class="line">        result = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> text:</span><br><span class="line">            <span class="keyword">if</span> char.isalpha():</span><br><span class="line">                shift = <span class="built_in">ord</span>(char) + n</span><br><span class="line">                <span class="keyword">if</span> char.islower():</span><br><span class="line">                    <span class="keyword">if</span> shift &gt; <span class="built_in">ord</span>(<span class="string">&quot;z&quot;</span>):</span><br><span class="line">                        shift -= <span class="number">26</span></span><br><span class="line">                    <span class="keyword">elif</span> shift &lt; <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>):</span><br><span class="line">                        shift += <span class="number">26</span></span><br><span class="line">                <span class="keyword">elif</span> char.isupper():</span><br><span class="line">                    <span class="keyword">if</span> shift &gt; <span class="built_in">ord</span>(<span class="string">&quot;Z&quot;</span>):</span><br><span class="line">                        shift -= <span class="number">26</span></span><br><span class="line">                    <span class="keyword">elif</span> shift &lt; <span class="built_in">ord</span>(<span class="string">&quot;A&quot;</span>):</span><br><span class="line">                        shift += <span class="number">26</span></span><br><span class="line">                result += <span class="built_in">chr</span>(shift)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result += char</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;尝试所有可能的位移：&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">26</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;位移 <span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;shift(ciphertext, -i)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    ciphertext = <span class="built_in">input</span>(<span class="string">&quot;请输入凯撒密码的密文：&quot;</span>)</span><br><span class="line">    decrypt_caesar_cipher(ciphertext)</span><br></pre></td></tr></table></figure>



<h3 id="2-Atbash-Cipher"><a href="#2-Atbash-Cipher" class="headerlink" title="2.Atbash Cipher"></a>2.Atbash Cipher</h3><p>埃特巴什码(Atbash Cipher)，它使用字母表中的最后一个字母代表第一个字母，倒数第二个字母代表第二个字母。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</span><br><span class="line">密文：Z Y X W V U T S R Q P O N M L K J I H G F E D C B A</span><br></pre></td></tr></table></figure>

<p>加密例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明文：the quick brown fox jumps over the lazy dog</span><br><span class="line">密文：gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt</span><br></pre></td></tr></table></figure>

<p>工具：<a href="http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/">实用密码学 (practicalcryptography.com)</a></p>
<h3 id="3-简单替换密码"><a href="#3-简单替换密码" class="headerlink" title="3.简单替换密码"></a>3.简单替换密码</h3><p><strong>加密时，每个明文都有自己对应的密文，而且不是简单的移位，是混乱的。这也使得其破解难度要高于凯撒密码</strong></p>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明文: abcdefghijklmnopqrstuvwxyz</span><br><span class="line">密钥: phqgiumeaylnofdxjkrcvstzwb</span><br><span class="line"></span><br><span class="line">a对应p,b对应h</span><br></pre></td></tr></table></figure>

<p>一般用词频分析破解：<a href="http://quipqiup.com/">quipqiup - cryptoquip and cryptogram solver</a></p>
<h3 id="4-仿射密码"><a href="#4-仿射密码" class="headerlink" title="4.仿射密码"></a>4.仿射密码</h3><p>$$<br>加密函数：E(x) &#x3D; (ax+b) \mod m<br>$$</p>
<p>$$<br>其中,x是明文通过某种数字得到的编码<br>$$</p>
<p>$$<br>a,m满足gcd(a,m)&#x3D;1<br>$$</p>
<p>$$<br>m是编码系统中字母的个数<br>$$</p>
<p>$$<br>eg:如果以26字母表作为编码系统，则m&#x3D;26<br>$$</p>
<p>$$<br>解密函数：D(x)&#x3D;a^{-1}(x-b)\mod m<br>$$</p>
<p>$$<br>a^{-1}是模m的逆元<br>$$</p>
<h2 id="二、多表代换"><a href="#二、多表代换" class="headerlink" title="二、多表代换"></a>二、多表代换</h2><h3 id="1-Playfair"><a href="#1-Playfair" class="headerlink" title="1.Playfair"></a>1.Playfair</h3><p>原理：</p>
<ol>
<li>选取一串英文字母，除去重复出现的字母，将剩下的字母逐个逐个加入 5 × 5 的矩阵内，剩下的空间由未加入的英文字母依 a-z 的顺序加入。注意，将 q 去除，或将 i 和 j 视作同一字。</li>
<li>将要加密的明文分成两个一组。若组内的字母相同，将 X（或 Q）加到该组的第一个字母后，重新分组。若剩下一个字，也加入 X 。</li>
<li>在每组中，找出两个字母在矩阵中的地方<ul>
<li>若两个字母不同行也不同列，在矩阵中找出另外两个字母（第一个字母对应行优先），使这四个字母成为一个长方形的四个角。</li>
<li>若两个字母同行，取这两个字母右方的字母（若字母在最右方则取最左方的字母）</li>
<li>若两个字母同列，取这两个字母下方的字母（若字母在最下方则取最上方的字母）</li>
</ul>
</li>
</ol>
<p>新找到的两个字母就是原本的两个字母加密的结果。</p>
<p><strong>exp:</strong></p>
<p>以 playfair example 为密匙，得</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P L A Y F</span><br><span class="line">I R E X M</span><br><span class="line">B C D G H</span><br><span class="line">K N O Q S</span><br><span class="line">T U V W Z</span><br></pre></td></tr></table></figure>

<p><strong>要加密的讯息为 Hide the gold in the tree stump</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HI DE TH EG OL DI NT HE TR EX ES TU MP</span><br></pre></td></tr></table></figure>

<p>加密后密文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BM OD ZB XD NA BE KU DM UI XM MO UV IF</span><br></pre></td></tr></table></figure>

<p><strong>加解密网站：</strong><a href="http://www.metools.info/code/playfair_186.html">Playfair加密解密_普莱费尔加密解密-ME2在线工具 (metools.info)</a></p>
<h3 id="2-Polybius"><a href="#2-Polybius" class="headerlink" title="2.Polybius"></a>2.Polybius</h3><p>Polybius 密码又称为棋盘密码</p>
<p><strong>密码表长这样</strong></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">A</td>
<td align="center">B</td>
<td align="center">C</td>
<td align="center">D</td>
<td align="center">E</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">F</td>
<td align="center">G</td>
<td align="center">H</td>
<td align="center">I&#x2F;J</td>
<td align="center">K</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">L</td>
<td align="center">M</td>
<td align="center">N</td>
<td align="center">O</td>
<td align="center">P</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">Q</td>
<td align="center">R</td>
<td align="center">S</td>
<td align="center">T</td>
<td align="center">U</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">V</td>
<td align="center">W</td>
<td align="center">X</td>
<td align="center">Y</td>
<td align="center">Z</td>
</tr>
</tbody></table>
<p><strong>eg: HELLO加密后 23 15 31 31 34</strong></p>
<p>另外有种变表：</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>D</th>
<th>F</th>
<th>G</th>
<th>X</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>b</td>
<td>t</td>
<td>a</td>
<td>l</td>
<td>p</td>
</tr>
<tr>
<td>D</td>
<td>d</td>
<td>h</td>
<td>o</td>
<td>z</td>
<td>k</td>
</tr>
<tr>
<td>F</td>
<td>q</td>
<td>f</td>
<td>v</td>
<td>s</td>
<td>n</td>
</tr>
<tr>
<td>G</td>
<td>g</td>
<td>j</td>
<td>c</td>
<td>u</td>
<td>x</td>
</tr>
<tr>
<td>X</td>
<td>m</td>
<td>r</td>
<td>e</td>
<td>w</td>
<td>y</td>
</tr>
</tbody></table>
<p>应用这种密码表的加密方式叫<strong>ADFGX加密</strong></p>
<p><strong>eg:HELLO 加密后得到 DD XF AG AG DF</strong></p>
<h3 id="3-Vigenere"><a href="#3-Vigenere" class="headerlink" title="3.Vigenere"></a>3.Vigenere</h3><p>维吉尼亚密码（Vigenere）是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式。</p>
<p><img src="/../../images/Ancient/0.jpg"></p>
<p><strong>eg:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明文：come greatwall</span><br><span class="line">密钥：crypto</span><br><span class="line"></span><br><span class="line">先把密钥变成和明文同样长度</span><br><span class="line">明文：comegreatwall</span><br><span class="line">密钥：cryptocryptoc</span><br><span class="line"></span><br><span class="line">然后查表，cc作为横纵坐标得到e</span><br><span class="line">加密后的密文为：efkt zferrltzn</span><br></pre></td></tr></table></figure>

<p>解密网站：</p>
<p><strong>未知密钥：<a href="https://www.mygeocachingprofile.com/codebreaker.vigenerecipher.aspx">My Geocaching Profile.com - Vigenere Cipher Codebreaker</a></strong></p>
<p><strong>已知密钥：<a href="http://planetcalc.com/2468/">http://planetcalc.com/2468/</a></strong></p>
<h3 id="4-Nihilist"><a href="#4-Nihilist" class="headerlink" title="4.Nihilist"></a>4.Nihilist</h3><p><strong>Nihilist 密码又称关键字密码：明文 + 关键字 &#x3D; 密文。</strong></p>
<p>首先利用密钥构造棋盘矩阵（类似 Polybius 密码），新建一个 5 × 5 矩阵，将字符不重复地依次填入矩阵 ，剩下部分按字母顺序填入 ，字母 i 和 j 等价</p>
<p><strong>以关键字 helloworld 为例</strong></p>
<p><strong>关键字导出的密码表如下</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>h</td>
<td>e</td>
<td>l</td>
<td>o</td>
<td>w</td>
</tr>
<tr>
<td>2</td>
<td>r</td>
<td>d</td>
<td>a</td>
<td>b</td>
<td>c</td>
</tr>
<tr>
<td>3</td>
<td>f</td>
<td>g</td>
<td>i&#x2F;j</td>
<td>k</td>
<td>m</td>
</tr>
<tr>
<td>4</td>
<td>n</td>
<td>p</td>
<td>q</td>
<td>s</td>
<td>t</td>
</tr>
<tr>
<td>5</td>
<td>u</td>
<td>v</td>
<td>x</td>
<td>y</td>
<td>z</td>
</tr>
</tbody></table>
<p><strong>将明文中的每个字母对应横纵坐标就是其密文，例如a加密后是23</strong></p>
<h3 id="5-Hill"><a href="#5-Hill" class="headerlink" title="5.Hill"></a>5.Hill</h3><p><strong>希尔密码（Hill）使用每个字母在字母表中的顺序作为其对应的数字，即 A&#x3D;0，B&#x3D;1，C&#x3D;2 等等。然后将明文转化为 n 维向量，跟一个 n × n 的矩阵相乘，再将得出的结果模 26。注意用作加密的矩阵（即密匙）在mod26下必须是可逆的，否则就不可能解码。</strong></p>
<p><strong>只有矩阵的行列式和 26 互质，才是可逆的。</strong></p>
<p>eg:</p>
<p><img src="/../../images/Ancient/1.png"></p>
<p><strong>在线解密工具</strong><a href="http://www.practicalcryptography.com/ciphers/hill-cipher/">http://www.practicalcryptography.com/ciphers/hill-cipher/</a></p>
<h3 id="6-Autokey-Cipher"><a href="#6-Autokey-Cipher" class="headerlink" title="6.Autokey Cipher"></a>6.Autokey Cipher</h3><p><strong>自动密钥密码（Autokey Cipher）也是多表替换密码，与维吉尼亚密码密码类似，但使用不同的方法生成密钥。</strong></p>
<p><strong>自动密钥密码主要有两种，关键词自动密钥密码和原文自动密钥密码。</strong></p>
<p><strong>以关键词自动密钥为例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明文：THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</span><br><span class="line">关键词：CULTURE</span><br></pre></td></tr></table></figure>

<p><strong>以用关键词开始，填充为与明文等长的密钥</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明文：THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</span><br><span class="line">关键词：CULTURE THE QUICK BROWN FOX JUMPS OVER THE</span><br></pre></td></tr></table></figure>

<p><img src="/../../images/Ancient/0.jpg"></p>
<p><strong>和Vigenere同样的码表</strong></p>
<p>加密后的密文为:<code>VBP JOZGD IVEQV HYY AIICX CSNL FWW ZVDP WVK</code></p>
<p><strong>原文自动密钥密码，应该是密钥和明文一样进行加密</strong></p>
<p><strong>当未知关键词（也就是未知密钥的时候）可以用网站解密</strong><a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-autokey-cipher/">http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-autokey-cipher/</a></p>
]]></content>
      <categories>
        <category>古典密码学</category>
      </categories>
      <tags>
        <tag>古典密码</tag>
        <tag>代换密码</tag>
      </tags>
  </entry>
  <entry>
    <title>古典密码-其他密码</title>
    <url>/2023/07/11/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81-%E5%85%B6%E4%BB%96%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>记录一些见过的密码</p>
<p>时间不语，但却回答了很多问题</p>
<span id="more"></span>

<p>从网上找了些资料，以及一些大佬的博客，再结合自己所学，收集了一些加密方式。</p>
<h1 id="一、培根密码"><a href="#一、培根密码" class="headerlink" title="一、培根密码"></a>一、培根密码</h1><p><strong>把字母用A,B两个字母表示</strong></p>
<p>码表:</p>
<table>
<thead>
<tr>
<th>明文</th>
<th>密文</th>
<th>明文</th>
<th>密文</th>
<th>明文</th>
<th>密文</th>
<th>明文</th>
<th>密文</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>AAAAA</td>
<td>G</td>
<td>AABBA</td>
<td>N</td>
<td>ABBAA</td>
<td>T</td>
<td>BAABA</td>
</tr>
<tr>
<td>B</td>
<td>AAAAB</td>
<td>H</td>
<td>AABBB</td>
<td>O</td>
<td>ABBAB</td>
<td>U&#x2F;V</td>
<td>BAABB</td>
</tr>
<tr>
<td>C</td>
<td>AAABA</td>
<td>I&#x2F;J</td>
<td>ABAAA</td>
<td>P</td>
<td>ABBBA</td>
<td>W</td>
<td>BABAA</td>
</tr>
<tr>
<td>D</td>
<td>AAABB</td>
<td>K</td>
<td>ABAAB</td>
<td>Q</td>
<td>ABBBB</td>
<td>X</td>
<td>BABAB</td>
</tr>
<tr>
<td>E</td>
<td>AABAA</td>
<td>I</td>
<td>ABABA</td>
<td>R</td>
<td>BAAAA</td>
<td>Y</td>
<td>BABBA</td>
</tr>
<tr>
<td>F</td>
<td>AABAB</td>
<td>M</td>
<td>ABABB</td>
<td>S</td>
<td>BAAAB</td>
<td>Z</td>
<td>BABBB</td>
</tr>
</tbody></table>
<p><strong>培根密码不过是用A,B代替0，1表示其在字母表中的顺序（0——25）。</strong></p>
<p><strong>例如字母C的顺序是2，所以其密文是AAABA（00010）</strong></p>
<p>工具：<a href="http://rumkin.com/tools/cipher/baconian.php">http://rumkin.com/tools/cipher/baconian.php</a></p>
<p>找了harry师傅的脚本<a href="https://blog.csdn.net/qq_32284207/article/details/124771025">(59条消息) CTF·Crypto·古典密码大全_博多密码_0HB的博客-CSDN博客</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__autor__ = <span class="string">&#x27;0HB&#x27;</span></span><br><span class="line">letters1 = [</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;T&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>,</span><br><span class="line">]</span><br><span class="line">letters2 = [</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>,</span><br><span class="line">]</span><br><span class="line">cipher1 = [</span><br><span class="line">    <span class="string">&quot;aaaaa&quot;</span>, <span class="string">&quot;aaaab&quot;</span>, <span class="string">&quot;aaaba&quot;</span>, <span class="string">&quot;aaabb&quot;</span>, <span class="string">&quot;aabaa&quot;</span>, <span class="string">&quot;aabab&quot;</span>, <span class="string">&quot;aabba&quot;</span>,</span><br><span class="line">    <span class="string">&quot;aabbb&quot;</span>, <span class="string">&quot;abaaa&quot;</span>, <span class="string">&quot;abaab&quot;</span>, <span class="string">&quot;ababa&quot;</span>, <span class="string">&quot;ababb&quot;</span>, <span class="string">&quot;abbaa&quot;</span>, <span class="string">&quot;abbab&quot;</span>,</span><br><span class="line">    <span class="string">&quot;abbba&quot;</span>, <span class="string">&quot;abbbb&quot;</span>, <span class="string">&quot;baaaa&quot;</span>, <span class="string">&quot;baaab&quot;</span>, <span class="string">&quot;baaba&quot;</span>, <span class="string">&quot;baabb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babaa&quot;</span>, <span class="string">&quot;babab&quot;</span>, <span class="string">&quot;babba&quot;</span>, <span class="string">&quot;babbb&quot;</span>, <span class="string">&quot;bbaaa&quot;</span>, <span class="string">&quot;bbaab&quot;</span>,</span><br><span class="line">]</span><br><span class="line">cipher2 = [</span><br><span class="line">    <span class="string">&quot;AAAAA&quot;</span>, <span class="string">&quot;AAAAB&quot;</span>, <span class="string">&quot;AAABA&quot;</span>, <span class="string">&quot;AAABB&quot;</span>, <span class="string">&quot;AABAA&quot;</span>, <span class="string">&quot;AABAB&quot;</span>, <span class="string">&quot;AABBA&quot;</span>,</span><br><span class="line">    <span class="string">&quot;AABBB&quot;</span>, <span class="string">&quot;ABAAA&quot;</span>, <span class="string">&quot;ABAAA&quot;</span>, <span class="string">&quot;ABAAB&quot;</span>, <span class="string">&quot;ABABA&quot;</span>, <span class="string">&quot;ABABB&quot;</span>, <span class="string">&quot;ABBAA&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ABBAB&quot;</span>, <span class="string">&quot;ABBBA&quot;</span>, <span class="string">&quot;ABBBB&quot;</span>, <span class="string">&quot;BAAAA&quot;</span>, <span class="string">&quot;BAAAB&quot;</span>, <span class="string">&quot;BAABA&quot;</span>,</span><br><span class="line">    <span class="string">&quot;BAABB&quot;</span>, <span class="string">&quot;BAABB&quot;</span>, <span class="string">&quot;BABAA&quot;</span>, <span class="string">&quot;BABAB&quot;</span>, <span class="string">&quot;BABBA&quot;</span>, <span class="string">&quot;BABBB&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bacon1</span>(<span class="params">string</span>):  <span class="comment"># 对应小写密文</span></span><br><span class="line">    lists = []</span><br><span class="line">    <span class="comment"># 分割，五个一组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(string), <span class="number">5</span>):</span><br><span class="line">        lists.append(string[i:i + <span class="number">5</span>])</span><br><span class="line">    <span class="comment"># print(lists)</span></span><br><span class="line">    <span class="comment"># 循环匹配，得到下标，对应下标即可</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(lists)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">26</span>):</span><br><span class="line">            <span class="keyword">if</span> lists[i] == cipher1[j]:</span><br><span class="line">                <span class="comment"># print(j)</span></span><br><span class="line">                <span class="built_in">print</span>(letters1[j], end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bacon2</span>(<span class="params">string</span>):  <span class="comment"># 对应大写密文</span></span><br><span class="line">    lists = []</span><br><span class="line">    <span class="comment"># 分割，五个一组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(string), <span class="number">5</span>):</span><br><span class="line">        lists.append(string[i:i + <span class="number">5</span>])</span><br><span class="line">    <span class="comment"># print(lists)</span></span><br><span class="line">    <span class="comment"># 循环匹配，得到下标，对应下标即可</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(lists)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">26</span>):</span><br><span class="line">            <span class="keyword">if</span> lists[i] == cipher2[j]:</span><br><span class="line">                <span class="comment"># print(j)</span></span><br><span class="line">                <span class="built_in">print</span>(letters2[j], end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    c = <span class="built_in">input</span>(<span class="string">&#x27;请输入培根密文：&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> c.isupper():</span><br><span class="line">        bacon2(c)</span><br><span class="line">    <span class="keyword">elif</span> c.islower():</span><br><span class="line">        bacon1(c)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;输入错误，请检查！&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="二、栅栏密码"><a href="#二、栅栏密码" class="headerlink" title="二、栅栏密码"></a>二、栅栏密码</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>栅栏密码把要加密的明文分成 N 个一组，然后把每组的第 1 个字连起来，形成一段无规律的话。</strong></p>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明文：THERE IS A CIPHER</span><br><span class="line">去掉空格</span><br><span class="line">明文：THEREISACIPHER</span><br><span class="line">取N=2，即2个字母一组</span><br><span class="line">TH ER EI SA CI PH ER</span><br><span class="line">先取每组第一个字母：TEESCPE</span><br><span class="line">再去每组第二个字母：HRIAIHR</span><br><span class="line">所以密文：TEESCPEHRIAIHR</span><br><span class="line"></span><br><span class="line">如果明文是THERE IS CIPHER</span><br><span class="line">分组：TH ER EI SC IP HE R</span><br><span class="line">照样2个一组，然后先取每组第一个字母</span><br><span class="line">密文：TEESIHRHRICPE</span><br></pre></td></tr></table></figure>

<p><strong>自己写了个加密代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plaintext = <span class="string">&quot;THEREISACIPHER&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypto</span>(<span class="params">plaintext,n</span>):</span><br><span class="line">    array = []</span><br><span class="line">    cipher = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(plaintext),n):</span><br><span class="line">        array.append(plaintext[i:i+n])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array[<span class="number">0</span>])):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                cipher += j[i]</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;每组字数&quot;</span>+ <span class="built_in">str</span>(n) +<span class="string">&quot;加密结果&quot;</span> + cipher)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">len</span>(plaintext)):</span><br><span class="line">    encrypto(plaintext,i)</span><br></pre></td></tr></table></figure>

<h2 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h2><p><a href="http://www.metools.info/code/fence154.html">栅栏密码_栅栏密码在线加密解密【W型】-ME2在线工具 (metools.info)</a></p>
<p><a href="https://www.qqxiuzi.cn/bianma/zhalanmima.php">栅栏密码在线加密解密 - 千千秀字 (qqxiuzi.cn)</a></p>
<h1 id="三、曲路密码"><a href="#三、曲路密码" class="headerlink" title="三、曲路密码"></a>三、曲路密码</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p><strong>曲路密码（Curve Cipher）是一种换位密码，需要事先双方约定密钥（也就是曲路路径）</strong></p>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明文：The quick brown fox jumps over the lazy dog</span><br></pre></td></tr></table></figure>

<p><strong>填入5行7列的表格（事先约定填充的行列数）</strong></p>
<table>
<thead>
<tr>
<th align="center">T</th>
<th align="center">h</th>
<th align="center">e</th>
<th align="center">q</th>
<th align="center">u</th>
<th align="center">i</th>
<th align="center">c</th>
</tr>
</thead>
<tbody><tr>
<td align="center">k</td>
<td align="center">b</td>
<td align="center">r</td>
<td align="center">o</td>
<td align="center">w</td>
<td align="center">n</td>
<td align="center">f</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">x</td>
<td align="center">j</td>
<td align="center">u</td>
<td align="center">m</td>
<td align="center">p</td>
<td align="center">s</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">v</td>
<td align="center">e</td>
<td align="center">r</td>
<td align="center">t</td>
<td align="center">h</td>
<td align="center">e</td>
</tr>
<tr>
<td align="center">l</td>
<td align="center">a</td>
<td align="center">z</td>
<td align="center">y</td>
<td align="center">d</td>
<td align="center">o</td>
<td align="center">g</td>
</tr>
</tbody></table>
<p><strong>加密的回路线（事先约定）</strong></p>
<p><img src="/../../images/Ancient/3.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">密文：gesfc inpho dtmwu qoury zejre avxbh Tkool</span><br></pre></td></tr></table></figure>



<h1 id="四、列位移密码"><a href="#四、列位移密码" class="headerlink" title="四、列位移密码"></a>四、列位移密码</h1><p><strong>列移位密码（Columnar Transposition Cipher）是一种比较简单，易于实现的换位密码，通过一个简单的规则将明文打乱混合成密文。</strong></p>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明文：The quick brown fox jumps over the lazy dog</span><br></pre></td></tr></table></figure>

<p><strong>填入5行7列的表格（事先约定填充的行列数）</strong></p>
<table>
<thead>
<tr>
<th align="center">T</th>
<th align="center">h</th>
<th align="center">e</th>
<th align="center">q</th>
<th align="center">u</th>
<th align="center">i</th>
<th align="center">c</th>
</tr>
</thead>
<tbody><tr>
<td align="center">k</td>
<td align="center">b</td>
<td align="center">r</td>
<td align="center">o</td>
<td align="center">w</td>
<td align="center">n</td>
<td align="center">f</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">x</td>
<td align="center">j</td>
<td align="center">u</td>
<td align="center">m</td>
<td align="center">p</td>
<td align="center">s</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">v</td>
<td align="center">e</td>
<td align="center">r</td>
<td align="center">t</td>
<td align="center">h</td>
<td align="center">e</td>
</tr>
<tr>
<td align="center">l</td>
<td align="center">a</td>
<td align="center">z</td>
<td align="center">y</td>
<td align="center">d</td>
<td align="center">o</td>
<td align="center">g</td>
</tr>
</tbody></table>
<p><strong>选取密钥:</strong> <code>how are u</code></p>
<p>按 <code>how are u</code> 在字母表中的出现的先后顺序进行编号，<strong>我们就有 a 为 1，e 为 2，h 为 3，o 为 4，r 为 5，u 为 6，w 为 7，所以先写出 a 列，其次 e 列，以此类推</strong></p>
<p><img src="/../../images/Ancient/4.png"></p>
<p>最后得到的密文是<code>qoury inpho Tkool hbxva uwmtd cfseg erjez</code></p>
<p>网站：<a href="http://www.practicalcryptography.com/ciphers/classical-era/columnar-transposition/">Practical Cryptography</a></p>
<h1 id="五、01248密码"><a href="#五、01248密码" class="headerlink" title="五、01248密码"></a>五、01248密码</h1><p><strong>01248密码又称云影密码</strong></p>
<h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p><strong>使用 0，1，2，4，8 四个数字，其中把0当间隔，被0间隔开的数字进行相加，表示字母A—Z。eg：28代表10，即字母J</strong></p>
<p><strong>这里以2023HDCTF——爬过小山去看云</strong></p>
<p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">密文：ymyvzjtxswwktetpyvpfmvcdgywktetpyvpfuedfnzdjsiujvpwktetpyvnzdjpfkjssvacdgywktetpyvnzdjqtincduedfpfkjssne</span><br><span class="line">在山的那头，有3个人，4只鸟，19只羊，11朵云</span><br></pre></td></tr></table></figure>

<p><strong>先将密文进行Hill密码解密，然后得到的密文是：</strong><code>842084210884024084010124</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">842084210884024084010124</span><br><span class="line">把0去掉得到</span><br><span class="line">842 8421 884 24 84 1 124</span><br><span class="line">分别表示 14 15 20 6 12 1 7</span><br><span class="line">表示N O T F L A G</span><br></pre></td></tr></table></figure>

<h3 id="解密脚本"><a href="#解密脚本" class="headerlink" title="解密脚本"></a>解密脚本</h3><p><strong>自己写的解密脚本，可能有错</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cipher = <span class="string">&quot;&quot;</span>                         <span class="comment">#输入密文，密文由01248构成</span></span><br><span class="line">string = cipher.split(<span class="string">&#x27;0&#x27;</span>)			<span class="comment">#以0作为间隔，实现分组</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> string:					<span class="comment">#对每组数字进行求和</span></span><br><span class="line">    <span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">        <span class="built_in">sum</span> += <span class="built_in">int</span>(j)				<span class="comment">#int的作用是把字符转成数字</span></span><br><span class="line">    flag += <span class="built_in">chr</span>(<span class="built_in">sum</span>+<span class="number">64</span>)				<span class="comment">#数字转对应的字母</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<h3 id="加密脚本"><a href="#加密脚本" class="headerlink" title="加密脚本"></a>加密脚本</h3><p><strong>自己写的，可能有误</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message = <span class="string">&quot;&quot;</span>                    <span class="comment">#输入要加密的字符串</span></span><br><span class="line">cipher=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">ord</span>(i)-<span class="number">64</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">sum</span> &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span> &gt;= <span class="number">8</span>:</span><br><span class="line">            cipher+=<span class="string">&#x27;8&#x27;</span></span><br><span class="line">            <span class="built_in">sum</span> -= <span class="number">8</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">sum</span> &gt;= <span class="number">4</span>:</span><br><span class="line">            cipher+=<span class="string">&#x27;4&#x27;</span></span><br><span class="line">            <span class="built_in">sum</span> -= <span class="number">4</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">sum</span> &gt;= <span class="number">2</span>:</span><br><span class="line">            cipher+=<span class="string">&#x27;2&#x27;</span></span><br><span class="line">            <span class="built_in">sum</span> -= <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cipher+=<span class="string">&#x27;1&#x27;</span></span><br><span class="line">            <span class="built_in">sum</span> -= <span class="number">1</span></span><br><span class="line">    cipher += <span class="string">&#x27;0&#x27;</span></span><br><span class="line">           </span><br><span class="line"><span class="built_in">print</span>(cipher)</span><br></pre></td></tr></table></figure>



<h1 id="六、JSFuck"><a href="#六、JSFuck" class="headerlink" title="六、JSFuck"></a>六、JSFuck</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p><strong>JSFuck 可以只用 6 个字符 <code>[]()!+</code> 来编写 JavaScript 程序。比如我们想用 JSFuck 来实现 <code>alert(1)</code> 代码如下</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]][([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+([][[]]+[])[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[+!+[]]]]+([][[]]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]((![]+[])[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+[+!+[]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]])()</span><br></pre></td></tr></table></figure>

<p><strong>这个一点没理解</strong></p>
<h2 id="工具：-1"><a href="#工具：-1" class="headerlink" title="工具："></a>工具：</h2><p><a href="https://jsfuck.com/">JSFuck - Write any JavaScript with 6 Characters: <a href=""></a>!+</a></p>
<h1 id="七、BrainFuck"><a href="#七、BrainFuck" class="headerlink" title="七、BrainFuck"></a>七、BrainFuck</h1><p><strong>一种极小化的计算机语言，下面链接有详解。本人只是浅浅的了解了一下</strong></p>
<p><strong>BrainFuck用</strong><code>&gt; &lt; + - . ，[ ]</code><strong>八种符号替换C语言的各种语法和命令</strong></p>
<p>其含义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; :指针加一</span><br><span class="line">&lt; :指针减一</span><br><span class="line">+ :指针指向字节的值加一</span><br><span class="line">- :指针指向字节的值减一</span><br><span class="line">. :输出指针指向的内容(以ASCII码的形式)</span><br><span class="line">, :输入内容到指针指向的单元</span><br><span class="line">[ :如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处</span><br><span class="line">] :如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处</span><br></pre></td></tr></table></figure>

<p>详细可见下面文章：</p>
<p><a href="https://zhuanlan.zhihu.com/p/44091850">Brainfuck详解 - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/nameofcsdn/article/details/110231730">(59条消息) Brainfuck语言入门_bf语言_csuzhucong的博客-CSDN博客</a></p>
<h2 id="工具：-2"><a href="#工具：-2" class="headerlink" title="工具："></a>工具：</h2><p>[Brainfuck&#x2F;Ook! Obfuscation&#x2F;Encoding <a href="https://www.splitbrain.org/services/ook">splitbrain.org]</a></p>
<h1 id="八、Ook"><a href="#八、Ook" class="headerlink" title="八、Ook"></a>八、Ook</h1><p><strong>Ook和BrainFuck类似，也是用了替换，Ook只有三个不同的语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ook.   Ook?    Ook!</span><br><span class="line">用这三个语法即可表示多种含义：</span><br><span class="line">Ook. Ook?表示：指针加一</span><br><span class="line">Ook? Ook.表示：指针减一</span><br><span class="line">Ook. Ook.表示：指针指向字节的值加1</span><br><span class="line">Ook! Ook!表示：指针指向字节的值减1</span><br><span class="line">Ook. Ook!表示：输入内容到指针指向的单元(以ASCII码的形式)</span><br><span class="line">Ook! Ook.表示：输出指针指向的内容(以ASCII码的形式)</span><br><span class="line">Ook! Ook?表示：如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处</span><br><span class="line">Ook? Ook!表示：如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处</span><br></pre></td></tr></table></figure>

<p>可参考下面文章：<a href="https://www.cnblogs.com/WangAoBo/p/6373318.html">Brainfuck与Ook！编程语言解析与解密 - M4x - 博客园 (cnblogs.com)</a></p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>[Brainfuck&#x2F;Ook! Obfuscation&#x2F;Encoding <a href="https://www.splitbrain.org/services/ook">splitbrain.org]</a></p>
<h1 id="九、猪圈密码-含变种"><a href="#九、猪圈密码-含变种" class="headerlink" title="九、猪圈密码(含变种)"></a>九、猪圈密码(含变种)</h1><p><strong>根据码表</strong></p>
<p><img src="/../../images/Ancient/5.png"></p>
<p><strong>其来源于</strong></p>
<p><img src="/../../images/Ancient/6.png"></p>
<p>变种</p>
<p><img src="/../../images/Ancient/6.jpg"></p>
<h1 id="十、舞动的小人密码"><a href="#十、舞动的小人密码" class="headerlink" title="十、舞动的小人密码"></a>十、舞动的小人密码</h1><p><img src="/../../images/Ancient/1.jpg"></p>
<p><img src="/../../images/Ancient/8.png"></p>
<h1 id="十一、键盘密码"><a href="#十一、键盘密码" class="headerlink" title="十一、键盘密码"></a>十一、键盘密码</h1><p><strong>键盘密码就是用手机键盘或电脑键盘进行加密的密码</strong></p>
<h2 id="手机键盘密码"><a href="#手机键盘密码" class="headerlink" title="手机键盘密码"></a>手机键盘密码</h2><p><img src="/../../images/Ancient/2.jpg"></p>
<p><strong>关于手机键盘加密还有另一种方式，就是拼音具体参照手机键盘来打，例如：「数字」表示出来就是：748 94。</strong></p>
<h2 id="电脑键盘棋盘"><a href="#电脑键盘棋盘" class="headerlink" title="电脑键盘棋盘"></a>电脑键盘棋盘</h2><p>这个感觉挺怪的</p>
<p><img src="/../../images/Ancient/3.jpg"></p>
<h2 id="电脑键盘坐标"><a href="#电脑键盘坐标" class="headerlink" title="电脑键盘坐标"></a>电脑键盘坐标</h2><p><strong>用字母在电脑键盘上的坐标来表示，比如B表示为35</strong></p>
<h2 id="电脑键盘QWE"><a href="#电脑键盘QWE" class="headerlink" title="电脑键盘QWE"></a>电脑键盘QWE</h2><p><strong>用QWE代表ABC，依次推下去</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QWERTYUIOP表示ABCDEFGHIJ</span><br><span class="line">ASDFGHJKL表示KLMNOPQRS</span><br><span class="line">ZXCVBNM表示TUVWXYZ</span><br></pre></td></tr></table></figure>

<h2 id="QWE包围"><a href="#QWE包围" class="headerlink" title="QWE包围"></a>QWE包围</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解密方式：每组密文所围住的按键上的字符</span><br><span class="line">例: yujnbg, 观察键盘发现这六个字母围住了h，故明文为h。</span><br></pre></td></tr></table></figure>



<h2 id="代换"><a href="#代换" class="headerlink" title="代换"></a>代换</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">q,w,e,r,t,y,u,i,o,p,a,s,d,f,g,h,j,k,l,z,x,c,v,b,n,m替换成</span><br><span class="line">a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z</span><br></pre></td></tr></table></figure>



<h1 id="十二、古埃及象形文字"><a href="#十二、古埃及象形文字" class="headerlink" title="十二、古埃及象形文字"></a>十二、古埃及象形文字</h1><p><img src="/../../images/Ancient/7.png"></p>
<h1 id="十三、宝可梦图腾"><a href="#十三、宝可梦图腾" class="headerlink" title="十三、宝可梦图腾"></a>十三、宝可梦图腾</h1><p><img src="/../../images/Ancient/4.jpg"></p>
<h1 id="十四、精灵语"><a href="#十四、精灵语" class="headerlink" title="十四、精灵语"></a>十四、精灵语</h1><p><img src="/../../images/Ancient/5.jpg"></p>
<h1 id="十五、夏多密码"><a href="#十五、夏多密码" class="headerlink" title="十五、夏多密码"></a>十五、夏多密码</h1><p><strong>夏多密码又称曲路密码</strong></p>
<p><img src="/../../images/Ancient/9.png"></p>
<h1 id="十六、圣堂武士密码"><a href="#十六、圣堂武士密码" class="headerlink" title="十六、圣堂武士密码"></a>十六、圣堂武士密码</h1><p><img src="/../../images/Ancient/10.png"></p>
<h1 id="十七、盲文"><a href="#十七、盲文" class="headerlink" title="十七、盲文"></a>十七、盲文</h1><p><img src="/../../images/Ancient/11.png"></p>
<h1 id="十八、外星人密码"><a href="#十八、外星人密码" class="headerlink" title="十八、外星人密码"></a>十八、外星人密码</h1><p><img src="/../../images/Ancient/12.png"></p>
<h1 id="十九、音乐密码"><a href="#十九、音乐密码" class="headerlink" title="十九、音乐密码"></a>十九、音乐密码</h1><p><img src="/../../images/Ancient/13.png"></p>
<h1 id="二十、标准银河密码"><a href="#二十、标准银河密码" class="headerlink" title="二十、标准银河密码"></a>二十、标准银河密码</h1><p><img src="/../../images/Ancient/0.webp"></p>
<h1 id="二十一、天干地支表"><a href="#二十一、天干地支表" class="headerlink" title="二十一、天干地支表"></a>二十一、天干地支表</h1><p><img src="/../../images/Ancient/14.png"></p>
<h1 id="二十二、摩斯密码"><a href="#二十二、摩斯密码" class="headerlink" title="二十二、摩斯密码"></a>二十二、摩斯密码</h1><p><img src="/../../images/Ancient/15.png"></p>
<p>在线解密：<a href="https://www.matools.com/morse">在线摩斯电码 - 码工具 (matools.com)</a></p>
<h1 id="二十三、玛雅数字"><a href="#二十三、玛雅数字" class="headerlink" title="二十三、玛雅数字"></a>二十三、玛雅数字</h1><p>这个是自己在做题的时候积累的</p>
<p><img src="/../../images/Ancient/16.png"></p>
]]></content>
      <categories>
        <category>古典密码学</category>
      </categories>
      <tags>
        <tag>古典密码</tag>
        <tag>其他密码</tag>
      </tags>
  </entry>
  <entry>
    <title>2023DASCTF暑期挑战赛——Crypto</title>
    <url>/2023/07/24/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/2023DASCTF7%E6%9C%88/</url>
    <content><![CDATA[<p>复现2023DASCTF暑期挑战赛Crypto方向赛题（没做完）</p>
<span id="more"></span>



<h1 id="EzDHKE"><a href="#EzDHKE" class="headerlink" title="EzDHKE"></a>EzDHKE</h1><p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">from hashlib import sha256</span><br><span class="line">from random import randbytes, getrandbits</span><br><span class="line">from flag import flag</span><br><span class="line">def diffie_hellman(g, p, flag):</span><br><span class="line">    alice = getrandbits(1024)</span><br><span class="line">    bob = getrandbits(1024)</span><br><span class="line">    alice_c = pow(g, alice, p)</span><br><span class="line">    bob_c = pow(g, bob, p)</span><br><span class="line">    print(alice_c , bob_c)</span><br><span class="line">    key = sha256(long_to_bytes(pow(bob_c, alice, p))).digest()</span><br><span class="line">    iv = b&quot;dasctfdasctfdasc&quot;</span><br><span class="line">    aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    enc = aes.encrypt(flag)</span><br><span class="line">    print(enc)</span><br><span class="line"></span><br><span class="line">def getp():</span><br><span class="line">    p = int(input(&quot;P = &quot;))</span><br><span class="line">    assert isPrime(p)</span><br><span class="line">    assert p.bit_length() &gt;= 1024 and p.bit_length() &lt;= 2048</span><br><span class="line">    g = 2</span><br><span class="line">    diffie_hellman(g, p, flag)</span><br><span class="line"></span><br><span class="line">getp()</span><br></pre></td></tr></table></figure>

<p><strong>flag被ECB加密，已经给出了iv，我们的目的是求key</strong></p>
<p><strong>而key是关于DH加密的一个值</strong></p>
<p><code>getp()</code><strong>要求我们传一个1024bit——2048bit的素数p，之后会返回DH加密后的密文</strong></p>
<p><strong>既然模数p是由我们决定的，那我们传一个很光滑的素数p使得下式可以很快解出来</strong><br>$$<br>g^{Alice} &#x3D; Alice_c \mod p<br>$$<br>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> sympy.ntheory <span class="keyword">import</span> discrete_log</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造一个很光滑的p，即p可以分解成许多小素数之积</span></span><br><span class="line">p = <span class="number">1</span></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span>  isPrime(p+<span class="number">1</span>) ==<span class="literal">False</span> <span class="keyword">or</span> p.bit_length()&lt;<span class="number">1024</span> :</span><br><span class="line">    p *= i</span><br><span class="line">    i = gmpy2.next_prime(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(p+1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来就是解Alice的私钥a</span></span><br><span class="line">g = <span class="number">2</span></span><br><span class="line">p = p+<span class="number">1</span></span><br><span class="line">A = <span class="number">6497613672285956425201511287597625030386480108672286755480826112363203245642148151212994725377254666591461004877010242830011793120730597548153751505160757772485565892716879723968695533469583944347775896608532625158303921475557511270608379047178615651278485591942635948967376062201899549648208278357029126731213145007749394102828405131490762093895807059008547765574826356405482971857911257856639902792877504986919307035949726</span></span><br><span class="line">B = <span class="number">6892121088985539176550813556605471863390995273766116635861764749041016271848611822954736310722897673081939505093515966422841748844230466887689109451140120941395556326881049077033545866417480327268932777262530024548392468111847291103142479432094000792091679519431359554583970331286677886683961473976144527513383303092681236504569767664611631709120184944129897975070357015740122424467791475504388327118892471415926469637241282</span></span><br><span class="line"></span><br><span class="line">enc = <span class="string">b&#x27;`&lt;\xad\x93e\xeez\x8e\x1b\xe2B\xe9\xc7\x166\xc92$\x1a\xda\x86\x12m\x07\xb2\xa5d\x0b.\x13\xee\xa7.y(1\xd0\xf8\xc5\xffL\xf1\xb6_m840&#x27;</span></span><br><span class="line">iv = <span class="string">b&quot;dasctfdasctfdasc&quot;</span></span><br><span class="line">a = discrete_log(p,A,g)</span><br><span class="line"></span><br><span class="line">key = sha256(long_to_bytes(<span class="built_in">pow</span>(B, a, p))).digest()</span><br><span class="line"><span class="comment"># print(a)</span></span><br><span class="line"></span><br><span class="line">aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">flag = aes.decrypt(enc)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>



<h1 id="EzRSA"><a href="#EzRSA" class="headerlink" title="EzRSA"></a>EzRSA</h1><p>题目:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import secret, flag</span><br><span class="line">def encrypt(m):</span><br><span class="line">    return pow(m, e, n)</span><br><span class="line">assert flag == b&quot;dasctf&#123;&quot; + secret + b&quot;&#125;&quot;</span><br><span class="line">e = 11</span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">n = p * q</span><br><span class="line">P = getPrime(512)</span><br><span class="line">Q = getPrime(512)</span><br><span class="line">N = P * Q</span><br><span class="line">gift = P ^ (Q &gt;&gt; 16)</span><br><span class="line"></span><br><span class="line">print(N, gift, pow(n, e, N))</span><br><span class="line">print(encrypt(bytes_to_long(secret)),</span><br><span class="line">    encrypt(bytes_to_long(flag)))</span><br><span class="line"></span><br><span class="line">N = 75000029602085996700582008490482326525611947919932949726582734167668021800854674616074297109962078048435714672088452939300776268788888016125632084529419230038436738761550906906671010312930801751000022200360857089338231002088730471277277319253053479367509575754258003761447489654232217266317081318035524086377</span><br><span class="line">gift = 8006730615575401350470175601463518481685396114003290299131469001242636369747855817476589805833427855228149768949773065563676033514362512835553274555294034</span><br><span class="line">pow(n,e,N) = 14183763184495367653522884147951054630177015952745593358354098952173965560488104213517563098676028516541915855754066719475487503348914181674929072472238449853082118064823835322313680705889432313419976738694317594843046001448855575986413338142129464525633835911168202553914150009081557835620953018542067857943</span><br><span class="line">pow(secret,e,n) = 69307306970629523181683439240748426263979206546157895088924929426911355406769672385984829784804673821643976780928024209092360092670457978154309402591145689825571209515868435608753923870043647892816574684663993415796465074027369407799009929334083395577490711236614662941070610575313972839165233651342137645009</span><br><span class="line">pow(flag,e,n) = 46997465834324781573963709865566777091686340553483507705539161842460528999282057880362259416654012854237739527277448599755805614622531827257136959664035098209206110290879482726083191005164961200125296999449598766201435057091624225218351537278712880859703730566080874333989361396420522357001928540408351500991</span><br></pre></td></tr></table></figure>

<p><strong>首先注意到</strong><code>flag</code><strong>和</strong><code>secret</code><strong>在转成long型之后是有一定差值的，所以想到了相关消息攻击，但是相关消息攻击需要</strong><code>n</code></p>
<p><strong>已知给了</strong><code>N</code>,<code>P^(Q&gt;&gt;16)</code>,<code>pow(n,e,N)</code><strong>的值，想到把P求出来再解</strong><code>pow(n,e,N)</code></p>
<p><strong>这里通过爆破的方法求P</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *</span><br><span class="line">sys.setrecursionlimit(<span class="number">3000</span>)</span><br><span class="line">gift = <span class="number">8006730615575401350470175601463518481685396114003290299131469001242636369747855817476589805833427855228149768949773065563676033514362512835553274555294034</span></span><br><span class="line">N = <span class="number">75000029602085996700582008490482326525611947919932949726582734167668021800854674616074297109962078048435714672088452939300776268788888016125632084529419230038436738761550906906671010312930801751000022200360857089338231002088730471277277319253053479367509575754258003761447489654232217266317081318035524086377</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 低位往高位爆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findp</span>(<span class="params">p,q</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(p) == <span class="number">512</span>:</span><br><span class="line">        pp = <span class="built_in">int</span>(p,<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> N % pp == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;p = &quot;</span>,pp)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;q = &quot;</span>,N // pp)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l = <span class="built_in">len</span>(p)</span><br><span class="line">        pp = <span class="built_in">int</span>(p,<span class="number">2</span>)</span><br><span class="line">        qq = <span class="built_in">int</span>(q,<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (pp ^ (qq&gt;&gt;<span class="number">16</span>)) % (<span class="number">2</span> ** l) == gift %(<span class="number">2</span>**l) <span class="keyword">and</span> pp * qq %(<span class="number">2</span> ** l) == N % (<span class="number">2</span>**l):</span><br><span class="line">            findp(<span class="string">&#x27;1&#x27;</span> + p,<span class="string">&#x27;1&#x27;</span> + q)</span><br><span class="line">            findp(<span class="string">&#x27;1&#x27;</span> + p,<span class="string">&#x27;0&#x27;</span> + q)</span><br><span class="line">            findp(<span class="string">&#x27;0&#x27;</span> + p,<span class="string">&#x27;1&#x27;</span> + q)</span><br><span class="line">            findp(<span class="string">&#x27;0&#x27;</span> + p,<span class="string">&#x27;0&#x27;</span> + q)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> trange(<span class="number">2</span>**<span class="number">17</span>,<span class="number">2</span>**<span class="number">16</span>,-<span class="number">1</span>):</span><br><span class="line">    findp(<span class="string">&#x27;1&#x27;</span>,<span class="built_in">bin</span>(i)[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure>

<p><strong>因为不知道Q的低16位是什么，只能爆破一下Q。</strong></p>
<p><strong>得到</strong></p>
<p><code>P=8006847171912577069085166877758626954304824756138758266557706391662987806065132448544117840031499707938227955094109779732609035310252723066470330862622641</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">N = <span class="number">75000029602085996700582008490482326525611947919932949726582734167668021800854674616074297109962078048435714672088452939300776268788888016125632084529419230038436738761550906906671010312930801751000022200360857089338231002088730471277277319253053479367509575754258003761447489654232217266317081318035524086377</span></span><br><span class="line">gift = <span class="number">8006730615575401350470175601463518481685396114003290299131469001242636369747855817476589805833427855228149768949773065563676033514362512835553274555294034</span></span><br><span class="line">c = <span class="number">14183763184495367653522884147951054630177015952745593358354098952173965560488104213517563098676028516541915855754066719475487503348914181674929072472238449853082118064823835322313680705889432313419976738694317594843046001448855575986413338142129464525633835911168202553914150009081557835620953018542067857943</span></span><br><span class="line">secret_c = <span class="number">69307306970629523181683439240748426263979206546157895088924929426911355406769672385984829784804673821643976780928024209092360092670457978154309402591145689825571209515868435608753923870043647892816574684663993415796465074027369407799009929334083395577490711236614662941070610575313972839165233651342137645009</span></span><br><span class="line">flag_c = <span class="number">46997465834324781573963709865566777091686340553483507705539161842460528999282057880362259416654012854237739527277448599755805614622531827257136959664035098209206110290879482726083191005164961200125296999449598766201435057091624225218351537278712880859703730566080874333989361396420522357001928540408351500991</span></span><br><span class="line">e = <span class="number">11</span></span><br><span class="line"></span><br><span class="line">P = <span class="number">8006847171912577069085166877758626954304824756138758266557706391662987806065132448544117840031499707938227955094109779732609035310252723066470330862622641</span></span><br><span class="line">Q = N // P</span><br><span class="line">d = gmpy2.invert(e,(P-<span class="number">1</span>)*(Q-<span class="number">1</span>))</span><br><span class="line">n0 = <span class="built_in">pow</span>(c,d,N)</span><br><span class="line"><span class="built_in">print</span>(n0)</span><br><span class="line"><span class="built_in">print</span>(n0.bit_length())</span><br></pre></td></tr></table></figure>

<p><strong>解得</strong></p>
<p><code>n=8410363083727227985204019150296233995423906412694890252698371563789022268553444336554986979907257458547381598181369620318848637391220240378808211998052306324620364339595355706922325759625785590466818309839146408927226283350419069859849879835884942537531811470537915106995685907400782213608736735862576031042 </code></p>
<p><strong>检查一下n的位数发现只有1020bit，理论上n应该是1024bit，所以我们手动加上N</strong></p>
<p><strong>然后就是相关消息攻击解flag</strong></p>
<p>exp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">def GCD(a,b):</span><br><span class="line">    if b == 0:</span><br><span class="line">        return a.monic()</span><br><span class="line">    else:</span><br><span class="line">        return GCD(b,a%b)</span><br><span class="line">    </span><br><span class="line">n = 83410392685813224685786027640778560521035854332627839979281105731457044069408118952629284089869335506983096270269822559619624906180108256504440296527471536363057103101146262613593336072556587341466840510200003498265457285439149541137127199088938421905041387224795918868443175561632999479925818053898100117419</span><br><span class="line">secret_c = 69307306970629523181683439240748426263979206546157895088924929426911355406769672385984829784804673821643976780928024209092360092670457978154309402591145689825571209515868435608753923870043647892816574684663993415796465074027369407799009929334083395577490711236614662941070610575313972839165233651342137645009</span><br><span class="line">flag_c = 46997465834324781573963709865566777091686340553483507705539161842460528999282057880362259416654012854237739527277448599755805614622531827257136959664035098209206110290879482726083191005164961200125296999449598766201435057091624225218351537278712880859703730566080874333989361396420522357001928540408351500991</span><br><span class="line">e = 11</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line"></span><br><span class="line">for i in range(100):</span><br><span class="line">    f1 = (bytes_to_long(b&#x27;dasctf&#123;&#x27; + b&#x27;\x00&#x27;*i + b&#x27;&#125;&#x27;) + 256*x)^e - flag_c</span><br><span class="line">    f2 = x^e - secret_c</span><br><span class="line">    if (GCD(f1,f2).coefficients()[0] != 1):</span><br><span class="line">        print(b&#x27;dasctf&#123;&#x27; + long_to_bytes(int(n - GCD(f1,f2).coefficients()[0]))+b&#x27;&#125;&#x27;)</span><br></pre></td></tr></table></figure>

<p>解释部分代码：</p>
<ol>
<li><code>f1 = (bytes_to_long(b&quot;dasctf&#123;&quot; + b&quot;\x00&quot;*i + b&quot;&#125;&quot;) + 256*x)^11 - flag_c</code></li>
</ol>
<p><strong>因为</strong><code>dasctf&#123;</code><strong>在高位，所以要补上一些</strong><code>x</code><strong>代表</strong><code>secret</code><strong>的值，因为</strong><code>bytes_to_long()</code><strong>之后是256进制，所以乘上256</strong></p>
<p><strong>判断条件为：</strong></p>
<ol start="2">
<li><code> if (N-GCD(f1,f2).coefficients()[0]) != N-1:</code><strong>是因为如果填充的</strong><code>i</code><strong>个数不对</strong><code>GCD(f1,f2)</code><strong>返回的是1，则</strong></li>
</ol>
<p><code>coefficients()</code><strong>返回的也是1了</strong></p>
<p><strong>值得注意的是</strong></p>
<p><code>coefficients()</code><strong>这个函数返回的值是多项式中每项的系数，但是是从低次幂往高次幂</strong></p>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = x**3 + 2*x**2 + 6*x + 6</span><br><span class="line">f.coefficients() = [6,6,2,1]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>print(long_to_bytes(int(N-GCD(f1,f2).coefficients()[0])))</code></li>
</ol>
<p><strong>为什么返回值要在前面加上</strong><code>N-</code></p>
<p>翻阅大佬博客：</p>
<p><a href="https://jayxv.github.io/2020/08/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bcoppersmith/">密码学学习笔记 之 Coppersmith’s Method | Van1sh的小屋 (jayxv.github.io)</a></p>
<p><strong>自己弄了一些简单的数进行测试，我的理解是：</strong></p>
<p><strong>假设</strong></p>
<p><code>GCD(f1,f2).coefficients()[0]</code><strong>返回的是tmp，而我们要求的</strong> <code>x</code> <strong>和</strong> <code>tmp</code> <strong>满足</strong></p>
<p><code>x + tmp = n</code></p>
]]></content>
      <categories>
        <category>Wp</category>
      </categories>
      <tags>
        <tag>Wp</tag>
      </tags>
  </entry>
  <entry>
    <title>LitCTF</title>
    <url>/2023/07/04/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/LitCTF/</url>
    <content><![CDATA[<p><strong>为之则易，不为则难</strong></p>
<span id="more"></span>

<p><strong>记录2023LitCTF——crypto题解</strong></p>
<p>进入Hyperion复现的第一个赛事</p>
<h1 id="梦想是红色的"><a href="#梦想是红色的" class="headerlink" title="梦想是红色的"></a>梦想是红色的</h1><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自由友善公正公正敬业法治自由自由和谐平等自由自由公正法治诚信民主诚信自由自由诚信民主爱国友善平等诚信富强友善爱国自由诚信民主敬业爱国诚信民主友善爱国平等爱国爱国敬业敬业友善爱国公正敬业爱国敬业和谐文明诚信文明友善爱国自由诚信民主爱国爱国诚信和谐友善爱国自由友善平等爱国友善平等友善自由诚信自由平等爱国爱国敬业敬业友善爱国敬业敬业友善自由友善平等诚信自由法治诚信和谐</span><br></pre></td></tr></table></figure>

<p><strong>社会主义核心价值观解码</strong></p>
<p>解码得到：</p>
<p><strong><code>LitCTF&#123;为之则易,不为则难&#125;</code></strong></p>
<h1 id="Hex-Hex"><a href="#Hex-Hex" class="headerlink" title="Hex? Hex!"></a>Hex? Hex!</h1><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4c69744354467b746169313131636f6f6c6c616161217d</span><br></pre></td></tr></table></figure>

<p><strong>16进制转字符串</strong></p>
<p>解码得到：</p>
<p><strong><code>LitCTF&#123;tai111coollaaa!&#125;</code></strong></p>
<h1 id="原来你也玩原神"><a href="#原来你也玩原神" class="headerlink" title="原来你也玩原神"></a>原来你也玩原神</h1><p>密文：</p>
<p><img src="/../../images/LitCTF/1.png"></p>
<p><strong>对应提瓦特文字</strong></p>
<p>提瓦特文字表：</p>
<p><img src="/../../images/LitCTF/2.jpg"></p>
<p>把最后一行对应解码得到：</p>
<p><strong><code>LitCTF&#123;YUANLAINIYEWANYUANSHENWWW&#125;</code></strong></p>
<h1 id="你是我的关键词"><a href="#你是我的关键词" class="headerlink" title="你是我的关键词"></a>你是我的关键词</h1><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IFRURC&#123;X0S_YP3_JX_HBXV0PA&#125;</span><br></pre></td></tr></table></figure>

<p>根据题目信息，知道这是<strong>关键词密码，而且密钥是YOU</strong></p>
<p><img src="/../../images/LitCTF/2.png"></p>
<p>解码得到：</p>
<p><strong><code>LITCTF&#123;Y0U_AR3_MY_KEYW0RD&#125;</code></strong></p>
<h1 id="Is-this-only-base？"><a href="#Is-this-only-base？" class="headerlink" title="Is this only base？"></a>Is this only base？</h1><p><strong>栅栏 –&gt; base64 –&gt; 凯撒</strong></p>
<p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SWZxWl=F=DQef0hlEiSUIVh9ESCcMFS9NF2NXFzM</span><br><span class="line">今年是本世纪的第23年呢</span><br></pre></td></tr></table></figure>

<p><strong>先根据提示，23这个数字肯定有用</strong></p>
<p>首先栅栏密码解密，这里的栅栏密码是特殊的W型解密才能得到有效信息，栏目数为23</p>
<p>解密得到：</p>
<p><strong><code>SWZxWlFDe0liUV9ScF9FNFMzX2NSMCEhISEhfQ==</code></strong></p>
<p><strong>base64解密得到</strong>：</p>
<p><strong><code>IfqZQC&#123;IbQ_Rp_E4S3_cR0!!!!!&#125;</code></strong></p>
<p><strong>把LitCTF和IfqZQC对应一下</strong></p>
<p><img src="/../../images/LitCTF/4.png"></p>
<p><strong>凯撒移动3位得到</strong>：</p>
<p><strong><code>LitCTF&#123;LeT_Us_H4V3_fU0!!!!!&#125;</code></strong></p>
<h1 id="Virginia"><a href="#Virginia" class="headerlink" title="Virginia"></a>Virginia</h1><p><strong>维吉尼亚 –&gt; 凯撒</strong></p>
<p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ysexj lrk rzmkses os wilj hhks joa rtsy xzmktye yt xuim ehgy joa ofsz blnz yz pohv tnjx fxtx yuzc dxjlmy fyd nzr tnjx fuw cegq! Orkfx wnfe yuz haty eo jwpas;lz wnjce etf wgse tu lz;bk bsaz dzu cfyt zt me,hjnaaxp yuz sabj znrd znk qtfk fyd usp cnfyck yz du fwl zmp tnnygy dzu cfyt zt oo.Sfj yuz sabj pnuzrh nfapospsy yz mgpp yuz dwkje,ettfgn ycigqd tu rlkk dzu yycotl,pnuzrh ytcrub eo qjpp etf harln,kszumm sovj eo sfve etf hguay? Gqhaex auz dzuxxpll ny ozmpry’xsokx.Tf etf fkjw tnfe iz mfrzx joa,ne pxtmahqj hawes zmp ozmpr vjcsus, eou.Yse nfapojdt uk aeuuwe jty’t tjneyxlroqj hgap tnj meyy zf kapreysitl;ehkd uuyy xaqj ehk rzsz tq ebjcyzmtnm ysaz hzmkx llusr tnjtr cfj.Hguaitjds rnps ltc tntde cmz cxd,ehuxp wnt suxy, ehuxp wnt sabj degwnhki,lnj ysoyj hhu mlvk yciki,qox tyle ysee hln guarkhtazj ehk nxpuweathp ol upovqp,wnt sabj eoahsej yseow wibjd.Luap bkltny bttn f dmoqp,gxths cneh g ptsy fyd ksos cneh g ypax.Yse hwtgnypsz kftawp woqw arblyy gp bgxpd us l fuwrozypn vfdt, etf cgs’e gu ty wkqw it qtfkzytoq joa qpt mt zf etfr vfdt lftlawps gso hkfctghsey.Bset dzu cjce htcn,etf wkwp cxdtnm fyd kapretye gwzuti joa bls yrtlosr.Loap yuzc lokp su ysaz bset dzu jnp,yuz&#x27;ce zmp otj hhu nd ssnwitl lnj jgexdznk fcoaso yuz ts iwjitl.</span><br><span class="line">Uwegxp skso tnnd mkxdamj eo zmzsk upovqp wnt xegs dosjehosr tu dzu,zt ehuxp wnt sabj eoahsej dzux qtfk ny otj hae tc attehkw,eo zmzsk bso sfve etf ssnwe cmpn etf rkfwle spej ne,tu ysoyj ehgy xaqj joa xpe zmp bxnrhzjc soip ol ysitld wnjy yuz lrk wparqj duby,tu ysoyj hhu dzu cfyt zt wez yses pyoc ysaz dzu guarkhtazj ehknc fxnpnjxsiv.Fyd ok joa izn’z, izn’z bzrxd,yozmtnm gld cnwl nfapks eo etf,yuz hirq uuyy xiyx zuz ty tnj zpvtctastte yz bxnrhzjy surpotj’d dgd hizm ehox xeyxlgk.Rj pgxdwuwo iy szt g wpgaqlr Ifpsgw aayxhoxi,lnj yse ksn frfr=[86, 116, 128, 80, 98, 85, 139, 122, 134, 114, 125, 136, 117, 123, 129, 127, 128, 128, 142, 130, 140, 147, 127, 132, 131, 136, 151, 134, 152, 164] -Cgjdax</span><br></pre></td></tr></table></figure>

<p>维吉尼亚第一次解密得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There are moments in life when you miss someone so much that you just want to pick them from your dreams and hug them for real! Dream what you want to dream;go where you want to go;be what you want to be,because you have only one life and one chance to do all the things you want to do.May you have enough happiness to make you sweet,enough trials to make you strong,enough sorrow to keep you human,enough hope to make you happy? Always put yourself in others’shoes.If you feel that it hurts you,it probably hurts the other person, too.The happiest of people don’t necessarily have the best of everything;they just make the most of everything that comes along their way.Happiness lies for those who cry,those who hurt, those who have searched,and those who have tried,for only they can appreciate the importance of people,who have touched their lives.Love begins with a smile,grows with a kiss and ends with a tear.The brightest future will always be based on a forgotten past, you can’t go on well in lifeuntil you let go of your past failures and heartaches.When you were born,you were crying and everyone around you was smiling.Live your life so that when you die,you&#x27;re the one who is smiling and everyone around you is crying.</span><br><span class="line">Jwybmp mfho nicd gfmduhy ei ubzmf jpiqfp qii xybh dinyebjhr np szo,ui ebpmp qii suwy eivwsye szos ftzf cy ioy huz ic uoiebfl,ei ubzmf qsi nuvy zif mncwy xbph zif lfuwfz hpye ce,np nsity ebbn xuly jiv mpy ubp vscrbuyc mjxp ig nscoad qiyy spo llf lpumfj xpqy,np nsity hbp szo xuyn ui wyu nsyn eyix nsuu szo bjalfwtuuy ebfcc zscphemscq.Uyx jz jiv xzh’u, xzh’u qzlss,yiubthh vlx xcwf iuajfh ei zif,spo hcmf uotn xctm zou iy niy zjqicnvhtnz nz vscrbuyy mpgpioy’d xbs hcub ebjm xytmlaf.Gj jbmdqplo ct hzn b lpavfll Dupmbl autmhisx,lhe nsy fhn zmur=[86, 116, 128, 80, 98, 85, 139, 122, 134, 114, 125, 136, 117, 123, 129, 127, 128, 128, 142, 130, 140, 147, 127, 132, 131, 136, 151, 134, 152, 164] -Wbydus</span><br></pre></td></tr></table></figure>

<p>似乎没什么用，但是发现还有一段怪怪的信息，再解密一次：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Please send this message to those people who mean something to you,to those who have touched your life in one way or another,to those who make you smile when you really need it,to those that make you see the brighter side of things when you are really down,to those who you want to let them know that you appreciate their friendship.And if you don’t, don’t worry,nothing bad will happen to you,you will just miss out on the opportunity to brighten someone’s day with this message.My password is not a regular Caesar password,and the enc flag=[86, 116, 128, 80, 98, 85, 139, 122, 134, 114, 125, 136, 117, 123, 129, 127, 128, 128, 142, 130, 140, 147, 127, 132, 131, 136, 151, 134, 152, 164] -Caesar</span><br></pre></td></tr></table></figure>

<p>注意到这段话来自<strong>Caesar(凯撒大帝)</strong></p>
<p><strong>把LitCTF的ascii码和86，116，128，80，98，85对应</strong>：</p>
<p><img src="/../../images/LitCTF/5.png"></p>
<p>写个脚本跑一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="number">86</span>, <span class="number">116</span>, <span class="number">128</span>, <span class="number">80</span>, <span class="number">98</span>, <span class="number">85</span>, <span class="number">139</span>, <span class="number">122</span>, <span class="number">134</span>, <span class="number">114</span>, <span class="number">125</span>, <span class="number">136</span>, <span class="number">117</span>, <span class="number">123</span>, <span class="number">129</span>, <span class="number">127</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">142</span>, <span class="number">130</span>, <span class="number">140</span>, <span class="number">147</span>, <span class="number">127</span>, <span class="number">132</span>, <span class="number">131</span>, <span class="number">136</span>, <span class="number">151</span>, <span class="number">134</span>, <span class="number">152</span>, <span class="number">164</span>]</span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    flag += <span class="built_in">chr</span>(i-(<span class="number">10</span>+j))</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"><span class="comment">#LitCTF&#123;it_is_different_caesar&#125;</span></span><br></pre></td></tr></table></figure>



<h1 id="隐晦的消息记录"><a href="#隐晦的消息记录" class="headerlink" title="隐晦的消息记录"></a>隐晦的消息记录</h1><p><strong>OPT(一次一密)加密</strong><a href="https://dexterjie.github.io/2023/07/05/OPT-%E4%B8%80%E6%AC%A1%E4%B8%80%E5%AF%86-%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F/">OPT(一次一密加密法) - DexterJie’s Blog</a></p>
<p><img src="/../../images/LitCTF/3.png"></p>
<p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">出题人:6c73d5240a948c86981bc294814d</span><br><span class="line">某不知名收件人：收到消息attack at dawn</span><br><span class="line">出题人:xxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">某不知名收件人：收到消息Monday or Thur</span><br><span class="line">已知出题人和收件人手中的密钥相同，请解出出题人第二次发送的密文呢（16进制，字母小写，解得的结果记得要加上LitCTF&#123;&#125;哦。）</span><br></pre></td></tr></table></figure>

<p>根据题目提示，知道这是OPT加密，了解一下原理之后就知道该加密方式是通过异或实现的</p>
<p>只要把密文和密钥进行异或就能得到明文</p>
<p><strong>首先把 <code>attack at dawn</code>转成16进制，再和<code>6c73d5240a948c86981bc294814d</code>进行异或，即可得到密钥，因为两次密钥相同，所以把<code>Monday or Thur</code>和密钥异或，就是我们要的密文</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ciphertext1 = <span class="number">0x6c73d5240a948c86981bc294814d</span>    <span class="comment">#   attack at dawn转16进制后</span></span><br><span class="line">plaintext1 = <span class="number">0x61747461636b206174206461776e</span></span><br><span class="line"></span><br><span class="line">key = ciphertext1 ^ plaintext1</span><br><span class="line"></span><br><span class="line"><span class="comment">#   key = 0xd07a14569fface7ec3ba6f5f623</span></span><br><span class="line"></span><br><span class="line">plaintext2 = <span class="number">0x4d6f6e646179206f722054687572</span>      <span class="comment">#  Monday or Thur转16进制后</span></span><br><span class="line"></span><br><span class="line">ciphertext2 = key ^ plaintext2</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(ciphertext2))</span><br><span class="line"></span><br><span class="line"><span class="comment">#NSSCTF&#123;4068cf2108868c889e1bf29d8351&#125;</span></span><br></pre></td></tr></table></figure>



<h1 id="RSA签到"><a href="#RSA签到" class="headerlink" title="RSA签到"></a>RSA签到</h1><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">e = 65537</span><br><span class="line">n = p*q</span><br><span class="line">c = pow(m,e,n)</span><br><span class="line">print(f&#x27;p = &#123;p&#125;&#x27;)</span><br><span class="line">print(f&#x27;q = &#123;q&#125;&#x27;)</span><br><span class="line">print(f&#x27;c = &#123;c&#125;&#x27;)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">p = 12567387145159119014524309071236701639759988903138784984758783651292440613056150667165602473478042486784826835732833001151645545259394365039352263846276073</span><br><span class="line">q = 12716692565364681652614824033831497167911028027478195947187437474380470205859949692107216740030921664273595734808349540612759651241456765149114895216695451</span><br><span class="line">c = 108691165922055382844520116328228845767222921196922506468663428855093343772017986225285637996980678749662049989519029385165514816621011058462841314243727826941569954125384522233795629521155389745713798246071907492365062512521474965012924607857440577856404307124237116387085337087671914959900909379028727767057</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line"></span><br><span class="line">p = <span class="number">12567387145159119014524309071236701639759988903138784984758783651292440613056150667165602473478042486784826835732833001151645545259394365039352263846276073</span></span><br><span class="line">q =<span class="number">12716692565364681652614824033831497167911028027478195947187437474380470205859949692107216740030921664273595734808349540612759651241456765149114895216695451</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c =<span class="number">108691165922055382844520116328228845767222921196922506468663428855093343772017986225285637996980678749662049989519029385165514816621011058462841314243727826941569954125384522233795629521155389745713798246071907492365062512521474965012924607857440577856404307124237116387085337087671914959900909379028727767057</span></span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line">d = invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"><span class="comment">#LitCTF&#123;it_is_easy_to_solve_question_when_you_know_p_and_q&#125;</span></span><br></pre></td></tr></table></figure>



<h1 id="md5的破解"><a href="#md5的破解" class="headerlink" title="md5的破解"></a>md5的破解</h1><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from hashlib import md5</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">#flag全是由小写字母及数字组成</span><br><span class="line">m=md5(flag).hexdigest()</span><br><span class="line">print(flag[:13]+flag[15:18]+flag[19:34]+flag[35:38])</span><br><span class="line">print(m)</span><br><span class="line"># b&#x27;LitCTF&#123;md5can3derypt213thoughcrsh&#125;&#x27;</span><br><span class="line"># 496603d6953a15846cd7cc476f146771</span><br></pre></td></tr></table></figure>

<p><strong>注意切片，前面闭区间，后面开区间</strong></p>
<p><strong>这里输出flag中索引值0—12， 15—17， 19—33， 35—37</strong></p>
<p>第13，14，18，34位需要爆破，根据提示可以缩小爆破范围</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> string.ascii_lowercase + string.digits:</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> string.ascii_lowercase + string.digits:</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> string.ascii_lowercase + string.digits:</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> string.ascii_lowercase + string.digits:</span><br><span class="line">                flag = <span class="string">&quot;LitCTF&#123;md5can&quot;</span> + a + b + <span class="string">&quot;3de&quot;</span> + c + <span class="string">&quot;rypt213thoughcr&quot;</span> + d +<span class="string">&quot;sh&#125;&quot;</span></span><br><span class="line">                s = hashlib.md5(flag.encode()).hexdigest()</span><br><span class="line">                <span class="keyword">if</span> s == <span class="string">&quot;496603d6953a15846cd7cc476f146771&quot;</span>:</span><br><span class="line">                    <span class="built_in">print</span>(flag)</span><br><span class="line">                    </span><br><span class="line"><span class="comment">#LitCTF&#123;md5can123dexrypt213thoughcrpsh&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="yafu"><a href="#yafu" class="headerlink" title="yafu"></a>yafu</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">n  = 1</span><br><span class="line">for i in range(15):</span><br><span class="line">    n *=getPrime(32)</span><br><span class="line">e = 65537</span><br><span class="line">c = pow(m,e,n)</span><br><span class="line">print(f&#x27;n = &#123;n&#125;&#x27;)</span><br><span class="line">print(f&#x27;c = &#123;c&#125;&#x27;)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">n = 15241208217768849887180010139590210767831431018204645415681695749294131435566140166245881287131522331092026252879324931622292179726764214435307</span><br><span class="line">c = 12608550100856399369399391849907846147170257754920996952259023159548789970041433744454761458030776176806265496305629236559551086998780836655717</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>注意n的产生方式，是由15个素数相乘得到</p>
<p>分解n,得到15个因子，然后求</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line">c = <span class="number">12608550100856399369399391849907846147170257754920996952259023159548789970041433744454761458030776176806265496305629236559551086998780836655717</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n =<span class="number">15241208217768849887180010139590210767831431018204645415681695749294131435566140166245881287131522331092026252879324931622292179726764214435307</span></span><br><span class="line"></span><br><span class="line">p =[<span class="number">2201440207</span>,<span class="number">3354884521</span>,<span class="number">4171911923</span>,<span class="number">2719600579</span>,<span class="number">2906576131</span>,<span class="number">4021078331</span>,<span class="number">2151018733</span>,<span class="number">2758708999</span>,<span class="number">2315495107</span>,<span class="number">4044505687</span>,<span class="number">2923522073</span>,<span class="number">3355651511</span>,<span class="number">2585574697</span>,<span class="number">2767137487</span>,<span class="number">3989697563</span>]</span><br><span class="line">phi = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> p:</span><br><span class="line">    phi *= i-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">d = invert(e,phi)</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"><span class="comment">#LitCTF&#123;Mu1tiple_3m4ll_prim5_fac7ors_@re_uns4f5&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="factot-b"><a href="#factot-b" class="headerlink" title="factot b"></a>factot b</h1><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e = 65537</span><br><span class="line">n = 87924348264132406875276140514499937145050893665602592992418171647042491658461</span><br><span class="line">c = 87677652386897749300638591365341016390128692783949277305987828177045932576708</span><br></pre></td></tr></table></figure>

<p>网站分解</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line"></span><br><span class="line">p =<span class="number">275127860351348928173285174381581152299</span></span><br><span class="line">q =<span class="number">319576316814478949870590164193048041239</span></span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c =<span class="number">87677652386897749300638591365341016390128692783949277305987828177045932576708</span></span><br><span class="line"></span><br><span class="line">d = invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"><span class="comment">#LitCTF&#123;factordb!!!&#125;</span></span><br></pre></td></tr></table></figure>



<h1 id="the-same-common-divisor"><a href="#the-same-common-divisor" class="headerlink" title="the same common divisor"></a>the same common divisor</h1><p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">m=bytes_to_long(b&#x27;xxxxxx&#x27;)</span><br><span class="line">e=65537</span><br><span class="line">p=getPrime(1024)</span><br><span class="line">q1=getPrime(1024)</span><br><span class="line">q2=getPrime(1024)</span><br><span class="line">n1=p*q1</span><br><span class="line">n2=p*q2</span><br><span class="line">c1=pow(m,e,n1)</span><br><span class="line">c2=pow(m,e,n2)</span><br><span class="line">n3=n1^n2</span><br><span class="line">print(&#x27;n1=&#x27;,n1)</span><br><span class="line">print(&#x27;n3=&#x27;,n3)</span><br><span class="line">print(&#x27;c1=&#x27;,c1)</span><br><span class="line">print(&#x27;c2=&#x27;,c2)</span><br><span class="line">#n1= 9852079772293301283705208653824307027320071498525390578148444258198605733768947108049676831872672654449631852459503049139275329796717506126689710613873813880735666507857022786447784753088176997374711523987152412069255685005264853118880922539048290400078105858759506186417678959028622484823376958194324034590514104266608644398160457382895380141070373685334979803658172378382884352616985632157233900719194944197689860219335238499593658894630966428723660931647038577670614850305719449893199713589368780231046895222526070730152875112477675102652862254926169713030701937231206405968412044029177246460558028793385980934233</span><br><span class="line">#n3= 4940268030889181135441311597961813780480775970170156650560367030148383674257975796516865571557828263935532335958510269356443566533284856608454193676600884849913964971291145182724888816164723930966472329604608512023988191536173112847915884014445539739070437180314205284883149421228744714989392788108329929896637182055266508625177260492776962915873036873839946591259443753924970795669864031580632650140641456386202636466624658715315856453572441182758855085077441336516178544978457053552156714181607801760605521338788424464551796638531143900048375037218585999440622490119344971822707261432953755569507740550277088437182</span><br><span class="line">#c1= 7066425618980522033304943700150361912772559890076173881522840300333719222157667104461410726444725540513601550570478331917063911791020088865705346188662290524599499769112250751103647749860198318955619903728724860941709527724500004142950768744200491448875522031555564384426372047270359602780292587644737898593450148108629904854675417943165292922990980758572264063039172969633878015560735737699147707712154627358077477591293746136250207139049702201052305840453700782016480965369600667516646007546442708862429431724013679189842300429421340122052682391471347471758814138218632022564279296594279507382548264409296929401260</span><br><span class="line">#c2= 854668035897095127498890630660344701894030345838998465420605524714323454298819946231147930930739944351187708040037822108105697983018529921300277486094149269105712677374751164879455815185393395371001495146490416978221501351569800028842842393448555836910486037183218754013655794027528039329299851644787006463456162952383099752894635657833907958930587328480492546831654755627949756658554724024525108575961076341962292900510328611128404001877137799465932130220386963518903892403159969133882215092783063943679288192557384595152566356483424061922742307738886179947575613661171671781544283180451958232826666741028590085269</span><br></pre></td></tr></table></figure>

<p><strong>共享素数</strong></p>
<p>n1和n2共用了p</p>
<p>先异或n1,n3得到n2,再得到p</p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> gcd,invert</span><br><span class="line"></span><br><span class="line">n1 = <span class="number">9852079772293301283705208653824307027320071498525390578148444258198605733768947108049676831872672654449631852459503049139275329796717506126689710613873813880735666507857022786447784753088176997374711523987152412069255685005264853118880922539048290400078105858759506186417678959028622484823376958194324034590514104266608644398160457382895380141070373685334979803658172378382884352616985632157233900719194944197689860219335238499593658894630966428723660931647038577670614850305719449893199713589368780231046895222526070730152875112477675102652862254926169713030701937231206405968412044029177246460558028793385980934233</span></span><br><span class="line">n3 = <span class="number">4940268030889181135441311597961813780480775970170156650560367030148383674257975796516865571557828263935532335958510269356443566533284856608454193676600884849913964971291145182724888816164723930966472329604608512023988191536173112847915884014445539739070437180314205284883149421228744714989392788108329929896637182055266508625177260492776962915873036873839946591259443753924970795669864031580632650140641456386202636466624658715315856453572441182758855085077441336516178544978457053552156714181607801760605521338788424464551796638531143900048375037218585999440622490119344971822707261432953755569507740550277088437182</span></span><br><span class="line">c1 = <span class="number">7066425618980522033304943700150361912772559890076173881522840300333719222157667104461410726444725540513601550570478331917063911791020088865705346188662290524599499769112250751103647749860198318955619903728724860941709527724500004142950768744200491448875522031555564384426372047270359602780292587644737898593450148108629904854675417943165292922990980758572264063039172969633878015560735737699147707712154627358077477591293746136250207139049702201052305840453700782016480965369600667516646007546442708862429431724013679189842300429421340122052682391471347471758814138218632022564279296594279507382548264409296929401260</span></span><br><span class="line">c2 = <span class="number">854668035897095127498890630660344701894030345838998465420605524714323454298819946231147930930739944351187708040037822108105697983018529921300277486094149269105712677374751164879455815185393395371001495146490416978221501351569800028842842393448555836910486037183218754013655794027528039329299851644787006463456162952383099752894635657833907958930587328480492546831654755627949756658554724024525108575961076341962292900510328611128404001877137799465932130220386963518903892403159969133882215092783063943679288192557384595152566356483424061922742307738886179947575613661171671781544283180451958232826666741028590085269</span></span><br><span class="line"></span><br><span class="line">n2 = n1 ^ n3</span><br><span class="line">p = gcd(n1,n2)</span><br><span class="line">q = n1 // p</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">d = invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c1,d,n1)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"><span class="comment">#LitCTF&#123;TH3_Tw0_nUmb3rs_H@v3_The_sAme_D1v1s0r!!&#125;</span></span><br></pre></td></tr></table></figure>



<h1 id="e的学问"><a href="#e的学问" class="headerlink" title="e的学问"></a>e的学问</h1><p><strong>考点是e和phi不互素</strong>，相关知识在学习过程中有</p>
<p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">m=bytes_to_long(b&#x27;xxxxxx&#x27;)</span><br><span class="line">p=getPrime(256)</span><br><span class="line">q=getPrime(256)</span><br><span class="line">e=74</span><br><span class="line">n=p*q</span><br><span class="line">c=pow(m,e,n)</span><br><span class="line">print(&quot;p=&quot;,p)</span><br><span class="line">print(&quot;q=&quot;,q)</span><br><span class="line">print(&quot;c=&quot;,c)</span><br><span class="line">#p= 86053582917386343422567174764040471033234388106968488834872953625339458483149</span><br><span class="line">#q= 72031998384560188060716696553519973198388628004850270102102972862328770104493</span><br><span class="line">#c= 3939634105073614197573473825268995321781553470182462454724181094897309933627076266632153551522332244941496491385911139566998817961371516587764621395810123</span><br></pre></td></tr></table></figure>

<p>因为e和phi不互素,先对e和phi求公因数<strong>t</strong>，再把e除去这个公因数</p>
<p><strong>这样就使得新的e和phi互素</strong></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">p = <span class="number">86053582917386343422567174764040471033234388106968488834872953625339458483149</span></span><br><span class="line">q = <span class="number">72031998384560188060716696553519973198388628004850270102102972862328770104493</span></span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">74</span></span><br><span class="line">c = <span class="number">3939634105073614197573473825268995321781553470182462454724181094897309933627076266632153551522332244941496491385911139566998817961371516587764621395810123</span></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> gmpy2.gcd(phi,e) != <span class="number">1</span>:                   </span><br><span class="line">    t = gmpy2.gcd(phi,e)                <span class="comment">#因为Phi和e不互素，所以要用e除掉他们的公因数，保证新的e和phi互素</span></span><br><span class="line">    e1 = e // t</span><br><span class="line">    d = gmpy2.invert(e1,phi)</span><br><span class="line">    m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">    msg = gmpy2.iroot(m,t)				</span><br><span class="line">    <span class="keyword">if</span> msg[<span class="number">1</span>]:</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(msg[<span class="number">0</span>]))	</span><br><span class="line"></span><br><span class="line"> <span class="comment">#LitCTF&#123;e_1s_n0t_@_Prime&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="Euler"><a href="#Euler" class="headerlink" title="Euler"></a>Euler</h1><p><strong>对欧拉函数的理解</strong></p>
<p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">n = p*q</span><br><span class="line">c = pow(m,n-p-q+3,n)</span><br><span class="line">print(f&#x27;n = &#123;n&#125;&#x27;)</span><br><span class="line">print(f&#x27;c = &#123;c&#125;&#x27;)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">n = 115140122725890943990475192890188343698762004010330526468754961357872096040956340092062274481843042907652320664917728267982409212988849109825729150839069369465433531269728824368749655421846730162477193420534803525810831025762500375845466064264837531992986534097821734242082950392892529951104643690838773406549</span><br><span class="line">c = 406480424882876909664869928877322864482740577681292497936198951316587691545267772748204383995815523935005725558478033908575228532559165174398668885819826720515607326399097899572022020453298441</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/../../images/LitCTF/7.png"></p>
<p>通过爆破K,即可得到m。</p>
<p><strong>自己闲着没事试了一下，好像m的次方大于5就不能通过这个方法求</strong></p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot</span><br><span class="line">n = <span class="number">115140122725890943990475192890188343698762004010330526468754961357872096040956340092062274481843042907652320664917728267982409212988849109825729150839069369465433531269728824368749655421846730162477193420534803525810831025762500375845466064264837531992986534097821734242082950392892529951104643690838773406549</span></span><br><span class="line">c = <span class="number">406480424882876909664869928877322864482740577681292497936198951316587691545267772748204383995815523935005725558478033908575228532559165174398668885819826720515607326399097899572022020453298441</span></span><br><span class="line">k=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    m = iroot(k*n+c,<span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">    flag = <span class="built_in">str</span>(long_to_bytes(m))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;LitCTF&quot;</span> <span class="keyword">in</span> flag :</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#LitCTF&#123;a1a8887793acfc199182a649e905daab&#125;</span></span><br></pre></td></tr></table></figure>



<h1 id="easy-math"><a href="#easy-math" class="headerlink" title="easy_math"></a>easy_math</h1><p><strong>解方程</strong></p>
<p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">e = 65537</span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(128)</span><br><span class="line">n = p*q</span><br><span class="line">hint = p**3-q**5</span><br><span class="line">c = pow(m,e,n)</span><br><span class="line">print(f&#x27;n = &#123;n&#125;&#x27;)</span><br><span class="line">print(f&#x27;c = &#123;c&#125;&#x27;)</span><br><span class="line">print(f&#x27;hint = &#123;hint&#125;&#x27;)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">n = 2230791374046346835775433548641067593691369485828070649075162141394476183565187654365131822111419512477883295758461313983481545182887415447403634720326639070667688614534290859200753589300443797</span><br><span class="line">c = 2168563038335029902089976057856861885635845445863841607485310134441400500612435296818745930370268060353437465666224400129105788787423156958336380480503762222278722770240792709450637433509537280</span><br><span class="line">hint = 392490868359411675557103683163021977774935163924606169241731307258226973701652855448542714274348304997416149742779376023311152228735117186027560227613656229190807480010615064372521942836446425717660375242197759811804760170129768647414717571386950790115746414735411766002368288743086845078803312201707960465419405926186622999423245762570917629351110970429987377475979058821154568001902541710817731089463915930932142007312230897818177067675996751110894377356758932</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/../../images/LitCTF/6.png"></p>
<p>解方程得到p</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> symbols, solve</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义符号变量</span></span><br><span class="line">x = symbols(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">hint = <span class="number">392490868359411675557103683163021977774935163924606169241731307258226973701652855448542714274348304997416149742779376023311152228735117186027560227613656229190807480010615064372521942836446425717660375242197759811804760170129768647414717571386950790115746414735411766002368288743086845078803312201707960465419405926186622999423245762570917629351110970429987377475979058821154568001902541710817731089463915930932142007312230897818177067675996751110894377356758932</span></span><br><span class="line">n = <span class="number">2230791374046346835775433548641067593691369485828070649075162141394476183565187654365131822111419512477883295758461313983481545182887415447403634720326639070667688614534290859200753589300443797</span></span><br><span class="line"><span class="comment"># 定义方程</span></span><br><span class="line">eq = x**<span class="number">8</span> - x**<span class="number">5</span>*hint - n**<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解方程</span></span><br><span class="line">sol = solve(eq, x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印解</span></span><br><span class="line"><span class="built_in">print</span>(sol)</span><br></pre></td></tr></table></figure>

<p>这个脚本能跑，需要很久，而且输出的结果很多</p>
<p>用下面这个脚本可以更快求出p</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> symbols, solve</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义符号变量</span></span><br><span class="line">p = symbols(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">q = symbols(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">hint = <span class="number">392490868359411675557103683163021977774935163924606169241731307258226973701652855448542714274348304997416149742779376023311152228735117186027560227613656229190807480010615064372521942836446425717660375242197759811804760170129768647414717571386950790115746414735411766002368288743086845078803312201707960465419405926186622999423245762570917629351110970429987377475979058821154568001902541710817731089463915930932142007312230897818177067675996751110894377356758932</span></span><br><span class="line">n = <span class="number">2230791374046346835775433548641067593691369485828070649075162141394476183565187654365131822111419512477883295758461313983481545182887415447403634720326639070667688614534290859200753589300443797</span></span><br><span class="line"><span class="comment"># 定义方程</span></span><br><span class="line">eq1 = p**<span class="number">3</span> - q**<span class="number">5</span> -hint</span><br><span class="line">eq2 = p * q - n </span><br><span class="line"><span class="comment"># 解方程</span></span><br><span class="line">sol = solve((eq1,eq2),(p,q))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印解</span></span><br><span class="line"><span class="built_in">print</span>(sol)</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c=<span class="number">2168563038335029902089976057856861885635845445863841607485310134441400500612435296818745930370268060353437465666224400129105788787423156958336380480503762222278722770240792709450637433509537280</span></span><br><span class="line">p = <span class="number">7321664971326604351487965655099805117568571010588695608389113791312918573783115429227542573780838065461696504325762281209452761930184231131129306271846427</span></span><br><span class="line">q = <span class="number">304683618109085947723284393392507415311</span></span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#LitCTF&#123;f9fab7522253e44b48824e914d0801ba&#125;</span></span><br></pre></td></tr></table></figure>



<h1 id="babyLCG"><a href="#babyLCG" class="headerlink" title="babyLCG"></a>babyLCG</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">bit_len = m.bit_length()</span><br><span class="line">a = getPrime(bit_len)</span><br><span class="line">b = getPrime(bit_len)</span><br><span class="line">p = getPrime(bit_len+1)</span><br><span class="line"></span><br><span class="line">seed = m</span><br><span class="line">result = []</span><br><span class="line">for i in range(10):</span><br><span class="line">    seed = (a*seed+b)%p</span><br><span class="line">    result.append(seed)</span><br><span class="line">print(result)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">result = [699175025435513913222265085178805479192132631113784770123757454808149151697608216361550466652878, 193316257467202036043918706856603526262215679149886976392930192639917920593706895122296071643390, 1624937780477561769577140419364339298985292198464188802403816662221142156714021229977403603922943, 659236391930254891621938248429619132720452597526316230221895367798170380093631947248925278766506, 111407194162820942281872438978366964960570302720229611594374532025973998885554449685055172110829, 1415787594624585063605356859393351333923892058922987749824214311091742328340293435914830175796909, 655057648553921580727111809001898496375489870757705297406250204329094679858718932270475755075698, 1683427135823894785654993254138434580152093609545092045940376086714124324274044014654085676620851, 492953986125248558013838257810313149490245209968714980288031443714890115686764222999717055064509, 70048773361068060773257074705619791938224397526269544533030294499007242937089146507674570192265]</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>求seed初始值，在此之前需要先求a,b,m</strong></p>
<p><strong>关于lcg体制可以观看另外一篇博客</strong></p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">output = [<span class="number">699175025435513913222265085178805479192132631113784770123757454808149151697608216361550466652878</span>, <span class="number">193316257467202036043918706856603526262215679149886976392930192639917920593706895122296071643390</span>, <span class="number">1624937780477561769577140419364339298985292198464188802403816662221142156714021229977403603922943</span>, <span class="number">659236391930254891621938248429619132720452597526316230221895367798170380093631947248925278766506</span>, <span class="number">111407194162820942281872438978366964960570302720229611594374532025973998885554449685055172110829</span>, <span class="number">1415787594624585063605356859393351333923892058922987749824214311091742328340293435914830175796909</span>, <span class="number">655057648553921580727111809001898496375489870757705297406250204329094679858718932270475755075698</span>, <span class="number">1683427135823894785654993254138434580152093609545092045940376086714124324274044014654085676620851</span>, <span class="number">492953986125248558013838257810313149490245209968714980288031443714890115686764222999717055064509</span>, <span class="number">70048773361068060773257074705619791938224397526269544533030294499007242937089146507674570192265</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        t1 = output[i+<span class="number">1</span>]-output[i]</span><br><span class="line">        t2 = output[i+<span class="number">2</span>]-output[i+<span class="number">1</span>]</span><br><span class="line">        t3 = output[i+<span class="number">3</span>]-output[i+<span class="number">2</span>]</span><br><span class="line">        t4 = output[i+<span class="number">4</span>]-output[i+<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">        T1 = t1*t3 - t2*t2</span><br><span class="line">        T2 = t2*t4 - t3*t3</span><br><span class="line">        n = gmpy2.gcd(T1,T2)</span><br><span class="line"></span><br><span class="line">        ni = gmpy2.invert(t1,n)</span><br><span class="line">        a = t2 * ni % n</span><br><span class="line"></span><br><span class="line">        Ani = gmpy2.invert(a,n)</span><br><span class="line">        b = (output[i+<span class="number">1</span>] - a*output[i]) % n</span><br><span class="line"></span><br><span class="line">        m = Ani *(output[<span class="number">0</span>]-b) % n</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#LitCTF&#123;31fcd7832029a87f6c9f760fcf297b2f&#125;</span></span><br></pre></td></tr></table></figure>



<h1 id="P-leak"><a href="#P-leak" class="headerlink" title="P_leak"></a>P_leak</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">e=65537</span><br><span class="line">m=bytes_to_long(b&#x27;xxxx&#x27;)</span><br><span class="line">p=getPrime(512)</span><br><span class="line">q=getPrime(512)</span><br><span class="line">n=p*q</span><br><span class="line">phi=(p-1)*(q-1)</span><br><span class="line">d=inverse(e,phi)</span><br><span class="line">dp=d%(p-1)</span><br><span class="line">c=pow(m,e,n)</span><br><span class="line">print(&quot;dp=&quot;,dp)</span><br><span class="line">print(&quot;n=&quot;,n)</span><br><span class="line">print(&quot;c=&quot;,c)</span><br><span class="line"></span><br><span class="line">#dp= 5892502924236878675675338970704766304539618343869489297045857272605067962848952532606770917225218534430490745895652561015493032055636004130931491316020329</span><br><span class="line">#n= 50612159190225619689404794427464916374543237300894011803225784470008992781409447214236779975896311093686413491163221778479739252804271270231391599602217675895446538524670610623369953168412236472302812808639218392319634397138871387898452935081756580084070333246950840091192420542761507705395568904875746222477</span><br><span class="line">#c= 39257649468514605476432946851710016346016992413796229928386230062780829495844059368939749930876895443279723032641876662714088329296631207594999580050131450251288839714711436117326769029649419789323982613380617840218087161435260837263996287628129307328857086987521821533565738409794866606381789730458247531619</span><br></pre></td></tr></table></figure>

<p><strong>dp泄露</strong></p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n = <span class="number">50612159190225619689404794427464916374543237300894011803225784470008992781409447214236779975896311093686413491163221778479739252804271270231391599602217675895446538524670610623369953168412236472302812808639218392319634397138871387898452935081756580084070333246950840091192420542761507705395568904875746222477</span></span><br><span class="line">c = <span class="number">39257649468514605476432946851710016346016992413796229928386230062780829495844059368939749930876895443279723032641876662714088329296631207594999580050131450251288839714711436117326769029649419789323982613380617840218087161435260837263996287628129307328857086987521821533565738409794866606381789730458247531619</span></span><br><span class="line">dp =<span class="number">5892502924236878675675338970704766304539618343869489297045857272605067962848952532606770917225218534430490745895652561015493032055636004130931491316020329</span></span><br><span class="line">e =<span class="number">65537</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,e):</span><br><span class="line">    t = (dp * e - <span class="number">1</span>) % i        </span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">        p = (dp * e - <span class="number">1</span>) // i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n % p == <span class="number">0</span>:</span><br><span class="line">            q = n // p</span><br><span class="line">            d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">            <span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br><span class="line">            </span><br><span class="line"><span class="comment">#LitCTF&#123;Prim3_1s_Le@k!!!!!&#125;</span></span><br></pre></td></tr></table></figure>



<h1 id="Where-is-P"><a href="#Where-is-P" class="headerlink" title="Where is P"></a>Where is P</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">m=bytes_to_long(b&#x27;XXXX&#x27;)</span><br><span class="line">e=65537</span><br><span class="line">p=getPrime(1024)</span><br><span class="line">q=getPrime(1024)</span><br><span class="line">n=p*q</span><br><span class="line">print(p)</span><br><span class="line">c=pow(m,e,n)</span><br><span class="line">P=p&gt;&gt;340</span><br><span class="line">print(P)</span><br><span class="line">a=pow(P,3,n)</span><br><span class="line">print(&quot;n=&quot;,n)</span><br><span class="line">print(&quot;c=&quot;,c)</span><br><span class="line">print(&quot;a=&quot;,a)</span><br><span class="line"></span><br><span class="line">#n= 24479907029118467064460793139240403258697681144532146836881997837526487637306591893357774423547391867013441147680031968367449693796015901951120514250935018725570026327610524687128709707340727799633444550317834481416507364804274266363478822257132586592232042108076935945436358397787891169163821061005102693505011197453089873909085170776511350713452580692963748763166981047023704528272230392479728897831538235554137129584665886878574314566549330671483636900134584707867654841021494106881794644469229030140144595938886437242375435914268001721437309283611088568191856208951867342004280893021653793820874747638264412653721</span><br><span class="line">#c= 6566517934961780069851397787369134601399136324586682773286046135297104713708615112015588908759927424841719937322574766875308296258325687730658550956691921018605724308665345526807393669538103819281108643141723589363068859617542807984954436567078438099854340705208503317269397632214274507740533638883597409138972287275965697689862321166613821995226000320597560745749780942467497435742492468670016480112957715214640939272457886646483560443432985954141177463448896521810457886108311082101521263110578485768091003174683555938678346359150123350656418123918738868598042533211541966786594006129134087145798672161268647536724</span><br><span class="line">#a= 22184346235325197613876257964606959796734210361241668065837491428527234174610482874427139453643569493268653377061231169173874401139203757698022691973395609028489121048788465356158531144787135876251872262389742175830840373281181905217510352227396545981674450409488394636498629147806808635157820030290630290808150235068140864601098322473572121965126109735529553247807211711005936042322910065304489093415276688746634951081501428768318098925390576594162098506572668709475140964400043947851427774550253257759990959997691631511262768785787474750441024242552456956598974533625095249106992723798354594261566983135394923063605</span><br></pre></td></tr></table></figure>

<p><strong>p高位泄露</strong></p>
<p><strong>因为P大小为684bit,P的3次方是2052bit，而n是2048bit，相差4位</strong></p>
<p><strong>爆一下k就可以得到P</strong></p>
<p><strong>exp:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2</span><br><span class="line"></span><br><span class="line">n= 24479907029118467064460793139240403258697681144532146836881997837526487637306591893357774423547391867013441147680031968367449693796015901951120514250935018725570026327610524687128709707340727799633444550317834481416507364804274266363478822257132586592232042108076935945436358397787891169163821061005102693505011197453089873909085170776511350713452580692963748763166981047023704528272230392479728897831538235554137129584665886878574314566549330671483636900134584707867654841021494106881794644469229030140144595938886437242375435914268001721437309283611088568191856208951867342004280893021653793820874747638264412653721</span><br><span class="line">c= 6566517934961780069851397787369134601399136324586682773286046135297104713708615112015588908759927424841719937322574766875308296258325687730658550956691921018605724308665345526807393669538103819281108643141723589363068859617542807984954436567078438099854340705208503317269397632214274507740533638883597409138972287275965697689862321166613821995226000320597560745749780942467497435742492468670016480112957715214640939272457886646483560443432985954141177463448896521810457886108311082101521263110578485768091003174683555938678346359150123350656418123918738868598042533211541966786594006129134087145798672161268647536724</span><br><span class="line">a= 22184346235325197613876257964606959796734210361241668065837491428527234174610482874427139453643569493268653377061231169173874401139203757698022691973395609028489121048788465356158531144787135876251872262389742175830840373281181905217510352227396545981674450409488394636498629147806808635157820030290630290808150235068140864601098322473572121965126109735529553247807211711005936042322910065304489093415276688746634951081501428768318098925390576594162098506572668709475140964400043947851427774550253257759990959997691631511262768785787474750441024242552456956598974533625095249106992723798354594261566983135394923063605</span><br><span class="line">e = 65537</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line"></span><br><span class="line">for k in range(1000):</span><br><span class="line">    t = gmpy2.iroot(k*n+a,3)</span><br><span class="line">    if t[1]:</span><br><span class="line">        high_p = int(t[0])&lt;&lt;340</span><br><span class="line">        f = high_p + x</span><br><span class="line">        x = f.small_roots(X = 2^340,beta = 0.4)</span><br><span class="line">        if x:</span><br><span class="line">            p = int(high_p + x[0])</span><br><span class="line">            q = n  //  int(p)</span><br><span class="line">            d = gmpy2.invert(e,(p-1)*(q-1))</span><br><span class="line">            m = pow(c,d,n)</span><br><span class="line">            print(k)</span><br><span class="line">            print(long_to_bytes(int(m)))</span><br><span class="line">            break</span><br><span class="line">    </span><br><span class="line"># k = 11</span><br><span class="line"># LitCTF&#123;Y0U_hAV3_g0T_Th3_r1ghT_AnsW3r&#125;</span><br></pre></td></tr></table></figure>



<h1 id="我测你vva"><a href="#我测你vva" class="headerlink" title="我测你vva"></a>我测你vva</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Encrypto&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String flag=&quot;&quot;;</span><br><span class="line">        int cipher;</span><br><span class="line">        char[] arr;</span><br><span class="line">        arr=flag.toCharArray();</span><br><span class="line">        for(int i=0; i&lt;flag.length(); i++) &#123;</span><br><span class="line">           if(i%2==0)&#123;</span><br><span class="line">            cipher=Integer.valueOf(arr[i]);</span><br><span class="line">            cipher=cipher+i;</span><br><span class="line">            System.out.print((char)cipher);</span><br><span class="line">           &#125;</span><br><span class="line">           if(i%2!=0)&#123;</span><br><span class="line">            cipher=Integer.valueOf(arr[i]);</span><br><span class="line">            cipher=cipher-i;</span><br><span class="line">            System.out.print((char)cipher);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//cipher=HYEQJvPZ~X@+Bp</span><br></pre></td></tr></table></figure>

<p><strong>比赛的时候是非预期解，现在重新做一遍</strong></p>
<p><strong><code>Integer.valueOf()</code> 方法将一个字符串表示的整数转换为对应的<code>Integer</code> 对象</strong></p>
<p><strong>题目的意思就是把明文偶数位的值加上他的索引值再变为字符串,eg:<code>arr[2]=&quot;65&quot;</code>经过加密之后这个位置就变成了”C”</strong></p>
<p><strong>奇数位则是把明文减去他的索引值</strong></p>
<p><strong>把脚本逆回去就行了</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decrypto</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String Cipher=<span class="string">&quot;HYEQJvPZ~X@+Bp&quot;</span>;</span><br><span class="line">        <span class="type">int</span> flag;</span><br><span class="line">        <span class="type">char</span>[] arr;</span><br><span class="line">        arr=Cipher.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;Cipher.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            flag=Integer.valueOf(arr[i]);</span><br><span class="line">            flag=flag-i;</span><br><span class="line">            System.out.print((<span class="type">char</span>)flag);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(i%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            flag=Integer.valueOf(arr[i]);</span><br><span class="line">            flag=flag+i;</span><br><span class="line">            System.out.print((<span class="type">char</span>)flag);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># HZCTF&#123;Java666&#125;</span><br><span class="line"># 格式改一下 LitCTF&#123;Java666&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Babyxor"><a href="#Babyxor" class="headerlink" title="Babyxor"></a>Babyxor</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">assert len(flag)==32</span><br><span class="line">p = getPrime(512)</span><br><span class="line">q = getPrime(512)</span><br><span class="line">n = p*q</span><br><span class="line">e = 65537</span><br><span class="line">c1 = p^m</span><br><span class="line">c2 = pow(m,e,n)</span><br><span class="line">print(f&#x27;n = &#123;n&#125;&#x27;)</span><br><span class="line">print(f&#x27;c1 = &#123;c1&#125;&#x27;)</span><br><span class="line">print(f&#x27;c2 = &#123;c2&#125;&#x27;)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">n = 139167681803392690594490403105432649693546256181767408269202101512534988406137879788255103631885736461742577594980136624933914700779445704490217419248411578290305101891222576080645870988658334799437317221565839991979543660824098367011942169305111105129234902517835649895908656770416774539906212596072334423407</span><br><span class="line">c1 = 11201139662236758800406931253538295757259990870588609533820056210585752522925690049252488581929717556881067021381940083808024384402885422258545946243513996</span><br><span class="line">c2 = 112016152270171196606652761990170033221036025260883289104273504703557624964071464062375228351458191745141525003775876044271210498526920529385038130932141551598616579917681815276713386113932345056134302042399379895915706991873687943357627747262597883603999621939794450743982662393955266685255577026078256473601</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>首先测试了一下32长度的字符串，转为int类型的数据大概是256bit</strong></p>
<p><strong>1024位的p需要已知576位</strong></p>
<p><strong>512位的p需要已知288位</strong></p>
<p><strong>当满足这样一个关系的时候才可恢复：</strong></p>
<p><img src="/../../images/LitCTF/9.png"></p>
<p><strong>但是把f.small_roots(X,beta,epsilon)中的epsilon改为0.01，即最小的时候，可以在已知264位的情况下恢复512位的p，已知528位恢复1024位的p，而这道题中，我们已知256位p，所以需要爆破8位，再恢复p</strong></p>
<p>exp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from tqdm import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">n = 139167681803392690594490403105432649693546256181767408269202101512534988406137879788255103631885736461742577594980136624933914700779445704490217419248411578290305101891222576080645870988658334799437317221565839991979543660824098367011942169305111105129234902517835649895908656770416774539906212596072334423407</span><br><span class="line">c1 = 11201139662236758800406931253538295757259990870588609533820056210585752522925690049252488581929717556881067021381940083808024384402885422258545946243513996</span><br><span class="line">c2 = 112016152270171196606652761990170033221036025260883289104273504703557624964071464062375228351458191745141525003775876044271210498526920529385038130932141551598616579917681815276713386113932345056134302042399379895915706991873687943357627747262597883603999621939794450743982662393955266685255577026078256473601</span><br><span class="line">e=65537</span><br><span class="line">pbits = 512</span><br><span class="line"></span><br><span class="line">p_high = c1 &gt;&gt; 256</span><br><span class="line">for i in trange(2**8):</span><br><span class="line">     p4 = p_high&lt;&lt;8			#这里需要先爆破8位，使得知道264位以后再恢复p</span><br><span class="line">     p4 = p4 + i</span><br><span class="line">     kbits = pbits - p4.nbits()</span><br><span class="line">     p4 = p4 &lt;&lt; kbits</span><br><span class="line">     R.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">     f = x + p4</span><br><span class="line">     x = f.small_roots(X=2^kbits, beta=0.4, epsilon=0.01)</span><br><span class="line">     if x:</span><br><span class="line">         p = p4 + int(x[0])</span><br><span class="line">         q = n // p</span><br><span class="line">         d = gmpy2.invert(e,(p-1)*(q-1))</span><br><span class="line">         m = pow(c2,d,n)</span><br><span class="line">         print(long_to_bytes(int(m)))</span><br><span class="line">         break</span><br><span class="line"></span><br><span class="line">#LitCTF&#123;oh!!!!coppersmith_is_fun&#125;</span><br></pre></td></tr></table></figure>

<p>放虚拟机跑会更快一些</p>
<p><img src="/../../images/LitCTF/8.png"></p>
]]></content>
      <categories>
        <category>Wp</category>
      </categories>
      <tags>
        <tag>Wp</tag>
      </tags>
  </entry>
  <entry>
    <title>NKCTF</title>
    <url>/2023/07/14/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/NKCTF/</url>
    <content><![CDATA[<p>重新做一遍NKCTF的题（没写完，之后慢慢做）</p>
<span id="more"></span>

<h1 id="baby-RSA"><a href="#baby-RSA" class="headerlink" title="baby_RSA"></a>baby_RSA</h1><p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">nbit = 512</span><br><span class="line">flag=&#x27;****************************&#x27;</span><br><span class="line"></span><br><span class="line">p=getPrime(nbit)</span><br><span class="line">q=getPrime(nbit)</span><br><span class="line">e=65537</span><br><span class="line">n=p*q</span><br><span class="line">m= bytes_to_long(bytes(flag.encode()))</span><br><span class="line">P = pow(m,p,n)</span><br><span class="line">Q = pow(m,q,n)</span><br><span class="line">N=P*Q</span><br><span class="line">phi_N=(P-1)*(Q-1)</span><br><span class="line">d=inverse(e,phi_N)</span><br><span class="line">dP=d%(P-1)</span><br><span class="line">print(&#x27;n = &#x27;,n)</span><br><span class="line">print(&#x27;N = &#x27;,N)</span><br><span class="line">print(&#x27;dP = &#x27;,dP)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n =  114101396033690088275999670914803472451228154227614098210572767821433470213124900655723605426526569384342101959232900145334500170690603208327913698128445002527020347955300595384752458477749198178791196660625870659540794807018881780680683388008090434114437818447523471527878292741702348454486217652394664664641</span><br><span class="line">N =  1159977299277711167607914893426674454199208605107323826176606074354449015203832606569051328721360397610665453513201486235549374869954501563523028914285006850687275382822302821825953121223999268058107278346499657597050468069712686559045712946025472616754027552629008516489090871415609098178522863027127254404804829735621706042266140637592206366042515190385496909533329383212542170504864473944657824502882014292528444918055958758310544435120502872883857209880723535754528096143707324179005292445100655695427777453144657819474805882956064292780031599790769618615908501966912635232746588639924772530057835864082951499028</span><br><span class="line">dP =  33967356791272818610254738927769774016289590226681637441101504040121743937150259930712897925893431093938385216227201268238374281750681609796883676743311872905933219290266120756315613501614208779063819499785817502677885240656957036398336462000771885589364702443157120609506628895933862241269347200444629283263</span><br></pre></td></tr></table></figure>

<p><strong>dp泄露先求P,Q</strong></p>
<p>$\because P \equiv m^p \mod n \longrightarrow P \equiv m^p \mod p \longrightarrow P \equiv m \mod p \therefore P &#x3D; m+k_1p$</p>
<p>同理$Q &#x3D; m + k_2q$</p>
<p>则$PQ &#x3D; (m+k_1p)(m+k_2q) &#x3D; m^2+m(k_1p+k_2q)+k_1k_2n&#x3D;m^2 + m(P-m+Q-m)+k_1k_2n$</p>
<p>$\therefore PQ \equiv m^2+m(P-m+Q-m) \mod n$</p>
<p>CopperSmith求解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n = <span class="number">114101396033690088275999670914803472451228154227614098210572767821433470213124900655723605426526569384342101959232900145334500170690603208327913698128445002527020347955300595384752458477749198178791196660625870659540794807018881780680683388008090434114437818447523471527878292741702348454486217652394664664641</span></span><br><span class="line">N = <span class="number">1159977299277711167607914893426674454199208605107323826176606074354449015203832606569051328721360397610665453513201486235549374869954501563523028914285006850687275382822302821825953121223999268058107278346499657597050468069712686559045712946025472616754027552629008516489090871415609098178522863027127254404804829735621706042266140637592206366042515190385496909533329383212542170504864473944657824502882014292528444918055958758310544435120502872883857209880723535754528096143707324179005292445100655695427777453144657819474805882956064292780031599790769618615908501966912635232746588639924772530057835864082951499028</span></span><br><span class="line">dP = <span class="number">33967356791272818610254738927769774016289590226681637441101504040121743937150259930712897925893431093938385216227201268238374281750681609796883676743311872905933219290266120756315613501614208779063819499785817502677885240656957036398336462000771885589364702443157120609506628895933862241269347200444629283263</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,e):</span><br><span class="line">    t = (dP * e - <span class="number">1</span>) % i        </span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">        P = (dP * e - <span class="number">1</span>) // i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> N % P == <span class="number">0</span>:</span><br><span class="line">            P = (dP * e - <span class="number">1</span>) // i + <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;P=&quot;</span>,P)</span><br><span class="line">            Q = N // P</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Q=&quot;</span>,Q)</span><br><span class="line"></span><br><span class="line">            R.&lt;m&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">            </span><br><span class="line">            f = m^<span class="number">2</span> + m * (P - m + Q - m) - P * Q</span><br><span class="line">            f = f.monic()</span><br><span class="line">            m = f.small_roots(X=<span class="number">2</span>^<span class="number">400</span>,beta=<span class="number">0.4</span>)</span><br><span class="line">            <span class="comment">#print(m)</span></span><br><span class="line">            flag = long_to_bytes(<span class="built_in">int</span>(m[<span class="number">0</span>]))</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<p>另外一种解法：</p>
<p><img src="/../../images/NKCTF/0.png"></p>
<p><strong>得到kp后和n求公因数p</strong></p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n = <span class="number">114101396033690088275999670914803472451228154227614098210572767821433470213124900655723605426526569384342101959232900145334500170690603208327913698128445002527020347955300595384752458477749198178791196660625870659540794807018881780680683388008090434114437818447523471527878292741702348454486217652394664664641</span></span><br><span class="line">N = <span class="number">1159977299277711167607914893426674454199208605107323826176606074354449015203832606569051328721360397610665453513201486235549374869954501563523028914285006850687275382822302821825953121223999268058107278346499657597050468069712686559045712946025472616754027552629008516489090871415609098178522863027127254404804829735621706042266140637592206366042515190385496909533329383212542170504864473944657824502882014292528444918055958758310544435120502872883857209880723535754528096143707324179005292445100655695427777453144657819474805882956064292780031599790769618615908501966912635232746588639924772530057835864082951499028</span></span><br><span class="line">dP = <span class="number">33967356791272818610254738927769774016289590226681637441101504040121743937150259930712897925893431093938385216227201268238374281750681609796883676743311872905933219290266120756315613501614208779063819499785817502677885240656957036398336462000771885589364702443157120609506628895933862241269347200444629283263</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,e):</span><br><span class="line">    t = (dP * e - <span class="number">1</span>) % i        </span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">        P = (dP * e - <span class="number">1</span>) // i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> N % P == <span class="number">0</span>:</span><br><span class="line">            P = (dP * e - <span class="number">1</span>) // i + <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;P=&quot;</span>,P)</span><br><span class="line">            Q = N // P</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Q=&quot;</span>,Q)</span><br><span class="line"></span><br><span class="line">            x,y = P,Q</span><br><span class="line">            tmp = <span class="built_in">pow</span>(x,n,n) - y</span><br><span class="line">            p = gmpy2.gcd(tmp,n)</span><br><span class="line">            q = n // p</span><br><span class="line">            d = gmpy2.invert(p,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))			<span class="comment">#留意一下加密指数是p</span></span><br><span class="line">            m = <span class="built_in">pow</span>(x,d,n)</span><br><span class="line">            <span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>

<h1 id="ez-math"><a href="#ez-math" class="headerlink" title="ez_math"></a>ez_math</h1><p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import getPrime, bytes_to_long</span><br><span class="line">from secret import BITS, hints, flag</span><br><span class="line"></span><br><span class="line">p = getPrime(BITS)</span><br><span class="line">q = getPrime(BITS)</span><br><span class="line">n = p * q</span><br><span class="line">print(f&#x27;n = &#123;n&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">e = 0x10001</span><br><span class="line">c = pow(bytes_to_long(flag), e, n)</span><br><span class="line">print(f&#x27;c = &#123;c&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">print(&#x27;Give you some boring pows:&#x27;)</span><br><span class="line">for i in range(len(hints)):</span><br><span class="line">    print(hints[i])</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">n = 369520637995317866367336688225182965061898803879373674073832046072914710171302486913303917853881549637806426191970292829598855375370563396182543413674021955181862907847280705741114636854238746612618069619482248639049407507041667720977392421249242597197448360531895206645794505182208390084734779667749657408715621</span><br><span class="line">c = 324131338592233305486487416176106472248153652884280898177125443926549710357763331715045582842045967830200123100144721322509500306940560917086108978796500145618443920020112366546853892387011738997522207752873944151628204886591075864677988865335625452099668804529484866900390927644093597772065285222172136374562043</span><br><span class="line">Give you some boring pows:</span><br><span class="line">pow(6, 42762902032363446334121451790132830028099011269558028556333775251728898854654431095595000922138958455510196735338223430882428451914478079186797153527810555787441234842366353864053114538165236037883914332840687123514412294276743506313011532002136735343280737244020115917460801848337792582496228600926958548903290, n) = 4</span><br><span class="line">pow(6, 141997416965295486849546892322458652502850390670128808480582247784728456230996812361056958004801816363393016360646922983916999235770803618904474553309200419301820603229504955218189709387942156848904968053547462302189568831762401075340100029630332409419313772378068180267756675141584884876543484516408660699471038, n) = 9</span><br><span class="line">pow(6, 163378867981477210016607618217525067516899896304907822758749135410592905658324027908854458465871295591148114728316034699358213461728042658497873130073105697195541220650688132150216266657024774867846925219967805863946774978900772828496605795631400777090954141000078238226487076065753781167791598816872139973922682, n) = 3</span><br><span class="line">pow(5, 101651508435846472131121026992982127175369332865677196032272241712711171024515826370577416844824734811581351106736224929238579734879671732717639124571916168742336862493284572465162318403582113621582374924091725060981390318743531229548188092491836655143124663368239422819562367919547196053790207486164506763679128, n) = 4</span><br><span class="line">pow(8, 7202269322818255506843028035725052687541091567764933235328308385449791332345247877549905289072216053144576876979686287212194040101112899704499548530779540409356827298148385589812450437990490353926475147376495772639210184768544932563432306664067058309318707174880146258394471096033723193568453520897758319446472, n) = 3</span><br><span class="line">pow(6, 64144353048545169501182177685199245042148516904337042834500662877593348281981646643392501383208437683265295103007335146323642677871717118780195730291715833681161852263549530796079671807247854056825871499261030685271618441415115259469517298003205103014921105866030173876191202772506688873744342901390437823354935, n) = 8</span><br><span class="line">pow(6, 21381451016181723167060725895066415014049505634779014278166887625864449427327215547797500461069479227755098367669111715441214225957239039593398576763905277893720617421183176932026557269082618018941957166420343561757206147138371753156505766001068367671640368622010057958730400924168896291248114300463479274451645, n) = 2</span><br><span class="line">pow(4, 21606807968454766520529084107175158062623274703294799705984925156349373997035743632649715867216648159433730630939058861636582120303338699113498645592338621228070481894445156769437351313971471061779425442129487317917630554305634797690296919992201174927956121524640438775183413288101169580705360562693274958339416, n) = 9</span><br><span class="line">pow(2, 21606807968454766520529084107175158062623274703294799705984925156349373997035743632649715867216648159433730630939058861636582120303338699113498645592338621228070481894445156769437351313971471061779425442129487317917630554305634797690296919992201174927956121524640438775183413288101169580705360562693274958339417, n) = 6</span><br><span class="line">pow(4, 10803403984227383260264542053587579031311637351647399852992462578174686998517871816324857933608324079716865315469529430818291060151669349556749322796169310614035240947222578384718675656985735530889712721064743658958815277152817398845148459996100587463978060762320219387591706644050584790352680281346637479169708, n) = 3</span><br><span class="line">pow(9, 3293982057350410278459882519024200329089724149803879577174733206141551016681048848343176690789446255513117465644006032807116613436995145441651711865811812905401261777042165657533800465011922458688696664211216129846590488003282750224539553623014598025837108471148806368738631086225250952573439068109703953523338, n) = 4</span><br><span class="line">pow(2, 43213615936909533041058168214350316125246549406589599411969850312698747994071487265299431734433296318867461261878117723273164240606677398226997291184677242456140963788890313538874702627942942123558850884258974635835261108611269595380593839984402349855912243049280877550366826576202339161410721125386549916678832, n) = 9</span><br><span class="line">pow(7, 156359509651684605051402965560382969488421316701585527115005130492947292379802933549188085059602557600903593831240316597311439285149968787780538126741092612405335349622445040578126369183536683733294143156965518222696624206221060030916594302284630706642066420353822195108928341123726471513256217857861184609387726, n) = 9</span><br><span class="line">pow(7, 170559914324671769117535654836487226009685359320636182075960576764702323732727088502920021993271666209903403463612731506055433486417625242935904916789051793747298593847158174830184596554822038310041512771676833824200302666130102306284852931958549925702330464987955245647072909056824574486147965487598401928881026, n) = 3</span><br><span class="line">pow(8, 123173545998439288789112229408394321687299601293124558024610682024304903390434162304434639284627183212602142063990097609866285125123521132060847804558007316726174558714580872721495215950738261924525921590925432950469320750692763054435407707754979429841729673081392197456811651326615118306026475411557079498916218, n) = 4</span><br><span class="line">pow(2, 21606807968454766520529084107175158062623274703294799705984925156349373997035743632649715867216648159433730630939058861636582120303338699113498645592338621228070481894445156769437351313971471061779425442129487317917630554305634797690296919992201174927956121524640438775183413288101169580705360562693274958339416, n) = 3</span><br><span class="line">pow(3, 6587964114700820556919765038048400658179448299607759154349466412283102033362097696686353381578892511026234931288012065614233226873990290883303423731623625810802523554084331315067600930023844917377393328422432259693180976006565500449079107246029196051674216942297612737477262172450501905146878136219407907046676, n) = 4</span><br><span class="line">pow(7, 146900004342901005519726059203387905743111231159623333298786259340649199259667124880775175860427705602975071010583553281005991812801779033020769274211420710213704563866848310994325033574484679477677016014418321661821714582236428708141287327064859146436371562752616380650770729341741997594308364878898526065859626, n) = 4</span><br><span class="line">pow(5, 172192380036714150788905270808196199818277334366508682218739812159577144024191963252552116624193235000074634457087111471641800814071769221933018962135503876997163938949365614056098717522475180216291316295788774044033481065993544994610614082708563841846852650913646728169671510827052772868386414581035580266356334, n) = 3</span><br><span class="line">pow(8, 68789042322037899901399142739922213531190892214327212247633649397602243027562329029767224931385807659445647908974735092145336602662873465734923450809783198772444106655438821950560058413359621316189435942839212247873870560114926459781136160541556773230183543715576244986800296759341282346581691226676298068904581, n) = 6</span><br><span class="line">pow(5, 159624441075769368394142197503800917105605266793330527400563601282696932962732683048452274321445695181246055818189076528484173940458256745774766217433996778905066039826859919029954611118842967545793750205189398662362981005947945407568116603784658538931110792205205160154125544664182868277733116044735541284338342, n) = 9</span><br><span class="line">pow(8, 14404538645636511013686056071450105375082183135529866470656616770899582664690495755099810578144432106289153753959372574424388080202225799408999097061559080818713654596296771179624900875980980707852950294752991545278420369537089865126864613328134116618637414349760292516788942192067446387136907041795516638892944, n) = 9</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>$\because 7^{data_1} \equiv 3 \mod n$，$7^{data_2} \equiv 9 \mod n$，$\therefore 7^{2data_1} \equiv 9 \mod n$</p>
<p>做除法之后则有$7^{2data_1-data_2} \equiv 1 \mod n$，$\therefore 2data_1-data_2 \equiv 0 \mod phi$</p>
<p>如果$2data_1 \ne data_2$，则$2data_1-data_2 &#x3D; kphi$</p>
<p>随后把$kphi$当作$phi$解密。</p>
<p>需要注意的是，有的$data_1$和$data_2$求出来的$phi$与$e$不存在逆元</p>
<p>这里我选择的是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pow(7, 156359509651684605051402965560382969488421316701585527115005130492947292379802933549188085059602557600903593831240316597311439285149968787780538126741092612405335349622445040578126369183536683733294143156965518222696624206221060030916594302284630706642066420353822195108928341123726471513256217857861184609387726, n) = 9</span><br><span class="line">pow(7, 170559914324671769117535654836487226009685359320636182075960576764702323732727088502920021993271666209903403463612731506055433486417625242935904916789051793747298593847158174830184596554822038310041512771676833824200302666130102306284852931958549925702330464987955245647072909056824574486147965487598401928881026, n) = 3</span><br></pre></td></tr></table></figure>

<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="number">369520637995317866367336688225182965061898803879373674073832046072914710171302486913303917853881549637806426191970292829598855375370563396182543413674021955181862907847280705741114636854238746612618069619482248639049407507041667720977392421249242597197448360531895206645794505182208390084734779667749657408715621</span></span><br><span class="line">c = <span class="number">324131338592233305486487416176106472248153652884280898177125443926549710357763331715045582842045967830200123100144721322509500306940560917086108978796500145618443920020112366546853892387011738997522207752873944151628204886591075864677988865335625452099668804529484866900390927644093597772065285222172136374562043</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">data1 = <span class="number">170559914324671769117535654836487226009685359320636182075960576764702323732727088502920021993271666209903403463612731506055433486417625242935904916789051793747298593847158174830184596554822038310041512771676833824200302666130102306284852931958549925702330464987955245647072909056824574486147965487598401928881026</span></span><br><span class="line">data2 = <span class="number">156359509651684605051402965560382969488421316701585527115005130492947292379802933549188085059602557600903593831240316597311439285149968787780538126741092612405335349622445040578126369183536683733294143156965518222696624206221060030916594302284630706642066420353822195108928341123726471513256217857861184609387726</span></span><br><span class="line"></span><br><span class="line">kphi = <span class="number">2</span>*data1-data2</span><br><span class="line">d = gmpy2.invert(e,kphi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>



<h1 id="ezRSA"><a href="#ezRSA" class="headerlink" title="ezRSA"></a>ezRSA</h1><p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">m1 = bytes_to_long(flag[:len(flag)//3])</span><br><span class="line">m2 = bytes_to_long(flag[len(flag)//3:])</span><br><span class="line"></span><br><span class="line">def gen():</span><br><span class="line">    prime_list  = []</span><br><span class="line">    for i in range(4):</span><br><span class="line">        prime_list.append(getPrime(512))</span><br><span class="line">    return sorted(prime_list)</span><br><span class="line"></span><br><span class="line">prime_list = gen()</span><br><span class="line">p,q,r,t = prime_list[0],prime_list[3],prime_list[1],prime_list[2]</span><br><span class="line">e = 65537</span><br><span class="line">n = p*q*r*t</span><br><span class="line">phi = (p-1)*(q-1)*(r-1)*(t-1)</span><br><span class="line">c1 = pow(m1,e,p*q)</span><br><span class="line">p1 = getPrime(512)</span><br><span class="line">q1 = getPrime(512)</span><br><span class="line">N = p1*q1</span><br><span class="line">c2 = pow(m2,p1,N)</span><br><span class="line">c3 = pow(m2,q1,N)</span><br><span class="line">print(f&#x27;n = &#123;n&#125;&#x27;)</span><br><span class="line">print(f&#x27;phi = &#123;phi&#125;&#x27;)</span><br><span class="line">print(f&#x27;c1 = &#123;c1&#125;&#x27;)</span><br><span class="line">print(f&#x27;N = &#123;N&#125;&#x27;)</span><br><span class="line">print(f&#x27;c2 = &#123;c2&#125;&#x27;)</span><br><span class="line">print(f&#x27;c3 = &#123;c3&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">n = 8836130216343708623415307573630337110573363595188748983290313549413242332143945452914800845282478216810685733227137911630239808895196748125078747600505626165666334675100147790578546682128517668100858766784733351894480181877144793496927464058323582165412552970999921215333509253052644024478417393146000490808639363681195799826541558906527985336104761974023394438549055804234997654701266967731137282297623426318212701157416397999108259257077847307874122736921265599854976855949680133804464839768470200425669609996841568545945133611190979810786943246285103031363790663362165522662820344917056587244701635831061853354597</span><br><span class="line">phi = 8836130216343708623415307573630337110573363595188748983290313549413242332143945452914800845282478216810685733227137911630239808895196748125078747600505622503351461565956106005118029537938273153581675065762015952483687057805462728186901563990429998916382820576211887477098611684072561849314986341226981300596338314989867731725668312057134075244816223120038573374383949718714549930261073576391501671722900294331289082826058292599838631513746370889828026039555245672195833927609280773258978856664434349221972568651378808050580665443131001632395175205804045958846124475183825589672204752895252723130454951830966138888560</span><br><span class="line">c1 = 78327207863361017953496121356221173288422862370301396867341957979087627011991738176024643637029313969241151622985226595093079857523487726626882109114134910056673489916408854152274726721451884257677533593174371742411008169082367666168983943358876017521749198218529804830864940274185360506199116451280975188409</span><br><span class="line">N = 157202814866563156513184271957553223260772141845129283711146204376449001653397810781717934720804041916333174673656579086498762693983380365527400604554663873045166444369504886603233275868192688995284322277504050322927511160583280269073338415758019142878016084536129741435221345599028001581385308324407324725353</span><br><span class="line">c2 = 63355788175487221030596314921407476078592001060627033831694843409637965350474955727383434406640075122932939559532216639739294413008164038257338675094324172634789610307227365830016457714456293397466445820352804725466971828172010276387616894829328491068298742711984800900411277550023220538443014162710037992032</span><br><span class="line">c3 = 9266334096866207047544089419994475379619964393206968260875878305040712629590906330073542575719856965053269812924808810766674072615270535207284077081944428011398767330973702305174973148018082513467080087706443512285098600431136743009829009567065760786940706627087366702015319792328141978938111501345426931078</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h2><p>已知$phi$和$n$分解n得到$p,q,r,t$</p>
<h2 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h2><p>和baby_RSA一样的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> gcd</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> isqrt</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> is_prime</span><br><span class="line"><span class="comment"># from sage.all import is_prime</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorize</span>(<span class="params">N, phi</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Recovers the prime factors from a modulus if Euler&#x27;s totient is known.</span></span><br><span class="line"><span class="string">    This method only works for a modulus consisting of 2 primes!</span></span><br><span class="line"><span class="string">    :param N: the modulus</span></span><br><span class="line"><span class="string">    :param phi: Euler&#x27;s totient, the order of the multiplicative group modulo N</span></span><br><span class="line"><span class="string">    :return: a tuple containing the prime factors, or None if the factors were not found</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    s = N + <span class="number">1</span> - phi</span><br><span class="line">    d = s ** <span class="number">2</span> - <span class="number">4</span> * N</span><br><span class="line">    p = <span class="built_in">int</span>(s - isqrt(d)) // <span class="number">2</span></span><br><span class="line">    q = <span class="built_in">int</span>(s + isqrt(d)) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> p, q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorize_multi_prime</span>(<span class="params">N, phi</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Recovers the prime factors from a modulus if Euler&#x27;s totient is known.</span></span><br><span class="line"><span class="string">    This method works for a modulus consisting of any number of primes, but is considerably be slower than factorize.</span></span><br><span class="line"><span class="string">    More information: Hinek M. J., Low M. K., Teske E., &quot;On Some Attacks on Multi-prime RSA&quot; (Section 3)</span></span><br><span class="line"><span class="string">    :param N: the modulus</span></span><br><span class="line"><span class="string">    :param phi: Euler&#x27;s totient, the order of the multiplicative group modulo N</span></span><br><span class="line"><span class="string">    :return: a tuple containing the prime factors</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    prime_factors = <span class="built_in">set</span>()</span><br><span class="line">    factors = [N]</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(factors) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># Element to factorize.</span></span><br><span class="line">        N = factors[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        w = randrange(<span class="number">2</span>, N - <span class="number">1</span>)</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> phi % (<span class="number">2</span> ** i) == <span class="number">0</span>:</span><br><span class="line">            sqrt_1 = <span class="built_in">pow</span>(w, phi // (<span class="number">2</span> ** i), N)</span><br><span class="line">            <span class="keyword">if</span> sqrt_1 &gt; <span class="number">1</span> <span class="keyword">and</span> sqrt_1 != N - <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># We can remove the element to factorize now, because we have a factorization.</span></span><br><span class="line">                factors = factors[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">                p = gcd(N, sqrt_1 + <span class="number">1</span>)</span><br><span class="line">                q = N // p</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> is_prime(p):</span><br><span class="line">                    prime_factors.add(p)</span><br><span class="line">                <span class="keyword">elif</span> p &gt; <span class="number">1</span>:</span><br><span class="line">                    factors.append(p)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> is_prime(q):</span><br><span class="line">                    prime_factors.add(q)</span><br><span class="line">                <span class="keyword">elif</span> q &gt; <span class="number">1</span>:</span><br><span class="line">                    factors.append(q)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Continue in the outer loop</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tuple</span>(prime_factors)</span><br><span class="line">    </span><br><span class="line">n = <span class="number">8836130216343708623415307573630337110573363595188748983290313549413242332143945452914800845282478216810685733227137911630239808895196748125078747600505626165666334675100147790578546682128517668100858766784733351894480181877144793496927464058323582165412552970999921215333509253052644024478417393146000490808639363681195799826541558906527985336104761974023394438549055804234997654701266967731137282297623426318212701157416397999108259257077847307874122736921265599854976855949680133804464839768470200425669609996841568545945133611190979810786943246285103031363790663362165522662820344917056587244701635831061853354597</span></span><br><span class="line">phi = <span class="number">8836130216343708623415307573630337110573363595188748983290313549413242332143945452914800845282478216810685733227137911630239808895196748125078747600505622503351461565956106005118029537938273153581675065762015952483687057805462728186901563990429998916382820576211887477098611684072561849314986341226981300596338314989867731725668312057134075244816223120038573374383949718714549930261073576391501671722900294331289082826058292599838631513746370889828026039555245672195833927609280773258978856664434349221972568651378808050580665443131001632395175205804045958846124475183825589672204752895252723130454951830966138888560</span></span><br><span class="line"></span><br><span class="line">c1 = <span class="number">78327207863361017953496121356221173288422862370301396867341957979087627011991738176024643637029313969241151622985226595093079857523487726626882109114134910056673489916408854152274726721451884257677533593174371742411008169082367666168983943358876017521749198218529804830864940274185360506199116451280975188409</span></span><br><span class="line">N = <span class="number">157202814866563156513184271957553223260772141845129283711146204376449001653397810781717934720804041916333174673656579086498762693983380365527400604554663873045166444369504886603233275868192688995284322277504050322927511160583280269073338415758019142878016084536129741435221345599028001581385308324407324725353</span></span><br><span class="line">c2 = <span class="number">63355788175487221030596314921407476078592001060627033831694843409637965350474955727383434406640075122932939559532216639739294413008164038257338675094324172634789610307227365830016457714456293397466445820352804725466971828172010276387616894829328491068298742711984800900411277550023220538443014162710037992032</span></span><br><span class="line">c3 = <span class="number">9266334096866207047544089419994475379619964393206968260875878305040712629590906330073542575719856965053269812924808810766674072615270535207284077081944428011398767330973702305174973148018082513467080087706443512285098600431136743009829009567065760786940706627087366702015319792328141978938111501345426931078</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">prime_list = <span class="built_in">sorted</span>(factorize_multi_prime(n,phi))</span><br><span class="line">p,q,r,s = prime_list[<span class="number">0</span>],prime_list[<span class="number">3</span>],prime_list[<span class="number">1</span>],prime_list[<span class="number">2</span>]</span><br><span class="line">d1 = gmpy2.invert(<span class="number">65537</span>,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c1,d1,p*q)</span><br><span class="line">flag1 = long_to_bytes(<span class="built_in">int</span>(m))</span><br><span class="line"></span><br><span class="line">length = <span class="built_in">len</span>(flag1)</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(N))</span><br><span class="line"></span><br><span class="line">f = x^<span class="number">2</span> + x * (c2 - x + c3 - x) - c2 * c3</span><br><span class="line">f = f.monic()</span><br><span class="line">x = f.small_roots(X=<span class="number">2</span>^(length*<span class="number">2</span>*<span class="number">8</span>))</span><br><span class="line"><span class="comment">#print(x)</span></span><br><span class="line"></span><br><span class="line">flag2 = long_to_bytes(<span class="built_in">int</span>(x[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(flag1+flag2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> gcd</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> isqrt</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> is_prime</span><br><span class="line"><span class="comment"># from sage.all import is_prime</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorize</span>(<span class="params">N, phi</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Recovers the prime factors from a modulus if Euler&#x27;s totient is known.</span></span><br><span class="line"><span class="string">    This method only works for a modulus consisting of 2 primes!</span></span><br><span class="line"><span class="string">    :param N: the modulus</span></span><br><span class="line"><span class="string">    :param phi: Euler&#x27;s totient, the order of the multiplicative group modulo N</span></span><br><span class="line"><span class="string">    :return: a tuple containing the prime factors, or None if the factors were not found</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    s = N + <span class="number">1</span> - phi</span><br><span class="line">    d = s ** <span class="number">2</span> - <span class="number">4</span> * N</span><br><span class="line">    p = <span class="built_in">int</span>(s - isqrt(d)) // <span class="number">2</span></span><br><span class="line">    q = <span class="built_in">int</span>(s + isqrt(d)) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> p, q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">factorize_multi_prime</span>(<span class="params">N, phi</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Recovers the prime factors from a modulus if Euler&#x27;s totient is known.</span></span><br><span class="line"><span class="string">    This method works for a modulus consisting of any number of primes, but is considerably be slower than factorize.</span></span><br><span class="line"><span class="string">    More information: Hinek M. J., Low M. K., Teske E., &quot;On Some Attacks on Multi-prime RSA&quot; (Section 3)</span></span><br><span class="line"><span class="string">    :param N: the modulus</span></span><br><span class="line"><span class="string">    :param phi: Euler&#x27;s totient, the order of the multiplicative group modulo N</span></span><br><span class="line"><span class="string">    :return: a tuple containing the prime factors</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    prime_factors = <span class="built_in">set</span>()</span><br><span class="line">    factors = [N]</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(factors) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># Element to factorize.</span></span><br><span class="line">        N = factors[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        w = randrange(<span class="number">2</span>, N - <span class="number">1</span>)</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> phi % (<span class="number">2</span> ** i) == <span class="number">0</span>:</span><br><span class="line">            sqrt_1 = <span class="built_in">pow</span>(w, phi // (<span class="number">2</span> ** i), N)</span><br><span class="line">            <span class="keyword">if</span> sqrt_1 &gt; <span class="number">1</span> <span class="keyword">and</span> sqrt_1 != N - <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># We can remove the element to factorize now, because we have a factorization.</span></span><br><span class="line">                factors = factors[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">                p = gcd(N, sqrt_1 + <span class="number">1</span>)</span><br><span class="line">                q = N // p</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> is_prime(p):</span><br><span class="line">                    prime_factors.add(p)</span><br><span class="line">                <span class="keyword">elif</span> p &gt; <span class="number">1</span>:</span><br><span class="line">                    factors.append(p)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> is_prime(q):</span><br><span class="line">                    prime_factors.add(q)</span><br><span class="line">                <span class="keyword">elif</span> q &gt; <span class="number">1</span>:</span><br><span class="line">                    factors.append(q)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Continue in the outer loop</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tuple</span>(prime_factors)</span><br><span class="line"></span><br><span class="line">n = <span class="number">8836130216343708623415307573630337110573363595188748983290313549413242332143945452914800845282478216810685733227137911630239808895196748125078747600505626165666334675100147790578546682128517668100858766784733351894480181877144793496927464058323582165412552970999921215333509253052644024478417393146000490808639363681195799826541558906527985336104761974023394438549055804234997654701266967731137282297623426318212701157416397999108259257077847307874122736921265599854976855949680133804464839768470200425669609996841568545945133611190979810786943246285103031363790663362165522662820344917056587244701635831061853354597</span></span><br><span class="line">phi = <span class="number">8836130216343708623415307573630337110573363595188748983290313549413242332143945452914800845282478216810685733227137911630239808895196748125078747600505622503351461565956106005118029537938273153581675065762015952483687057805462728186901563990429998916382820576211887477098611684072561849314986341226981300596338314989867731725668312057134075244816223120038573374383949718714549930261073576391501671722900294331289082826058292599838631513746370889828026039555245672195833927609280773258978856664434349221972568651378808050580665443131001632395175205804045958846124475183825589672204752895252723130454951830966138888560</span></span><br><span class="line">c1 = <span class="number">78327207863361017953496121356221173288422862370301396867341957979087627011991738176024643637029313969241151622985226595093079857523487726626882109114134910056673489916408854152274726721451884257677533593174371742411008169082367666168983943358876017521749198218529804830864940274185360506199116451280975188409</span></span><br><span class="line">N = <span class="number">157202814866563156513184271957553223260772141845129283711146204376449001653397810781717934720804041916333174673656579086498762693983380365527400604554663873045166444369504886603233275868192688995284322277504050322927511160583280269073338415758019142878016084536129741435221345599028001581385308324407324725353</span></span><br><span class="line">c2 = <span class="number">63355788175487221030596314921407476078592001060627033831694843409637965350474955727383434406640075122932939559532216639739294413008164038257338675094324172634789610307227365830016457714456293397466445820352804725466971828172010276387616894829328491068298742711984800900411277550023220538443014162710037992032</span></span><br><span class="line">c3 = <span class="number">9266334096866207047544089419994475379619964393206968260875878305040712629590906330073542575719856965053269812924808810766674072615270535207284077081944428011398767330973702305174973148018082513467080087706443512285098600431136743009829009567065760786940706627087366702015319792328141978938111501345426931078</span></span><br><span class="line"></span><br><span class="line">prime_list = <span class="built_in">sorted</span>(factorize_multi_prime(n,phi))</span><br><span class="line">p,q,r,s = prime_list[<span class="number">0</span>],prime_list[<span class="number">3</span>],prime_list[<span class="number">1</span>],prime_list[<span class="number">2</span>]</span><br><span class="line">d1 = gmpy2.invert(<span class="number">65537</span>,phi)</span><br><span class="line">m1 = <span class="built_in">pow</span>(c1,d1,p*q)</span><br><span class="line">flag1 = long_to_bytes(<span class="built_in">int</span>(m1))</span><br><span class="line"></span><br><span class="line">tmp = <span class="built_in">pow</span>(c2,N,N)-c3</span><br><span class="line">p1 = gcd(tmp,N)</span><br><span class="line">q1 = N // p1</span><br><span class="line">d2 = gmpy2.invert(p1,(p1-<span class="number">1</span>)*(q1-<span class="number">1</span>))		<span class="comment">#留意加密指数是p</span></span><br><span class="line">m2 = <span class="built_in">pow</span>(c2,d2,N)</span><br><span class="line">flag2 = long_to_bytes(<span class="built_in">int</span>(m2))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag1+flag2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h1 id="real-MT"><a href="#real-MT" class="headerlink" title="real_MT"></a>real_MT</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">guess_number_1</span>():</span><br><span class="line">    randoms = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">208</span>):</span><br><span class="line">        randoms.append(random.getrandbits(<span class="number">96</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;randoms = &quot;</span>+<span class="built_in">str</span>(randoms))</span><br><span class="line">    number = <span class="built_in">str</span>(random.getrandbits(<span class="number">96</span>))</span><br><span class="line">    guess = <span class="built_in">str</span>(<span class="built_in">input</span>(<span class="string">&quot;Guess after number:&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> guess != number:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Wrong Number! Guess again.&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">guess_number_2</span>():</span><br><span class="line">    number = <span class="built_in">str</span>(random.getrandbits(<span class="number">96</span>))</span><br><span class="line">    randoms = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">627</span>):</span><br><span class="line">        randoms.append(random.getrandbits(<span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;randoms = &quot;</span>+<span class="built_in">str</span>(randoms))</span><br><span class="line">    guess = <span class="built_in">str</span>(<span class="built_in">input</span>(<span class="string">&quot;Guess pre number:&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> guess != number:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Wrong Number! Guess again.&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">guess_number_3</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_int32</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="number">0xFFFFFFFF</span> &amp; x)  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">seed</span>):</span><br><span class="line">        mt = [<span class="number">0</span>] * <span class="number">624</span></span><br><span class="line">        mt[<span class="number">0</span>] = seed</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">624</span>):</span><br><span class="line">            mt[i] = _int32(<span class="number">1812433253</span> * (mt[i - <span class="number">1</span>] ^ mt[i - <span class="number">1</span>] &gt;&gt; <span class="number">30</span>) + i)</span><br><span class="line">        <span class="keyword">return</span> mt[-<span class="number">1</span>]</span><br><span class="line">    number = random.getrandbits(<span class="number">32</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;last number = &quot;</span>+ <span class="built_in">str</span>(init(number)))</span><br><span class="line">    guess = <span class="built_in">int</span>(<span class="built_in">str</span>(<span class="built_in">input</span>(<span class="string">&quot;Guess seed number:&quot;</span>)))</span><br><span class="line">    <span class="keyword">if</span> guess != number:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Wrong Number! Guess again.&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">guess_number_4</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">extract_number</span>(<span class="params">y</span>):</span><br><span class="line">        y = y ^ y &gt;&gt; <span class="number">11</span></span><br><span class="line">        y = y ^ y &lt;&lt; <span class="number">7</span> &amp; <span class="number">2636928640</span></span><br><span class="line">        y = y ^ y &lt;&lt; <span class="number">15</span> &amp; <span class="number">4022730752</span></span><br><span class="line">        y = y ^ y &gt;&gt; <span class="number">18</span></span><br><span class="line">        <span class="keyword">return</span> y&amp;<span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line">    number = random.getrandbits(<span class="number">32</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;extract number = &quot;</span>+ <span class="built_in">str</span>(extract_number(number)))</span><br><span class="line">    guess = <span class="built_in">int</span>(<span class="built_in">str</span>(<span class="built_in">input</span>(<span class="string">&quot;Guess be extracted number:&quot;</span>)))</span><br><span class="line">    <span class="keyword">if</span> guess != number:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Wrong Number! Guess again.&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Welcome to the Mersenne Twister basic challenge. Please try to solve 20 challenges in 60 seconds.&quot;</span>)</span><br><span class="line">signal.alarm(<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Round: &quot;</span>+<span class="built_in">str</span>(i+<span class="number">1</span>))</span><br><span class="line">    random.choice([guess_number_1,guess_number_2,guess_number_3,guess_number_4])()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Good job!&quot;</span>)</span><br><span class="line"></span><br><span class="line">flag = <span class="built_in">open</span>(<span class="string">&#x27;/flag&#x27;</span>).read()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Congratulations on passing the challenge. This is your flag: &quot;</span> + <span class="built_in">str</span>(flag))</span><br></pre></td></tr></table></figure>



<h1 id="fake-MT"><a href="#fake-MT" class="headerlink" title="fake_MT"></a>fake_MT</h1><h1 id="ez-polynomial"><a href="#ez-polynomial" class="headerlink" title="ez_polynomial"></a>ez_polynomial</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#sage</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">flag = list(bytearray(&#x27;&#x27;))</span><br><span class="line">p = getPrime(16)</span><br><span class="line">R.&lt;y&gt; = PolynomialRing(GF(p))</span><br><span class="line">while True:</span><br><span class="line">    P1 = R.random_element(degree=(ZZ.random_element(len(flag), 2*len(flag))))</span><br><span class="line">    Q1 = R.random_element(degree=(ZZ.random_element(len(flag), 2*len(flag))))</span><br><span class="line">    if P1.is_irreducible() and Q1.is_irreducible():</span><br><span class="line">        P = P1</span><br><span class="line">        Q = Q1</span><br><span class="line">        break</span><br><span class="line">e = 65537</span><br><span class="line">N = P*Q</span><br><span class="line">S.&lt;x&gt; = R.quotient(N)</span><br><span class="line">c = S(flag) ^ e</span><br><span class="line">print(&quot;P:&quot; + str(p) + &quot;\n&quot;)</span><br><span class="line">print(&quot;N:&quot; + str(N) + &quot;\n&quot;)</span><br><span class="line">print(&quot;C:&quot; + str(c))</span><br><span class="line"></span><br><span class="line">#P:40031</span><br><span class="line">#N:24096*y^93 + 38785*y^92 + 17489*y^91 + 9067*y^90 + 1034*y^89 + 6534*y^88 + 35818*y^87 + 22046*y^86 + 12887*y^85 + 445*y^84 + 26322*y^83 + 37045*y^82 + 4486*y^81 + 3503*y^80 + 1184*y^79 + 38471*y^78 + 8012*y^77 + 36561*y^76 + 19429*y^75 + 35227*y^74 + 10813*y^73 + 26341*y^72 + 29474*y^71 + 2059*y^70 + 16068*y^69 + 31597*y^68 + 14685*y^67 + 9266*y^66 + 31019*y^65 + 6171*y^64 + 385*y^63 + 28986*y^62 + 9912*y^61 + 10632*y^60 + 33741*y^59 + 12634*y^58 + 21179*y^57 + 35548*y^56 + 17894*y^55 + 7152*y^54 + 9440*y^53 + 4004*y^52 + 2600*y^51 + 12281*y^50 + 22*y^49 + 17314*y^48 + 32694*y^47 + 7693*y^46 + 6567*y^45 + 19897*y^44 + 27329*y^43 + 8799*y^42 + 36348*y^41 + 33963*y^40 + 23730*y^39 + 27685*y^38 + 29037*y^37 + 14622*y^36 + 29608*y^35 + 39588*y^34 + 23294*y^33 + 757*y^32 + 20140*y^31 + 19511*y^30 + 1469*y^29 + 3898*y^28 + 6630*y^27 + 19610*y^26 + 11631*y^25 + 7188*y^24 + 11683*y^23 + 35611*y^22 + 37286*y^21 + 32139*y^20 + 20296*y^19 + 36426*y^18 + 25340*y^17 + 36204*y^16 + 37787*y^15 + 31256*y^14 + 505*y^13 + 27508*y^12 + 20885*y^11 + 32037*y^10 + 31236*y^9 + 7929*y^8 + 27195*y^7 + 28980*y^6 + 11863*y^5 + 16025*y^4 + 16389*y^3 + 570*y^2 + 36547*y + 10451</span><br><span class="line">#C:3552*x^92 + 6082*x^91 + 25295*x^90 + 35988*x^89 + 26052*x^88 + 16987*x^87 + 12854*x^86 + 25117*x^85 + 25800*x^84 + 30297*x^83 + 5589*x^82 + 23233*x^81 + 14449*x^80 + 4712*x^79 + 35719*x^78 + 1696*x^77 + 35653*x^76 + 13995*x^75 + 13715*x^74 + 4578*x^73 + 37366*x^72 + 25260*x^71 + 28865*x^70 + 36120*x^69 + 7047*x^68 + 10497*x^67 + 19160*x^66 + 17939*x^65 + 14850*x^64 + 6705*x^63 + 17805*x^62 + 30083*x^61 + 2400*x^60 + 10685*x^59 + 15272*x^58 + 2225*x^57 + 13194*x^56 + 14251*x^55 + 31016*x^54 + 10189*x^53 + 35040*x^52 + 7042*x^51 + 29206*x^50 + 39363*x^49 + 32608*x^48 + 38614*x^47 + 5528*x^46 + 20119*x^45 + 13439*x^44 + 25468*x^43 + 30056*x^42 + 19720*x^41 + 21808*x^40 + 3712*x^39 + 25243*x^38 + 10606*x^37 + 16247*x^36 + 36106*x^35 + 17287*x^34 + 36276*x^33 + 1407*x^32 + 28839*x^31 + 8459*x^30 + 38863*x^29 + 435*x^28 + 913*x^27 + 36619*x^26 + 15572*x^25 + 9363*x^24 + 36837*x^23 + 17925*x^22 + 38567*x^21 + 38709*x^20 + 13582*x^19 + 35038*x^18 + 31121*x^17 + 8933*x^16 + 1666*x^15 + 21940*x^14 + 25585*x^13 + 840*x^12 + 21938*x^11 + 20143*x^10 + 28507*x^9 + 5947*x^8 + 20289*x^7 + 32196*x^6 + 924*x^5 + 370*x^4 + 14849*x^3 + 10780*x^2 + 14035*x + 15327</span><br></pre></td></tr></table></figure>



<h1 id="eZ-Bl⊕ck"><a href="#eZ-Bl⊕ck" class="headerlink" title="eZ_Bl⊕ck"></a>eZ_Bl⊕ck</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.strxor <span class="keyword">import</span> strxor <span class="keyword">as</span> xor</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">round</span>(<span class="params">s, k</span>):</span><br><span class="line">    l, r = s[:<span class="number">16</span>], s[<span class="number">16</span>:]</span><br><span class="line">    l_, r_ = xor(xor(r, k), l), l</span><br><span class="line">    <span class="keyword">return</span> l_ + r_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">s, k</span>):</span><br><span class="line">    t = s</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        t = <span class="built_in">round</span>(t, k[i])</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r = os.urandom(<span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line"></span><br><span class="line">key = [os.urandom(<span class="number">16</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(encode(r, key))</span><br><span class="line">m = flag.strip(<span class="string">b&#x27;NKCTF&#123;&#x27;</span>).strip(<span class="string">b&#x27;&#125;&#x27;</span>).replace(<span class="string">b&#x27;-&#x27;</span>, <span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(encode(m, key))</span><br><span class="line"></span><br><span class="line"><span class="comment"># b&quot;t\xf7\xaa\xac\x9d\x88\xa4\x8b\x1f+pA\x84\xacHg&#x27;\x07&#123;\xcc\x06\xc4i\xdd)\xda\xc9\xad\xa9\xe8\x1fi&quot;</span></span><br><span class="line"><span class="comment"># b&quot;&#x27;&#123;&lt;z&#125;\x91\xda\xc5\xd5S\x8b\xfa\x9f~]J\x0f\xf4\x9a\x1e\xe0\xef\x129N\xe7a\x928+\xe0\xee&quot;</span></span><br><span class="line"><span class="comment"># b&#x27;8\x1f&quot;\x83B4\x86)\xce\xebq3\x06\xa0w\x16U\x04M/w\xa1\x8f;)M\xdd~\x11:\xe3\xb3&#x27;</span></span><br></pre></td></tr></table></figure>

<p>手动推导了一下</p>
<p>前一半：$iv[:16]$，后一半：$iv[16:]$</p>
<p>round1</p>
<p>前一半：$iv[16:]\otimes key1 \otimes iv[:16]$，后一半：$iv[:16]$</p>
<p>round2</p>
<p>前一半：$key1 \otimes key2 \otimes iv[:16]$，后一半：$iv[16:]\otimes key1 \otimes iv[:16]$</p>
<p>round3</p>
<p>前一半：$iv[:16]  \otimes key3 \otimes key2 $，后一半： $key1 \otimes key2 \otimes iv[16:]$ </p>
<p>round4</p>
<p>前一半：$key1 \otimes iv[16:] \otimes iv[:16] \otimes key3 \otimes key4$，后一半：$iv[:16]  \otimes key3 \otimes key2 $</p>
<p>round5</p>
<p>前一半：$key1 \otimes iv[16:] \otimes key2 \otimes key4 \otimes key5$，后一半：$key1 \otimes iv[16:] \otimes iv[:16] \otimes key3 \otimes key4$</p>
<p>round6</p>
<p>前一半：$iv[:16] \otimes key2 \otimes key3 \otimes key5\otimes key6$，后一半：$key1 \otimes  key2 \otimes key4 \otimes key5 \otimes iv[:16]$</p>
<p>round7</p>
<p>前一半：$iv[16:] \otimes iv[:16] \otimes key1 \otimes key3 \otimes key4 \otimes key6 \otimes  key7$，后一半：$iv[:16] \otimes key2 \otimes key3 \otimes key5\otimes key6$</p>
<p>round8</p>
<p>前一半：$key1 \otimes key2 \otimes key4 \otimes key5 \otimes key7 \otimes key8 \otimes iv[16:]$，后一半$iv[16:] \otimes iv[:16] \otimes key1 \otimes key3 \otimes key4 \otimes key6 \otimes  key7$</p>
<p><strong>把r或者m加密后在格式上有相同点。</strong></p>
<p>设$flag$和$r$分为两部分$flag1,flag2,r1,r2$</p>
<p>我们把两个密文的前半部分进行异或能得到$flag2\otimes r2$，已知$r2$，可以恢复$flag2$</p>
<p>把密文的后半部分进行异或能得到$flag1 \otimes r1 \otimes flag2 \otimes r2$，上面已经恢复了$flag2$，所以我们也能恢复$flag1$</p>
<p>最后把$flag$拼接再改为uuid形式</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.strxor <span class="keyword">import</span> strxor</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line">r = <span class="string">b&quot;t\xf7\xaa\xac\x9d\x88\xa4\x8b\x1f+pA\x84\xacHg&#x27;\x07&#123;\xcc\x06\xc4i\xdd)\xda\xc9\xad\xa9\xe8\x1fi&quot;</span></span><br><span class="line">cr = <span class="string">b&quot;&#x27;&#123;&lt;z&#125;\x91\xda\xc5\xd5S\x8b\xfa\x9f~]J\x0f\xf4\x9a\x1e\xe0\xef\x129N\xe7a\x928+\xe0\xee&quot;</span></span><br><span class="line">cm = <span class="string">b&#x27;8\x1f&quot;\x83B4\x86)\xce\xebq3\x06\xa0w\x16U\x04M/w\xa1\x8f;)M\xdd~\x11:\xe3\xb3&#x27;</span></span><br><span class="line"></span><br><span class="line">r1 = r[:<span class="number">16</span>]</span><br><span class="line">r2 = r[<span class="number">16</span>:]</span><br><span class="line"></span><br><span class="line">flag2 = strxor(strxor(cr[:<span class="number">16</span>],cm[:<span class="number">16</span>]),r2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag2)</span><br><span class="line"></span><br><span class="line">flag1 = strxor(strxor(strxor(strxor(cr[<span class="number">16</span>:],cm[<span class="number">16</span>:]),r1),r2),flag2)</span><br><span class="line"><span class="built_in">print</span>(flag1)</span><br><span class="line"></span><br><span class="line">flag = flag1+flag2					<span class="comment">#得到的flag是byte型</span></span><br><span class="line"><span class="built_in">print</span>(uuid.UUID(flag.decode()))		<span class="comment">#把byte转str再转uuid</span></span><br></pre></td></tr></table></figure>

<h1 id="eazy-high"><a href="#eazy-high" class="headerlink" title="eazy_high"></a>eazy_high</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">p, q = getPrime(<span class="number">1024</span>), getPrime(<span class="number">1024</span>)</span><br><span class="line">N = p * q</span><br><span class="line">p0 = p ^ (bytes_to_long(flag)&lt;&lt;<span class="number">444</span>)</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = <span class="built_in">pow</span>(m, <span class="number">65537</span>, N)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c=&#x27;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;N=&#x27;</span>,N)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;p0=&#x27;</span>,p0)</span><br><span class="line"></span><br><span class="line"><span class="comment">#c= 4881545863615247924697512170011400857004555681758106351259776881249360423774694437921554056529064037535796844084045263140567168171628832384672612945806728465127954937293787045302307135365408938448006548465000663247116917564500525499976139556325841597810084111303039525833367199565266613007333465332710833102978756654324956219855687611590278570749890543277201538208370370097424105751568285050703167350889953331829275262932104042040526209179357770495596739361176548337593674366015027648541293309465113202672923556991818236011769228078267484362980348613669012975963468592763463397575879215173972436831753615524193609612</span></span><br><span class="line"><span class="comment">#N= 17192509201635459965397076685948071839556595198733884616568925970608227408244870123644193452116734188924766414178232653941867668088060274364830452998991993756231372252367134508712447410029668020439498980619263308413952840568602285764163331028384281840387206878673090608323292785024372223569438874557728414737773416206032540038861064700108597448191546413236875600906013508022023794395360001242071569785940215873854748631691555516626235191098174739613181230094797844414203694879874212340812119576042962565179579136753839946922829803044355134086779223242080575811804564731938746051591474236147749401914216734714709281349</span></span><br><span class="line"><span class="comment">#p0= 149263925308155304734002881595820602641174737629551638146384199378753884153459661375931646716325020758837194837271581361322079811468970876532640273110966545339040194118880506352109559900553776706613338890047890747811129988585025948270181264314668772556874718178868209009192010129918138140332707080927643141811</span></span><br></pre></td></tr></table></figure>

<p>$p &#x3D; 1024bit$，$m$经过左移$444$位之后，$m$的低$444$位全是0，猜测$flag$的长度为$40$字节，则$m$经过左移后的大小为$764bit$左右。</p>
<p>所以$p$的高$260$位是不受异或影响的，则$p$的$260$位就是$p0$的高$260$位，我们有了$p$的高$260$位和低$444$位，可以用coppersmith恢复p</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">c= <span class="number">4881545863615247924697512170011400857004555681758106351259776881249360423774694437921554056529064037535796844084045263140567168171628832384672612945806728465127954937293787045302307135365408938448006548465000663247116917564500525499976139556325841597810084111303039525833367199565266613007333465332710833102978756654324956219855687611590278570749890543277201538208370370097424105751568285050703167350889953331829275262932104042040526209179357770495596739361176548337593674366015027648541293309465113202672923556991818236011769228078267484362980348613669012975963468592763463397575879215173972436831753615524193609612</span></span><br><span class="line">N= <span class="number">17192509201635459965397076685948071839556595198733884616568925970608227408244870123644193452116734188924766414178232653941867668088060274364830452998991993756231372252367134508712447410029668020439498980619263308413952840568602285764163331028384281840387206878673090608323292785024372223569438874557728414737773416206032540038861064700108597448191546413236875600906013508022023794395360001242071569785940215873854748631691555516626235191098174739613181230094797844414203694879874212340812119576042962565179579136753839946922829803044355134086779223242080575811804564731938746051591474236147749401914216734714709281349</span></span><br><span class="line">p0= <span class="number">149263925308155304734002881595820602641174737629551638146384199378753884153459661375931646716325020758837194837271581361322079811468970876532640273110966545339040194118880506352109559900553776706613338890047890747811129988585025948270181264314668772556874718178868209009192010129918138140332707080927643141811</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">phigh = p0 &gt;&gt; <span class="number">764</span> &lt;&lt; <span class="number">764</span></span><br><span class="line">plow = p0 % <span class="number">2</span>**<span class="number">445</span></span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(N))</span><br><span class="line"></span><br><span class="line">f = phigh + x*<span class="number">2</span>**<span class="number">444</span> + plow</span><br><span class="line">f = f.monic()</span><br><span class="line">x = f.small_roots(X=<span class="number">2</span>^<span class="number">320</span>,beta=<span class="number">0.4</span>)</span><br><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    p = phigh + <span class="built_in">int</span>(x[<span class="number">0</span>])*<span class="number">2</span>**<span class="number">444</span> + plow</span><br><span class="line">    q = N // p</span><br><span class="line">    d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">    m = <span class="built_in">pow</span>(c,d,N)</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br></pre></td></tr></table></figure>



<h1 id="eZ-LargeCG"><a href="#eZ-LargeCG" class="headerlink" title="eZ_LargeCG"></a>eZ_LargeCG</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from gmpy2 import next_prime</span><br><span class="line">from Crypto.Util.number import getPrime, isPrime, bytes_to_long</span><br><span class="line">import random</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">def init():</span><br><span class="line">    primes = []</span><br><span class="line">    p = 1</span><br><span class="line">    while len(primes) &lt; 100:</span><br><span class="line">        p = next_prime(p)</span><br><span class="line">        primes.append(int(p))</span><br><span class="line">    return primes</span><br><span class="line"></span><br><span class="line">def genMyPrimeA(bits):</span><br><span class="line">    while True:</span><br><span class="line">        g = 2</span><br><span class="line">        while g &lt; 2 ** bits:</span><br><span class="line">            g *= random.choice(primes)</span><br><span class="line">        g += 1</span><br><span class="line">        if isPrime(g):</span><br><span class="line">            return g</span><br><span class="line"></span><br><span class="line">def genMyPrimeB(bits):</span><br><span class="line">    while True:</span><br><span class="line">        g = 2</span><br><span class="line">        while g &lt; 2 ** bits:</span><br><span class="line">            g *= random.choice(primes)</span><br><span class="line">        g -= 1</span><br><span class="line">        if isPrime(g):</span><br><span class="line">            return g</span><br><span class="line"></span><br><span class="line">def gen(st, n, a, b, c, d):</span><br><span class="line">    A = [st + 2023, st + 2024, st + 2025]</span><br><span class="line">    for i in range(6**666):</span><br><span class="line">        A.append((a * A[-3] + b * A[-2] + c * A[-1] + d) % n)</span><br><span class="line">    return A</span><br><span class="line"></span><br><span class="line">primes = init()</span><br><span class="line">p1 = getPrime(256)</span><br><span class="line">print(p1)</span><br><span class="line">q1 = 1</span><br><span class="line">while p1 &gt; q1:</span><br><span class="line">    q1 = genMyPrimeA(256)</span><br><span class="line">print(q1)</span><br><span class="line">p2 = getPrime(256)</span><br><span class="line">q2 = 1</span><br><span class="line">while p2 &gt; q2:</span><br><span class="line">    q2 = genMyPrimeB(256)</span><br><span class="line">n1 = p1 * q1</span><br><span class="line">n2 = p2 * q2</span><br><span class="line">print(f&#x27;n1 = &#123;n1&#125;&#x27;)</span><br><span class="line">print(f&#x27;n2 = &#123;n2&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">r = getPrime(512)</span><br><span class="line">print(f&#x27;r = &#123;r&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">A = gen(bytes_to_long(flag), r, p1, q1, p2, q2)</span><br><span class="line">print(f&#x27;A[-3] = &#123;A[-3]&#125;&#x27;)</span><br><span class="line">print(f&#x27;A[-2] = &#123;A[-2]&#125;&#x27;)</span><br><span class="line">print(f&#x27;A[-1] = &#123;A[-1]&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># n1 = 39755206609675677517559022219519767646524455449142889144073217274247893104711318356648198334858966762944109142752432641040037415587397244438634301062818169</span><br><span class="line"># n2 = 30725253491966558227957591684441310073288683324213439179377278006583428660031769862224980605664642101191616868994066039054762100886678504154619135365646221</span><br><span class="line"># r = 7948275435515074902473978567170931671982245044864706132834233483354166398627204583162848756424199888842910697874390403881343013872330344844971750121043493</span><br><span class="line"># A[-3] = 6085327340671394838391386566774092636784105046872311226269065664501131836034666722102264842236327898770287752026397099940098916322051606027565395747098434</span><br><span class="line"># A[-2] = 1385551782355619987198268805270109182589006873371541520953112424858566073422289235930944613836387546298080386848159955053303343649615385527645536504580787</span><br><span class="line"># A[-1] = 2529291156468264643335767070801583140819639532551726975314270127875306069067016825677707064451364791677536138503947465612206191051563106705150921639560469</span><br></pre></td></tr></table></figure>



<h1 id="complex-matrix"><a href="#complex-matrix" class="headerlink" title="complex_matrix"></a>complex_matrix</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2 as gy</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">k = 400</span><br><span class="line">p, q = getPrime(741), getPrime(741)</span><br><span class="line">N = p * q</span><br><span class="line">phi = (p-1) * (q-1)</span><br><span class="line">_flag = bytes_to_long(flag)</span><br><span class="line">p, q = getPrime(1024), getPrime(1024)</span><br><span class="line">d_array = [getPrime(k) for _ in range(4)] </span><br><span class="line">e_array = [inverse(i, phi) for i in d_array]</span><br><span class="line">c = pow(_flag, 65537, N)</span><br><span class="line">print(&#x27;N:&#x27;,N)</span><br><span class="line">print(&#x27;e:&#x27;,e_array)</span><br><span class="line">print(&#x27;c:&#x27;,c)</span><br><span class="line"></span><br><span class="line">#N: 71841248095369087024928175623295380241516644434969868335504061065977014103487197287619667598363486210886674500469383623511906399909335989202774281795855975972913438448899231650449810696539722877903606541112937729384851506921675290984316325565141178015123381439392534417225128922398194700511937668809140024838070124095703585627058463137549632965723304713166804084673075651182998654091113119667582720831809458721072371364839503563819080226784026253</span><br><span class="line">#e: [65128799196671634905309494529154568614228788035735808211836905142007976099865571126946706559109393187772126407982007858423859147772762638898854472065889939549916077695303157760259717113616428849798058080633047516455513870697383339784816006154279428812359241282979297285283850338964993773227397528608557211742425548651971558377656644211835094019462699301650412862894391885325969143805924684662849869947172175608502179438901337558870349697233790535, 58756559706647121529575085912021603170286163639572075337348109911506627489265537716060463072086480156516641723700802217411122982693536541892986623158818442274840863016647800896033363360822503445344748132842451806511693779600370832206455202293028402486647422212959763287987847280322100701242139127654031151565924132562837893975505159702015125483479126108892709063135006366792197127007229210558758401679638300464111782814561428899998471531067163715, 34828685390969672139784723764579499920301439564705391196519314224159563070870933754477650614819514127121146216049444888554338415587165719098661141454627820126445291802801256297252654045398330613075575527685542980264993711077876535643646746742646371967302159565887123638001580042027272379341650995728849759541960087953160211696369079708787543303742132161742979856720539914370868829868891655221361545648778590685232034703220732697083024449894197969, 26717968456600556973167180286909817773394160817933525240720067057464671317174201540556176814203780603153696663101158205367554829261808020426363683474848952397963507069306452835776851274959389849223566030857588019845781623271395012194869024566879791449466064832273531795430185178486425688475688634844530106740480643866537205900809400383304665727460014210405339697947582657505028211149470787536144302545259243549176816653560626044921521516818788487]</span><br><span class="line">#c: 39297018404565022956251803918747154798377576057123078716166221329195959669756819453426741569480551313085435037629493881038383709458043802420338889323233368852331387845200216275712388921820794980987541224782392553528127093154957890356084331463340193478391679540506421250562554424770350351514435220782124981277580072039637811543914983033300225131364246910828188727043248991987332274929827173923543187017105236008487756190002204169623313222748976369</span><br></pre></td></tr></table></figure>



<h1 id="baby-classical"><a href="#baby-classical" class="headerlink" title="baby_classical"></a>baby_classical</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import string</span><br><span class="line">import re</span><br><span class="line">import numpy as np</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">print(&#x27;flag length:&#x27;,len(flag))</span><br><span class="line">dic = string.ascii_uppercase+string.ascii_lowercase+string.digits+&#x27;+/&#x27;</span><br><span class="line">f1nd = lambda x : dic.find(x)</span><br><span class="line">class KeyEncryption:</span><br><span class="line">    def __init__(self, m: int, fillchar: str=&quot;z&quot;, key: np.ndarray=None):</span><br><span class="line">        self.m = m</span><br><span class="line">        self.key = key</span><br><span class="line">        self.dicn2s = &#123;i: dic[i] for i in range(64)&#125;</span><br><span class="line">        self.dics2n = dict(zip(self.dicn2s.values(), self.dicn2s.keys()))</span><br><span class="line">        self.fillchar = self.dics2n[fillchar]</span><br><span class="line">    def setM(self, m: int) -&gt; None:</span><br><span class="line">        assert m &gt; 0</span><br><span class="line">        self.m = m</span><br><span class="line">    def setKey(self, key: np.ndarray=None) -&gt; None:</span><br><span class="line">        if key is None:</span><br><span class="line">            while key is None or KeyEncryption.modInv(np.linalg.det(key)) == -1:</span><br><span class="line">                key = np.random.randint(0, 65, size=(self.m, self.m))</span><br><span class="line">            print(&quot;random matrix：\n&quot;, key)</span><br><span class="line">        else:</span><br><span class="line">            assert KeyEncryption.modInv(np.linalg.det(key)) != -1</span><br><span class="line">        self.key = key</span><br><span class="line">    @staticmethod</span><br><span class="line">    def modInv(x: int):</span><br><span class="line">        y = 0</span><br><span class="line">        while y &lt; 64:</span><br><span class="line">            y += 1</span><br><span class="line">            if (x * y) % 64 == 1:</span><br><span class="line">                return y</span><br><span class="line">        return -1</span><br><span class="line">    def _loopCrypt(self, long: np.ndarray, K: np.ndarray) -&gt; np.ndarray:</span><br><span class="line">        ans = np.array([])</span><br><span class="line">        for i in range(long.shape[0] // self.m):</span><br><span class="line">            ans = np.mod(np.hstack((</span><br><span class="line">                ans, </span><br><span class="line">                np.dot(long[i*self.m:i*self.m+self.m], K)</span><br><span class="line">            )), 64)</span><br><span class="line">        return ans.astype(np.int64)</span><br><span class="line">    def encrypt(self, plaintext: np.ndarray):</span><br><span class="line">        assert self.m !=None and self.key is not None</span><br><span class="line">        if plaintext.shape[0] % self.m:</span><br><span class="line">            plaintext = np.hstack((</span><br><span class="line">                plaintext, </span><br><span class="line">                [self.fillchar] *(self.m - plaintext.shape[0] % self.m)</span><br><span class="line">            ))</span><br><span class="line">        return self._loopCrypt(plaintext, self.key)</span><br><span class="line">    def translate(self, s, to: str):</span><br><span class="line">        if to == &quot;text&quot;:</span><br><span class="line">            return &quot;&quot;.join([self.dicn2s[si] for si in s])</span><br><span class="line">        elif to == &quot;num&quot;:</span><br><span class="line">            s = s.replace(&quot; &quot;, &quot;&quot;)</span><br><span class="line">            return np.array([self.dics2n[si] for si in s])</span><br><span class="line">def getKey(key):</span><br><span class="line">  he = KeyEncryption(m=3)</span><br><span class="line">  he.setKey()              </span><br><span class="line">  nums = he.translate(key, &quot;num&quot;)</span><br><span class="line">  res = he.encrypt(nums)</span><br><span class="line">  enkey = &#x27;&#x27;.join(dic[i] for i in res.tolist())</span><br><span class="line">  print(&#x27;Encrypt key:&#x27;,enkey)</span><br><span class="line">  return enkey</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">  fir1 = &#x27; &#x27;.join(map(lambda _:_[::-1],re.split(&quot;[ &#123; _ &#125; ]&quot; , flag.swapcase())))</span><br><span class="line">  ciphertext1 = &#x27;&#x27;</span><br><span class="line">  key = &quot;&quot;  </span><br><span class="line">  enkey = getKey(key)</span><br><span class="line">  _enkey=[f1nd(i) for i in key]</span><br><span class="line">  print(&#x27;key lengeh:&#x27;,len(_enkey))</span><br><span class="line">  j = 0</span><br><span class="line">  for i in fir1:</span><br><span class="line">    if f1nd(i)&gt;=0:</span><br><span class="line">      ciphertext1 += dic[(f1nd(i) + _enkey[j % len(_enkey)])%64]</span><br><span class="line">    else:</span><br><span class="line">      ciphertext1 += i</span><br><span class="line">    j += 1</span><br><span class="line">  ciphertext = ciphertext1.replace(&#x27; &#x27;,&#x27;_&#x27;)</span><br><span class="line">  print(&#x27;ciphertext:%s&#123;%s&#125;&#x27; % (ciphertext[0:5],ciphertext[6:-1]))</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">flag length: 48</span><br><span class="line">random matrix：</span><br><span class="line"> [[13 37 10]</span><br><span class="line"> [15 17 41]</span><br><span class="line"> [13  0 10]]</span><br><span class="line">Encrypt key: pVvRe/G08rLhfwa</span><br><span class="line">key lengeh: 14</span><br><span class="line">ciphertext:1k2Pe&#123;24seBl4_a6Ot_fp7O1_eHk_Plg3EF_g/JtIonut4/&#125;</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>



<h1 id="Raven"><a href="#Raven" class="headerlink" title="Raven"></a>Raven</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env sage</span><br><span class="line"># Problem by rec, with a bad raven.</span><br><span class="line">import os, hashlib</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line">def Raven(n: int, secret: bytes):</span><br><span class="line">    H = lambda x: hashlib.md5(os.urandom(8) + x).digest()</span><br><span class="line"></span><br><span class="line">    p = getPrime(728)</span><br><span class="line">    R.&lt;z&gt; = PolynomialRing(GF(p))</span><br><span class="line"></span><br><span class="line">    seed = H(secret)</span><br><span class="line">    f = R(</span><br><span class="line">        [bytes_to_long(secret)] + [bytes_to_long(H(seed)) for _ in range(n - 1)]</span><br><span class="line">    )</span><br><span class="line">    x = [getRandomRange(2, p - 1) for _ in range(n)]</span><br><span class="line">    y = [ZZ(f(xi)^2 + getPrime(256)) for xi in x]</span><br><span class="line"></span><br><span class="line">    pairs = list(zip(x, y))</span><br><span class="line">    return p, pairs</span><br><span class="line"></span><br><span class="line">flag = b&#x27;#####&#x27;</span><br><span class="line">key = os.urandom(16)</span><br><span class="line">cipher = AES.new(key=key, IV=bytes(range(16)), mode=AES.MODE_CBC)</span><br><span class="line">ct = cipher.encrypt(flag + os.urandom(16 - len(flag) % 16))</span><br><span class="line">p, pairs = Raven(4, key)</span><br><span class="line"></span><br><span class="line">print(f&quot;&#123;p = &#125;\n&#123;pairs = &#125;\n&#123;ct = &#125;&quot;)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">p = 1018551160851728231474335384388576586031917743463656622083024684199383855595168341728561337234276243780407755294430553694832049089534855113774546001494743212076463713621965520780122783825100696968959866614846174188401153</span><br><span class="line">pairs = [(615358616404864757405587650175842125441380884418119777842292095751090237848084440177153221092040264723889917863863854377665802549748720692225139890884830475485512763149974948701807492663962748292710803434009673589337265, 84982753624462868217739962129526665082932464631118597651920986288766037499319751354013335054886685186857222944776560264528363811382359242656883760986496856164448940929282013856762706210675691655747370624405968909408102), (528363810186974800127873139379943131424126521611531830591311656948009967709310974894584084912262479395720199930206495204352231804549705720854271566421006481173043064265399467682307971910488405265826107365679757755866812, 496810092723839642457928776423789418365006215801711874210443222720529161066621876103037104247173440072986344011599384793861949574577559989016501090247331146721371126871470611440468688947950954988175225633457347666551944), (68711183101845981499596464753252121346970486988311398916877579778110690480447199642602267233989256728822535174215153145632158860662954277116345331672194812126361911061449082917955000137698138358926301360506687271134873, 995428771589393162202488762223106955302099250561593105620410424291405842350539887383005328242236156038373244928147473800972534658018117705291472213770335998508454938607290279268848513727721410314612261163489156360908800), (61574167546312883246262193556029081771904529137922128124933785599227801608271357738142074310192454183183340219301304405636497744152219785042075198056952749425345561162612590170550454476602892138914473795478531165181812, 618169326093802548516842299173393893046765466917311052414967158839652012130855552015876657514610755108820971877570295328618373296493668146691687291894702228119875561585283226588768969944781923428807766632578060221034862)]</span><br><span class="line">ct = b&quot;|2\xf0v7\x05Y\x89\r]\xe93s\rr)#3\xe9\x90%Z\x9a\xd9\x9ck\xba\xec]q\xb8\xf2&#x27;\xc8e~fL\xcf\x93\x00\xd6^s-\xc9\xd6M&quot;</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>



<h1 id="PsychoRandom"><a href="#PsychoRandom" class="headerlink" title="PsychoRandom"></a>PsychoRandom</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># Problem by rec, with a toy generator.</span><br><span class="line">import os, utils</span><br><span class="line"></span><br><span class="line">seed = int(os.urandom(16).hex(), 16)</span><br><span class="line">gen = utils.ToyGen(seed)</span><br><span class="line"></span><br><span class="line">sec = b&#x27;#####&#x27;</span><br><span class="line">assert b&#x27;nkctf&#x27; in sec</span><br><span class="line"></span><br><span class="line">msg = b&#x27;##MSG FROM NK: &#x27; + sec</span><br><span class="line">enc = bytes(m ^ next(gen) for m in msg).hex()</span><br><span class="line">print(enc)</span><br><span class="line"># 9c1250e1fefb6012cf74a7fd0156cd1a2817ee9381d086a1561399f5b7f519e5abf4437739fa254cd35b241375292d73aa8b8e6ff61f4977da3c68a699156e6bfbe2c38d7b08eed07e40e831c25f5327a21847bb156060228e2b</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Wp</category>
      </categories>
      <tags>
        <tag>Wp</tag>
      </tags>
  </entry>
  <entry>
    <title>巅峰极客2023——Crypto</title>
    <url>/2023/07/24/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22023/</url>
    <content><![CDATA[<p>复现巅峰极客2023密码方向赛题</p>
<span id="more"></span>

<h1 id="Simple-encryption"><a href="#Simple-encryption" class="headerlink" title="Simple_encryption"></a>Simple_encryption</h1><p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2</span><br><span class="line">import random</span><br><span class="line">import binascii</span><br><span class="line">from secret import flag</span><br><span class="line"></span><br><span class="line">p = getStrongPrime(1024)</span><br><span class="line">q = getStrongPrime(1024)</span><br><span class="line">N = p * q</span><br><span class="line">g, r1, r2 = [getRandomRange(1, N) for _ in range(3)]</span><br><span class="line">g1 = pow(g, r1 * (p - 1), N)</span><br><span class="line">g2 = pow(g, r2 * (q - 1), N)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def encrypt(m):</span><br><span class="line">    s1, s2 = [getRandomRange(1, N) for _ in range(2)]</span><br><span class="line">    c1 = (m * pow(g1, s1, N)) % N</span><br><span class="line">    c2 = (m * pow(g2, s2, N)) % N</span><br><span class="line">    print(&quot;c1=&quot;, c1)</span><br><span class="line">    print(&quot;c2=&quot;, c2)</span><br><span class="line">    return (c1, c2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = encrypt(bytes_to_long(flag[:len(flag) // 2]))</span><br><span class="line">print(&#x27;N=&#x27;, N)</span><br><span class="line">print(&#x27;g1=&#x27;, g1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pad(msg, length):</span><br><span class="line">    l = len(msg)</span><br><span class="line">    return msg + (length - l) * chr(length - l).encode(&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = getStrongPrime(1024)</span><br><span class="line">q = getStrongPrime(1024)</span><br><span class="line">assert (p != q)</span><br><span class="line">n = p * q</span><br><span class="line">e = 5</span><br><span class="line">d = inverse(e, (p - 1) * (q - 1))</span><br><span class="line">assert (e * d % (p - 1) * (q - 1))</span><br><span class="line"></span><br><span class="line">flag = pad(flag[len(flag) // 2:], 48)</span><br><span class="line">m = [int(binascii.b2a_hex(flag[i * 16:i * 16 + 16]).decode(&#x27;utf-8&#x27;), 16) for i in range(3)]</span><br><span class="line">print(&#x27;S=&#x27;, sum(m) % n)</span><br><span class="line">cnt = len(m)</span><br><span class="line">A = [(i + 128) ** 2 for i in range(cnt)]</span><br><span class="line">B = [(i + 1024) for i in range(cnt)]</span><br><span class="line">C = [(i + 512) for i in range(cnt)]</span><br><span class="line">Cs = [int(pow((A[i] * m[i] ** 2 + B[i] * m[i] + C[i]), e, n)) for i in range(cnt)]</span><br><span class="line">print(&#x27;N=&#x27;, n)</span><br><span class="line">print(&#x27;e=&#x27;, e)</span><br><span class="line">print(&#x27;Cs=&#x27;, Cs)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">c1= 19024563955839349902897822692180949371550067644378624199902067434708278125346234824900117853598997270022872667319428613147809325929092749312310446754419305096891122211944442338664613779595641268298482084259741784281927857614814220279055840825157115551456554287395502655358453270843601870807174309121367449335110327991187235786798374254470758957844690258594070043388827157981964323699747450405814713722613265012947852856714100237325256114904705539465145676960232769502207049858752573601516773952294218843901330100257234517481221811887136295727396712894842769582824157206825592614684804626241036297918244781918275524254</span><br><span class="line">c2= 11387447548457075057390997630590504043679006922775566653728699416828036980076318372839900947303061300878930517069527835771992393657157069014534366482903388936689298175411163666849237525549902527846826224853407226289495201341719277080550962118551001246017511651688883675152554449310329664415179464488725227120033786305900106544217117526923607211746947511746335071162308591288281572603417532523345271340113176743703809868369623401559713179927002634217140206608963086656140258643119596968929437114459557916757824682496866029297120246221557017875892921591955181714167913310050483382235498906247018171409256534124073270350</span><br><span class="line">N= 21831630625212912450058787218272832615084640356500740162478776482071876178684642739065105728423872548532056206845637492058465613779973193354996353323494373418215019445325632104575415991984764454753263189235376127871742444636236132111097548997063091478794422370043984009615893441148901566420508196170556189546911391716595983110030778046242014896752388438535131806524968952947016059907135882390507706966746973544598457963945671064540465259211834751973065197550500334726779434679470160463944292619173904064826217284899341554269864669620477774678605962276256707036721407638013951236957603286867871199275024050690034901963</span><br><span class="line">g1= 20303501619435729000675510820217420636246553663472832286487504757515586157679361170332171306491820918722752848685645096611030558245362578422584797889428493611704976472409942840368080016946977234874471779189922713887914075985648876516896823599078349725871578446532134614410886658001724864915073768678394238725788245439086601955497248593286832679485832319756671985505398841701463782272300202981842733576006152153012355980197830911700112001441621619417349747262257225469106511527467526286661082010163334100555372381681421874165851063816598907314117035131618062582953512203870615406642787786668571083042463072230605649134</span><br><span class="line">S= 234626762558445335519229319778735528295</span><br><span class="line">N= 28053749721930780797243137464055357921262616541619976645795810707701031602793034889886420385567169222962145128498131170577184276590698976531070900776293344109534005057067680663813430093397821366071365221453788763262381958185404224319153945950416725302184077952893435265051402645871699132910860011753502307815457636525137171681463817731190311682277171396235160056504317959832747279317829283601814707551094074778796108136141845755357784361312469124392408642823375413433759572121658646203123677327551421440655322226192031542368496829102050186550793124020718643243789525477209493783347317576783265671566724068427349961101</span><br><span class="line">e= 5</span><br><span class="line">Cs= [1693447496400753735762426750097282582203894511485112615865753001679557182840033040705025720548835476996498244081423052953952745813186793687790496086492136043098444304128963237489862776988389256298142843070384268907160020751319313970887199939345096232529143204442168808703063568295924663998456534264361495136412078324133263733409362366768460625508816378362979251599475109499727808021609000751360638976, 2240772849203381534975484679127982642973364801722576637731411892969654368457130801503103210570803728830063876118483596474389109772469014349453490395147031665061733965097301661933389406031214242680246638201663845183194937353509302694926811282026475913703306789097162693368337210584494881249909346643289510493724709324540062077619696056842225526183938442535866325407085768724148771697260859350213678910949, 5082341111246153817896279104775187112534431783418388292800705085458704665057344175657566751627976149342406406594179073777431676597641200321859622633948317181914562670909686170531929552301852027606377778515019377168677204310642500744387041601260593120417053741977533047412729373182842984761689443959266049421034949822673159561609487404082536872314636928727833394518122974630386280495027169465342976]</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>flag分成了两段进行加密</p>
<h2 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h2><p>$$<br>\because g_1 \equiv g^{r_1(p-1)} \mod N<br>$$</p>
<p>$$<br>\therefore g_1 &#x3D; g^{r_1(p-1)}+kN<br>$$</p>
<p>$$<br>两边同模p得：<br>$$</p>
<p>$$<br>g_1 \equiv g^{r_1(p-1)} \mod p<br>$$</p>
<p>$$<br>由费马定理得:<br>$$</p>
<p>$$<br>g_1 \equiv 1 \mod p<br>$$</p>
<p>$$<br>\therefore kp &#x3D; g_1 - 1<br>$$</p>
<p><strong>通过kp和N求出p,q</strong><br>$$<br>又\because c_1 \equiv m×(g_1^{s_1} \mod N) \mod N<br>$$</p>
<p>$$<br>\therefore c_1 &#x3D; (m×(g_1^{s_1} + k_1N))+k_2N<br>$$</p>
<p>$$<br>\therefore c_1 &#x3D; mg_1^{s_1}+k_1mN + k_2N<br>$$</p>
<p>$$<br>两边同模p得:<br>$$</p>
<p>$$<br>c_1 \equiv mg_1^{s_1} \mod p<br>$$</p>
<p>$$<br>即c_1 \equiv (m \mod p)×(g_1^{s_1} \mod p) \mod p<br>$$</p>
<p>$$<br>又\because 1 \equiv g_1^{s_1} \mod p<br>$$</p>
<p>$$<br>\therefore c_1 \equiv m \mod p<br>$$</p>
<h2 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h2><p>解方程就行<br>$$<br>\because (A_im_i^2+B_im_i+C)^5 \equiv Cs_i \mod n<br>$$<br>$$<br>先对Cs_i开根号后<br>$$</p>
<p>$$<br>分别解3个方程:<br>$$</p>
<p>$$<br>A_ix^2+B_ix+C &#x3D; tep<br>$$</p>
<p>$$<br>其中tmp &#x3D; Cs_i^{\frac{1}{5}}<br>$$</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> symbols,solve</span><br><span class="line"></span><br><span class="line">c1= <span class="number">19024563955839349902897822692180949371550067644378624199902067434708278125346234824900117853598997270022872667319428613147809325929092749312310446754419305096891122211944442338664613779595641268298482084259741784281927857614814220279055840825157115551456554287395502655358453270843601870807174309121367449335110327991187235786798374254470758957844690258594070043388827157981964323699747450405814713722613265012947852856714100237325256114904705539465145676960232769502207049858752573601516773952294218843901330100257234517481221811887136295727396712894842769582824157206825592614684804626241036297918244781918275524254</span></span><br><span class="line">c2= <span class="number">11387447548457075057390997630590504043679006922775566653728699416828036980076318372839900947303061300878930517069527835771992393657157069014534366482903388936689298175411163666849237525549902527846826224853407226289495201341719277080550962118551001246017511651688883675152554449310329664415179464488725227120033786305900106544217117526923607211746947511746335071162308591288281572603417532523345271340113176743703809868369623401559713179927002634217140206608963086656140258643119596968929437114459557916757824682496866029297120246221557017875892921591955181714167913310050483382235498906247018171409256534124073270350</span></span><br><span class="line">N= <span class="number">21831630625212912450058787218272832615084640356500740162478776482071876178684642739065105728423872548532056206845637492058465613779973193354996353323494373418215019445325632104575415991984764454753263189235376127871742444636236132111097548997063091478794422370043984009615893441148901566420508196170556189546911391716595983110030778046242014896752388438535131806524968952947016059907135882390507706966746973544598457963945671064540465259211834751973065197550500334726779434679470160463944292619173904064826217284899341554269864669620477774678605962276256707036721407638013951236957603286867871199275024050690034901963</span></span><br><span class="line">g1= <span class="number">20303501619435729000675510820217420636246553663472832286487504757515586157679361170332171306491820918722752848685645096611030558245362578422584797889428493611704976472409942840368080016946977234874471779189922713887914075985648876516896823599078349725871578446532134614410886658001724864915073768678394238725788245439086601955497248593286832679485832319756671985505398841701463782272300202981842733576006152153012355980197830911700112001441621619417349747262257225469106511527467526286661082010163334100555372381681421874165851063816598907314117035131618062582953512203870615406642787786668571083042463072230605649134</span></span><br><span class="line"></span><br><span class="line">p = gmpy2.gcd(g1-<span class="number">1</span>,N)</span><br><span class="line">q = N // p </span><br><span class="line">m = c1 % p</span><br><span class="line">flag = long_to_bytes(m)</span><br><span class="line"><span class="comment">#print(long_to_bytes(m))</span></span><br><span class="line"></span><br><span class="line">N= <span class="number">28053749721930780797243137464055357921262616541619976645795810707701031602793034889886420385567169222962145128498131170577184276590698976531070900776293344109534005057067680663813430093397821366071365221453788763262381958185404224319153945950416725302184077952893435265051402645871699132910860011753502307815457636525137171681463817731190311682277171396235160056504317959832747279317829283601814707551094074778796108136141845755357784361312469124392408642823375413433759572121658646203123677327551421440655322226192031542368496829102050186550793124020718643243789525477209493783347317576783265671566724068427349961101</span></span><br><span class="line">e= <span class="number">5</span></span><br><span class="line">Cs= [<span class="number">1693447496400753735762426750097282582203894511485112615865753001679557182840033040705025720548835476996498244081423052953952745813186793687790496086492136043098444304128963237489862776988389256298142843070384268907160020751319313970887199939345096232529143204442168808703063568295924663998456534264361495136412078324133263733409362366768460625508816378362979251599475109499727808021609000751360638976</span>, <span class="number">2240772849203381534975484679127982642973364801722576637731411892969654368457130801503103210570803728830063876118483596474389109772469014349453490395147031665061733965097301661933389406031214242680246638201663845183194937353509302694926811282026475913703306789097162693368337210584494881249909346643289510493724709324540062077619696056842225526183938442535866325407085768724148771697260859350213678910949</span>, <span class="number">5082341111246153817896279104775187112534431783418388292800705085458704665057344175657566751627976149342406406594179073777431676597641200321859622633948317181914562670909686170531929552301852027606377778515019377168677204310642500744387041601260593120417053741977533047412729373182842984761689443959266049421034949822673159561609487404082536872314636928727833394518122974630386280495027169465342976</span>]</span><br><span class="line">A = [(i + <span class="number">128</span>) ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">B = [(i + <span class="number">1024</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">C = [(i + <span class="number">512</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">tmp = [gmpy2.iroot(i,<span class="number">5</span>)[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> Cs]</span><br><span class="line"></span><br><span class="line">x1 = symbols(<span class="string">&#x27;x1&#x27;</span>)</span><br><span class="line">x2 = symbols(<span class="string">&#x27;x2&#x27;</span>)</span><br><span class="line">x3 = symbols(<span class="string">&#x27;x3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eq1 = A[<span class="number">0</span>]*x1**<span class="number">2</span> + B[<span class="number">0</span>]*x1 + C[<span class="number">0</span>]-tmp[<span class="number">0</span>]</span><br><span class="line">eq2 = A[<span class="number">1</span>]*x2**<span class="number">2</span> + B[<span class="number">1</span>]*x2 + C[<span class="number">1</span>]-tmp[<span class="number">1</span>]</span><br><span class="line">eq3 = A[<span class="number">2</span>]*x3**<span class="number">2</span> + B[<span class="number">2</span>]*x3 + C[<span class="number">2</span>]-tmp[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">x1 = solve(eq1,x1)</span><br><span class="line">x2 = solve(eq2,x2)</span><br><span class="line">x3 = solve(eq3,x3)</span><br><span class="line"><span class="comment">#print(x1,x2,x3,sep=&#x27;\n&#x27;)</span></span><br><span class="line">flag = flag +long_to_bytes(x1[<span class="number">1</span>]) + long_to_bytes(x2[<span class="number">1</span>]) + long_to_bytes(x3[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>



<p>sagemath:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">import libnum</span><br><span class="line"></span><br><span class="line">c1= 19024563955839349902897822692180949371550067644378624199902067434708278125346234824900117853598997270022872667319428613147809325929092749312310446754419305096891122211944442338664613779595641268298482084259741784281927857614814220279055840825157115551456554287395502655358453270843601870807174309121367449335110327991187235786798374254470758957844690258594070043388827157981964323699747450405814713722613265012947852856714100237325256114904705539465145676960232769502207049858752573601516773952294218843901330100257234517481221811887136295727396712894842769582824157206825592614684804626241036297918244781918275524254</span><br><span class="line">c2= 11387447548457075057390997630590504043679006922775566653728699416828036980076318372839900947303061300878930517069527835771992393657157069014534366482903388936689298175411163666849237525549902527846826224853407226289495201341719277080550962118551001246017511651688883675152554449310329664415179464488725227120033786305900106544217117526923607211746947511746335071162308591288281572603417532523345271340113176743703809868369623401559713179927002634217140206608963086656140258643119596968929437114459557916757824682496866029297120246221557017875892921591955181714167913310050483382235498906247018171409256534124073270350</span><br><span class="line">N= 21831630625212912450058787218272832615084640356500740162478776482071876178684642739065105728423872548532056206845637492058465613779973193354996353323494373418215019445325632104575415991984764454753263189235376127871742444636236132111097548997063091478794422370043984009615893441148901566420508196170556189546911391716595983110030778046242014896752388438535131806524968952947016059907135882390507706966746973544598457963945671064540465259211834751973065197550500334726779434679470160463944292619173904064826217284899341554269864669620477774678605962276256707036721407638013951236957603286867871199275024050690034901963</span><br><span class="line">g1= 20303501619435729000675510820217420636246553663472832286487504757515586157679361170332171306491820918722752848685645096611030558245362578422584797889428493611704976472409942840368080016946977234874471779189922713887914075985648876516896823599078349725871578446532134614410886658001724864915073768678394238725788245439086601955497248593286832679485832319756671985505398841701463782272300202981842733576006152153012355980197830911700112001441621619417349747262257225469106511527467526286661082010163334100555372381681421874165851063816598907314117035131618062582953512203870615406642787786668571083042463072230605649134</span><br><span class="line"></span><br><span class="line">p = gmpy2.gcd(g1-1,N)</span><br><span class="line">m = c1 % p</span><br><span class="line">flag = libnum.n2s(int(m))</span><br><span class="line"># print(flag)</span><br><span class="line"></span><br><span class="line">S= 234626762558445335519229319778735528295</span><br><span class="line">n= 28053749721930780797243137464055357921262616541619976645795810707701031602793034889886420385567169222962145128498131170577184276590698976531070900776293344109534005057067680663813430093397821366071365221453788763262381958185404224319153945950416725302184077952893435265051402645871699132910860011753502307815457636525137171681463817731190311682277171396235160056504317959832747279317829283601814707551094074778796108136141845755357784361312469124392408642823375413433759572121658646203123677327551421440655322226192031542368496829102050186550793124020718643243789525477209493783347317576783265671566724068427349961101</span><br><span class="line">e= 5</span><br><span class="line">Cs= [1693447496400753735762426750097282582203894511485112615865753001679557182840033040705025720548835476996498244081423052953952745813186793687790496086492136043098444304128963237489862776988389256298142843070384268907160020751319313970887199939345096232529143204442168808703063568295924663998456534264361495136412078324133263733409362366768460625508816378362979251599475109499727808021609000751360638976, 2240772849203381534975484679127982642973364801722576637731411892969654368457130801503103210570803728830063876118483596474389109772469014349453490395147031665061733965097301661933389406031214242680246638201663845183194937353509302694926811282026475913703306789097162693368337210584494881249909346643289510493724709324540062077619696056842225526183938442535866325407085768724148771697260859350213678910949, 5082341111246153817896279104775187112534431783418388292800705085458704665057344175657566751627976149342406406594179073777431676597641200321859622633948317181914562670909686170531929552301852027606377778515019377168677204310642500744387041601260593120417053741977533047412729373182842984761689443959266049421034949822673159561609487404082536872314636928727833394518122974630386280495027169465342976]</span><br><span class="line"></span><br><span class="line">A = [(i + 128) ** 2 for i in range(3)]</span><br><span class="line">B = [(i + 1024) for i in range(3)]</span><br><span class="line">C = [(i + 512) for i in range(3)]</span><br><span class="line">tmp = [int(gmpy2.iroot(i,5)[0]) for i in Cs]</span><br><span class="line"></span><br><span class="line">R.&lt;x1&gt; = Zmod()[]</span><br><span class="line">R.&lt;x2&gt; = Zmod()[]</span><br><span class="line">R.&lt;x3&gt; = Zmod()[]</span><br><span class="line"></span><br><span class="line">f1 = A[0]*x1**2 + B[0]*x1 + C[0]-tmp[0]</span><br><span class="line">f2 = A[1]*x2**2 + B[1]*x2 + C[1]-tmp[1]</span><br><span class="line">f3 = A[2]*x3**2 + B[2]*x3 + C[2]-tmp[2]</span><br><span class="line"></span><br><span class="line">x1 = f1.roots()</span><br><span class="line">x2 = f2.roots()</span><br><span class="line">x3 = f3.roots()</span><br><span class="line"></span><br><span class="line">flag = flag + libnum.n2s(int(x1[0][0])) + libnum.n2s(int(x2[0][0])) + libnum.n2s(int(x3[0][0]))</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>



<h1 id="数学但高中"><a href="#数学但高中" class="headerlink" title="数学但高中"></a>数学但高中</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x=4&#123;0&lt;y&lt;6&#125;</span><br><span class="line"></span><br><span class="line">y=4&#123;2&lt;x&lt;6,17&lt;x&lt;18,28&lt;x&lt;30,41&lt;x&lt;42&#125;</span><br><span class="line"></span><br><span class="line">y=6&#123;4&lt;x&lt;6,15&lt;x&lt;16,17&lt;x&lt;19,41&lt;x&lt;43,50&lt;x&lt;51&#125;</span><br><span class="line"></span><br><span class="line">x=7&#123;0&lt;y&lt;6&#125;</span><br><span class="line"></span><br><span class="line">(x-9)^2+(y-3)^2=1</span><br><span class="line"></span><br><span class="line">x=10&#123;2&lt;y&lt;3&#125;</span><br><span class="line"></span><br><span class="line">(x-12)^2+(y-3)^2=1</span><br><span class="line"></span><br><span class="line">x=13&#123;0&lt;y&lt;3&#125;</span><br><span class="line"></span><br><span class="line">y=0&#123;11&lt;x&lt;13,15&lt;x&lt;16,50&lt;x&lt;51&#125;</span><br><span class="line"></span><br><span class="line">y=-x+17&#123;14&lt;x&lt;15&#125;</span><br><span class="line"></span><br><span class="line">y=x-11&#123;14&lt;x&lt;15&#125;</span><br><span class="line"></span><br><span class="line">x=15&#123;0&lt;y&lt;2,4&lt;y&lt;6&#125;</span><br><span class="line"></span><br><span class="line">x=17&#123;1&lt;y&lt;6&#125;</span><br><span class="line"></span><br><span class="line">x=19&#123;3&lt;y&lt;4&#125;</span><br><span class="line"></span><br><span class="line">x=21&#123;3&lt;y&lt;4&#125;</span><br><span class="line"></span><br><span class="line">(x-20)^2+(y-3)^2=1&#123;2&lt;y&lt;3&#125;</span><br><span class="line"></span><br><span class="line">(x-23)^2+(y-3)^2=1&#123;3&lt;y&lt;4&#125;</span><br><span class="line"></span><br><span class="line">x=22&#123;2&lt;y&lt;3&#125;</span><br><span class="line"></span><br><span class="line">x=24&#123;2&lt;y&lt;3&#125;</span><br><span class="line"></span><br><span class="line">(x-26)^2+(y-3)^2=1&#123;25&lt;x&lt;26&#125;</span><br><span class="line"></span><br><span class="line">y=0.5x-11&#123;26&lt;x&lt;27&#125;</span><br><span class="line"></span><br><span class="line">y=-0.5x+17&#123;26&lt;x&lt;27&#125;</span><br><span class="line"></span><br><span class="line">y=2&#123;29&lt;x&lt;30,31&lt;x&lt;33,39&lt;x&lt;40&#125;</span><br><span class="line"></span><br><span class="line">x=29&#123;2&lt;y&lt;5&#125;</span><br><span class="line"></span><br><span class="line">x=32&#123;2&lt;y&lt;5&#125;</span><br><span class="line"></span><br><span class="line">y=x-27&#123;31&lt;x&lt;32&#125;</span><br><span class="line"></span><br><span class="line">(x-34)^2+((y-3.5)^2)/(1.5^2)=1</span><br><span class="line"></span><br><span class="line">x=36&#123;2&lt;y&lt;3&#125;</span><br><span class="line"></span><br><span class="line">(x-37)^2+(y-3)^2=1&#123;3&lt;y&lt;4&#125;</span><br><span class="line"></span><br><span class="line">x=38&#123;2&lt;y&lt;3&#125;</span><br><span class="line"></span><br><span class="line">x=41&#123;2&lt;y&lt;6&#125;</span><br><span class="line"></span><br><span class="line">x=44&#123;3&lt;y&lt;4&#125;</span><br><span class="line"></span><br><span class="line">(x-45)^2+(y-3)^2=1&#123;2&lt;y&lt;3&#125;</span><br><span class="line"></span><br><span class="line">x=46&#123;3&lt;y&lt;4&#125;</span><br><span class="line"></span><br><span class="line">x=47&#123;2&lt;y&lt;3&#125;</span><br><span class="line"></span><br><span class="line">(x-48)^2+(y-3)^2=1&#123;3&lt;y&lt;4&#125;</span><br><span class="line"></span><br><span class="line">x=49&#123;2&lt;y&lt;3&#125;</span><br><span class="line"></span><br><span class="line">x=51&#123;0&lt;y&lt;2,4&lt;y&lt;6&#125;</span><br><span class="line"></span><br><span class="line">y=x-49&#123;51&lt;x&lt;52&#125;</span><br><span class="line"></span><br><span class="line">y=-x+55&#123;51&lt;x&lt;52&#125;</span><br></pre></td></tr></table></figure>

<p><strong>网站画图</strong></p>
<p><a href="https://www.desmos.com/calculator?lang=zh-CN">图形计算器 (desmos.com)</a></p>
<p><img src="/../../images/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22023/0.png"></p>
<p><code>flag&#123;Funct10n_Fun&#125;</code></p>
<h1 id="Rosita"><a href="#Rosita" class="headerlink" title="Rosita"></a>Rosita</h1><p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Problem by rec, without any sleep at all.</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long <span class="keyword">as</span> b2l</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> urandom</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> p, a, b, flag</span><br><span class="line"></span><br><span class="line">ECC = EllipticCurve(GF(p), [a, b])</span><br><span class="line">R, E, C = [ECC.random_point() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line">pad = <span class="keyword">lambda</span> m: urandom(<span class="number">8</span>) + m + <span class="string">b&#x27;\x00&#x27;</span> * (ZZ(p).nbits() // <span class="number">8</span> - <span class="built_in">len</span>(m) - <span class="number">8</span> - <span class="number">1</span>)</span><br><span class="line">out = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag)):</span><br><span class="line">    m = pad(<span class="built_in">chr</span>(flag[i]).encode())</span><br><span class="line">    nonce = urandom(<span class="number">16</span>)</span><br><span class="line">    sh = sha256(nonce + m).digest()</span><br><span class="line">    </span><br><span class="line">    Q = b2l(m)*R + b2l(nonce)*E + b2l(sh)*C</span><br><span class="line">    out.append(Q.xy())</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;out.tuo&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="built_in">str</span>(out))</span><br></pre></td></tr></table></figure>

<p>本题椭圆曲线的参数$p,a,b$全部没有给出，$R,E,C$是椭圆曲线上的点，$pad$是一种填充方式</p>
<p>$m$是$flag$经过$pad$填充后的，$nonce$是16字节的字符串，$sh$是$sha256(nonce+m)$</p>
<p>之后把$m,nonce,sh$全部转为数值，产生$Q点$</p>
<p>我们唯一拿到的就是一系列$Q点$</p>
<h2 id="First"><a href="#First" class="headerlink" title="First"></a>First</h2><p>先通过$Q$点恢复椭圆曲线的参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import GCD,isPrime</span><br><span class="line">def recover_para(Q):</span><br><span class="line"> x1,y1 = Q[0]</span><br><span class="line"> x2,y2 = Q[1]</span><br><span class="line"> x3,y3 = Q[2]</span><br><span class="line"> x4,y4 = Q[3]</span><br><span class="line"> t12_13 = ((y1**2 - x1**3)-(y2**2 - x2**3)) * (x1-x3)</span><br><span class="line"> t13_12 = ((y1**2 - x1**3)-(y3**2 - x3**3)) * (x1-x2)</span><br><span class="line"> k1p = t12_13-t13_12</span><br><span class="line"></span><br><span class="line"> t12_14 = ((y1**2 - x1**3)-(y2**2 - x2**3)) * (x1-x4)</span><br><span class="line"> t14_12 = ((y1**2 - x1**3)-(y4**2 - x4**3)) * (x1-x2)</span><br><span class="line"> k2p = t12_14-t14_12</span><br><span class="line"></span><br><span class="line"> p = factor(GCD(k1p,k2p))[-1][0]</span><br><span class="line"> assert isPrime(int(p))</span><br><span class="line"></span><br><span class="line"> a = ((y1^2-x1^3)-(y2^2-x2^3))/(x1-x2) % p</span><br><span class="line"> b = (y1^2-x1^3-a*x1) % p</span><br><span class="line"></span><br><span class="line"> E = EllipticCurve(GF(p),[a,b])</span><br><span class="line"></span><br><span class="line"> assert E(Q[0])</span><br><span class="line"> return E,a,b,p</span><br><span class="line"></span><br><span class="line">Q = [(4713513545399586887294281187501009141689080934674926984853052046637141607331993392136186920709675152470824454822335527736604585312216293390500894812356575, 10152198551269550712132843544953877513974069303791371586626547671550636936369607844350995807520993189830394615282586805640124173078292476320861958178531199), (8497709856659541496506566158438727086633064779296427286612559352247045304592577869075723270252557382159636274220949698085489427175611575498725494187042219, 9116811362014883884879981282521462123463402369273722016008105935084826801111377968641225157887930975588405833350168170885178864192235006321249285744756607), (9370988588550376568847533229569651406006327680521920971380933472551236466257993862023372207379492794618019196741718902793769742423589142369766582541381456, 2964764716081715738931864218952095017577031943078710662273038672326443429898927649838098895380036049701254956968440876093577389832396678079667784517400438), (9780561431490704165761200835168742342147019392307027843608906950941244751705916411353543429159840043103272583252784603317509552870673884311510395715589823, 4512360262119206250842086638048812502384840258083296584133384225879227543325169341795597008831855800692604773248185325609068166181249185285419214480894245)]</span><br><span class="line"></span><br><span class="line">E,a,b,p = recover_para(Q)</span><br><span class="line"></span><br><span class="line">print(&quot;a=&quot;,a)</span><br><span class="line">print(&quot;b=&quot;,b)</span><br><span class="line">print(&quot;p=&quot;,p)</span><br></pre></td></tr></table></figure>

<p>原理如下图，来源于<strong>Van1sh的公众号</strong><a href="https://mp.weixin.qq.com/s/e8iipjHVVXk0xTGZpNOeJQ">2023 巅峰极客-Rosita (qq.com)</a></p>
<p><img src="/../../images/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22023/1.png"></p>
<h2 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h2><p>我们已知$Q &#x3D; m×R+nonce×E + sh×C$，需要注意的是每个$m,nounce,sh$都是不同的</p>
<p>一共给了73个$Q$点，所以我们有</p>
<p><img src="/../../images/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22023/2.png"></p>
<p>需要注意的是，我们选择椭圆曲线上的生成元$G$，则必定有$R&#x3D;rG,E&#x3D;eG,C&#x3D;cG$</p>
<p>所以上式可以转换成</p>
<p><img src="/../../images/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22023/3.png"></p>
<p>上述矩阵分别记为$M,C,A$</p>
<p>因为曲线的阶和$p$相等，所以$A_i$可以通过<code>smart_attack</code>恢复</p>
<p>这其实就是一个HSSP问题</p>
<p>假设存在一个与$A$正交的矩阵$T$</p>
<p><img src="/../../images/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22023/4.png"></p>
<p>则</p>
<p><img src="/../../images/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22023/5.png"></p>
<p>那么有下式，我不确定这一点的原理</p>
<p><img src="/../../images/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22023/6.png"></p>
<p>构造格</p>
<p><img src="/../../images/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22023/7.png"></p>
<p>通过LLL算法格基规约后，理想情况下，最后一列D均被规约成0</p>
<h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h3><p>我的理解是，把上面这个矩阵的每一行看成行向量，因为LLL算法实际是对每个行向量进行线性组合</p>
<p>即$z&#x3D;y_1A_1+y_2A_2+…+y_{73}A_{73}$，最后一列就是这个组合生成的$z$的值，前面73列分别就是$y_1\longrightarrow y_{73}$的值</p>
<p>这样，每一行前73列的值就是$T矩阵$某行的73个值了。所以最后一列为0即是我们的判断条件。</p>
<p>大佬说不一定能把所有行都能规约成正交矩阵T。这题73行，有70行被规约成与A正交</p>
<p>强网杯2022 Lattice的wp这里只要满足$n&gt;\frac{m}{2}$就能通过右核矩阵还原出$M$。其中n是规约后正交的行数，$m$为给出的数据行数</p>
<p>所以对于得到的70行足够还原出小向量。</p>
<h2 id="Thrid"><a href="#Thrid" class="headerlink" title="Thrid"></a>Thrid</h2><p>恢复不完全的矩阵$T$之后，我们求解</p>
<p><img src="/../../images/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22023/8.png"></p>
<p>所以M的每一列是矩阵$T$的右核解，我们要求$M$的第一列，它在$T$的右核的格上</p>
<p>且$M$的第一列是短向量，期望对$T$求右核矩阵然后<strong>规约</strong>即可还原出M的第一列。</p>
<p>最后这一步还得琢磨琢磨</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a= <span class="number">490963434153515882934487973185142842357175523008183292296815140698999054658777820556076794490414610737654365807063916602037816955706321036900113929329671</span></span><br><span class="line">b= <span class="number">7668542654793784988436499086739239442915170287346121645884096222948338279165302213440060079141960679678526016348025029558335977042712382611197995002316466</span></span><br><span class="line">p= <span class="number">11093300438765357787693823122068501933326829181518693650897090781749379503427651954028543076247583697669597230934286751428880673539155279232304301123931419</span></span><br><span class="line"></span><br><span class="line">E = EllipticCurve(GF(p),[a,b])</span><br><span class="line">out = []</span><br><span class="line">G = E.gens()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SmartAttack</span>(<span class="params">P,Q,p</span>):</span><br><span class="line">    E = P.curve()</span><br><span class="line">    Eqp = EllipticCurve(Qp(p, <span class="number">2</span>), [ ZZ(t) + randint(<span class="number">0</span>,p)*p <span class="keyword">for</span> t <span class="keyword">in</span> E.a_invariants() ])</span><br><span class="line"></span><br><span class="line">    P_Qps = Eqp.lift_x(ZZ(P.xy()[<span class="number">0</span>]), <span class="built_in">all</span>=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> P_Qp <span class="keyword">in</span> P_Qps:</span><br><span class="line">        <span class="keyword">if</span> GF(p)(P_Qp.xy()[<span class="number">1</span>]) == P.xy()[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    Q_Qps = Eqp.lift_x(ZZ(Q.xy()[<span class="number">0</span>]), <span class="built_in">all</span>=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> Q_Qp <span class="keyword">in</span> Q_Qps:</span><br><span class="line">        <span class="keyword">if</span> GF(p)(Q_Qp.xy()[<span class="number">1</span>]) == Q.xy()[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    p_times_P = p*P_Qp</span><br><span class="line">    p_times_Q = p*Q_Qp</span><br><span class="line"></span><br><span class="line">    x_P,y_P = p_times_P.xy()</span><br><span class="line">    x_Q,y_Q = p_times_Q.xy()</span><br><span class="line"></span><br><span class="line">    phi_P = -(x_P/y_P)</span><br><span class="line">    phi_Q = -(x_Q/y_Q)</span><br><span class="line">    k = phi_Q/phi_P</span><br><span class="line">    <span class="keyword">return</span> ZZ(k)</span><br><span class="line"></span><br><span class="line">A = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> out:</span><br><span class="line">    point = E(i[<span class="number">0</span>],i[<span class="number">1</span>])</span><br><span class="line">    tmp = SmartAttack(G,point,p)</span><br><span class="line">    <span class="built_in">print</span>(tmp)</span><br><span class="line">    A.append(tmp)</span><br><span class="line">    </span><br><span class="line">Ge = Matrix(ZZ,<span class="number">74</span>,<span class="number">74</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">73</span>):</span><br><span class="line">    Ge[i,i] = <span class="number">1</span></span><br><span class="line">    Ge[i,-<span class="number">1</span>] = A[i]</span><br><span class="line">Ge[-<span class="number">1</span>,-<span class="number">1</span>] = p</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;求解T&quot;</span>)</span><br><span class="line">T = []</span><br><span class="line">L = Ge.LLL()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> L:</span><br><span class="line">    <span class="keyword">if</span> i[-<span class="number">1</span>] != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">       	T.append(i[:-<span class="number">1</span>])</span><br><span class="line">       	</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(T))</span><br><span class="line">T = Matrix(ZZ,T)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;求解T结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;还原M&quot;</span>)</span><br><span class="line">M = Matrix(ZZ,T.right_kernel().basis()).LLL()[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;还原M结束&quot;</span>)</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> M:</span><br><span class="line">    flag += <span class="built_in">chr</span>(long_to_bytes(i)[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>T.right_kernel().</code>：用于计算$T$的右核。右核是指所有使得线性变换或矩阵作用于其上结果为零向量的向量的集合。</p>
<p><code>T.right_kernel().basis()</code>：用于获取$T$右核的基向量</p>
<p>这道题花了太多时间，对于求解右核然后格基规约这一过程还很迷糊</p>
]]></content>
      <categories>
        <category>Wp</category>
      </categories>
      <tags>
        <tag>Wp</tag>
      </tags>
  </entry>
  <entry>
    <title>密钥交换协议(DH)</title>
    <url>/2023/07/24/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E5%8D%8F%E8%AE%AE-DH/</url>
    <content><![CDATA[<p>简述密钥交换协议(DH)</p>
<span id="more"></span>



<p>参考文章：</p>
<p>[(8条消息) Diffie-Hellman密钥交换协议及其中间人攻击_Memories off的博客-CSDN博客](<a href="https://blog.csdn.net/happy_single/article/details/106175275?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E5%8D%8F%E8%AE%AE">https://blog.csdn.net/happy_single/article/details/106175275?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=密钥交换协议</a> 中间人攻击&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-0-106175275.142^v9^control,157^v4^new_style&amp;spm&#x3D;1018.2226.3001.4187)</p>
<p><a href="https://harry0597.com/2022/05/11/%E7%A6%BB%E6%95%A3%C2%B7DH%C2%B7Elgamal/">离散对数 ｜ DH ｜ ElGamal | Harry’s Blog (harry0597.com)</a></p>
<p>密钥交换协议<strong>不是</strong>一种<strong>加密明文的算法</strong>，而是<strong>生成</strong>一个较为安全的<strong>密钥的算法</strong></p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p><img src="/../../images/DH/0.png"></p>
<p><img src="/../../images/DH/0.png"></p>
<p><strong>Diffie-Hellman的安全性是基于离散对数求解的困难性的，然而，存在可能的中间人攻击，对Diffie-Hellman协议的安全性造成威胁。</strong></p>
<h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><p><img src="/../../images/DH/1.png"></p>
<p><strong>简述一下攻击流程</strong></p>
<p>$$<br>假设攻击人为Darth<br>$$</p>
<p>$$<br>1.Darth截取了Alice发给Bob的公钥Y_A<br>$$</p>
<p>$$<br>2.Darth选取了自己的私钥X_{D_1},并计算Y_{D_{1}}&#x3D;g^{X_{D_1}} \mod p<br>$$</p>
<p>$$<br>3.Darth把Y_{D_{1}}发送给Bob，同时Darth计算\color{red}K_2&#x3D;Y_A^{X_{D_2}} &#x3D; g^{X_AX_{D_2}}\mod p<br>$$</p>
<p>$$<br>4.Bob收到Darth发送的Y_{D_1},并计算\color{blue}K_1 &#x3D; Y_{D_1}^{X_B} &#x3D; g^{X_{D_1}X_B} \mod p<br>$$</p>
<p>$$<br>5.Bob把Y_B发送给Alice<br>$$</p>
<p>$$<br>6.Darth截取Y_B,并把Y_{D_2}发送欸Alice。Darth计算\color{blue}K_1 &#x3D; Y_{B}^{X_{D_1}} &#x3D; g^{X_B{X_{D_1}}} \mod p<br>$$</p>
<p>$$<br>7.Alice收到Y_{D_2},并计算\color{red}K_2&#x3D;Y_{D_2}^{X_A} &#x3D; g^{X_{D_2}X_A}\mod p<br>$$</p>
<p>$$<br>此时,Alice和Bob移位他们共享了密钥，但实际上却是:<br>$$</p>
<p>$$<br>\color{red} Alice和Darth共享密钥K_2<br>$$</p>
<p>$$<br>\color{blue} Bob和Darth共享密钥K_1<br>$$</p>
<p>$$<br>接下来，Alice和Bob之间的通信将以下列方式泄密：<br>$$</p>
<p>$$<br>1.Alice发送了一份加密的消息M:E(K_2,M),表示用密钥K_2对消息M加密<br>$$</p>
<p>$$<br>2.Darth截获了该密文，并解密，知晓了M<br>$$</p>
<p>$$<br>3.Darth把E(K_1,M)或者把E(K_1,M’)发送给Bob，其中M’是修改后的信息<br>$$</p>
<p>$$<br>如果Darth把E(K_1,M)发送给Bob，表明他只是偷听消息，而没有进行修改<br>$$</p>
<p>$$<br>如果Darth把E(K_1,M’)发送给Bob，说明他修改了Alice原本想传给Bob的消息<br>$$</p>
]]></content>
      <categories>
        <category>现代密码-非对称加密</category>
      </categories>
      <tags>
        <tag>现代密码</tag>
        <tag>非对称加密</tag>
        <tag>DH</tag>
      </tags>
  </entry>
  <entry>
    <title>ECC</title>
    <url>/2023/07/25/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/ECC/</url>
    <content><![CDATA[<p>记录笔者学习椭圆曲线加密算法</p>
<span id="more"></span>



<h1 id="什么是椭圆曲线"><a href="#什么是椭圆曲线" class="headerlink" title="什么是椭圆曲线"></a>什么是椭圆曲线</h1><p>书本上椭圆曲线的定义相对复杂。</p>
<p>定义如下</p>
<p>一条椭圆曲线是在射影平面上满足威尔斯特拉斯方程（Weierstrass）所有点的集合。<br>$$<br>Y^2Z + a_1XYZ + a_3YZ^2 &#x3D; X^3+a_2X^2Z +a_4XZ^2+a_6Z^3<br>$$</p>
<p>我们讲简化版的Weierstrass方程：<br>$$<br>E_p:y^2 \equiv x^3 + ax + b \mod p<br>$$</p>
<p>其中，</p>
<p>(1)$ \Delta$ &#x3D; − 16 (4a^3 + 27 b) ≠ 0,用来保证曲线是光滑的，即曲线上的所有点都没有两个或者两个以上不同的切线</p>
<p>(2) a,b $\in$ K,K为E的基础域</p>
<p>(3) 点$O_{\infty}$是曲线唯一的无穷远点</p>
<h2 id="椭圆曲线上的加法"><a href="#椭圆曲线上的加法" class="headerlink" title="椭圆曲线上的加法"></a>椭圆曲线上的加法</h2><p>设$P&#x3D;(x_1,y_1),Q&#x3D;(x_2,y_2)\in E_p(a,b)$，则$P+Q&#x3D;(x_3,y_3)$</p>
<p>其中$x_3 \equiv k^2-x_1-x_2 \mod p$，$y_3 \equiv k(x_1-x_3)-y_1 \mod p$</p>
<p><img src="/../../images/ECC/1.png"></p>
<h1 id="什么是ECC？"><a href="#什么是ECC？" class="headerlink" title="什么是ECC？"></a>什么是ECC？</h1><p>ECC全称为椭圆曲线加密(EllipseCurve Cryptography)，是一种基于椭圆曲线数学的公钥密码。</p>
<p>这里给一个加密实例:</p>
<p><img src="/../../images/ECC/0.png"></p>
<p>其分为三个过程：</p>
<h2 id="1-密钥生成："><a href="#1-密钥生成：" class="headerlink" title="1.密钥生成："></a>1.密钥生成：</h2><p>$$<br>用户A先选择一条椭圆曲线E_p(a,b),然后选择上面一点G，称为基点。基点会公开,p也会公开<br>$$</p>
<p>$$<br>然后选择一个大整数作为私钥k,并计算公钥K &#x3D; k×G<br>$$</p>
<p>$$<br>这个乘法不是简单数值上相乘，而是需要通过加的方式实现<br>$$</p>
<p>$$<br>例如，nP &#x3D; P + (n-1))P<br>$$</p>
<p>$$<br>而加法也不是简单的加法，而是需要满足一些规则<br>$$</p>
<p>详情见：<a href="https://zhuanlan.zhihu.com/p/42629724">ECC椭圆曲线密码学的原理、公式推导、例子、Python实现和应用 - 知乎 (zhihu.com)</a><br>$$<br>公钥会公开，私钥不公开<br>$$</p>
<h2 id="2-加密"><a href="#2-加密" class="headerlink" title="2.加密"></a>2.加密</h2><p>$$<br>假设用户B把需要传送的信息编码为椭圆曲线E_p上的一点M<br>$$</p>
<p>$$<br>然后计算点C_1 &#x3D; M + rK,C_2 &#x3D; rG<br>$$</p>
<p>$$<br>再把C_1,C_2传给用户A<br>$$</p>
<h2 id="3-解密"><a href="#3-解密" class="headerlink" title="3.解密"></a>3.解密</h2><p>$$<br>用户A在接受到C_1,C_2后计算用私钥k计算C_1-kC_2<br>$$</p>
<p>$$<br>\because C_1-kC_2 &#x3D; M+rK-k(rG)，把K &#x3D; kG带入得：<br>$$</p>
<p>$$<br>C_1-kC_2 &#x3D; M+rkG - krG &#x3D; M<br>$$</p>
<p>$$<br>这样就完成了解密<br>$$</p>
<h1 id="sagemath实现"><a href="#sagemath实现" class="headerlink" title="sagemath实现"></a>sagemath实现</h1><h2 id="用上的函数"><a href="#用上的函数" class="headerlink" title="用上的函数"></a>用上的函数</h2><ol>
<li><p><code>E = EllipticCurve(GF(p),[a,b]) </code> <strong>:建立有限域p上的椭圆曲线E，参数为</strong><code>a</code>,<code>b</code><strong>即椭圆曲线方程为：</strong><br>$$<br>y^2 &#x3D; x^3 + ax + b<br>$$</p>
</li>
<li><p><code>E.random_point()</code><strong>:在椭圆曲线E上随机取一点</strong></p>
</li>
<li><p><code>E.set_order()</code><strong>:设置椭圆曲线的阶</strong></p>
</li>
<li><p><code>E.point((x,y))</code><strong>:创建一个椭圆曲线上的点对象，该点对象的坐标为</strong><code>(x,y)</code></p>
</li>
<li><p><strong>求解私钥，自动选择bsgs或Pohlig Hellman算法</strong><br><code>discrete_log(K,G,operation=&#39;+&#39;)</code></p>
<p><strong>等价于</strong><code>G.discrete_log(K)</code></p>
<p>其含义是：<br>$$<br>返回一个整数x，使其满足<br>$$</p>
<p>$$<br>K &#x3D; xG<br>$$</p>
</li>
<li><p><code>E.order()</code>：计算椭圆曲线上点的阶。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(factor(E.order()))</span><br><span class="line"><span class="comment"># 2 * 3^3 * 5 * 7 * 212117 * 302426983 * 10362951863095936421891634612647340060175499</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(*factor(E.order()))</span><br><span class="line"><span class="comment">#(2, 1) (3, 3) (5, 1) (7, 1) (212117, 1) (302426983, 1) (10362951863095936421891634612647340060175499, 1)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>用Pollard rho算法求解私钥</strong><br><code>discrete_log_rho(K,G,operation=&#39;+&#39;)</code></p>
</li>
<li><p><strong>用Pollard Lambda算法求解私钥，能够确定所求值在某一小范围时效率较高</strong><br><code>discrete_log_lambda(K,G,bound,operation=&#39;+&#39;)</code></p>
</li>
</ol>
<p>这里其实我有点疑惑<br>$$<br>公钥K &#x3D; kG<br>$$</p>
<p>$$<br>为什么说它是求解离散对数的问题<br>$$</p>
<h2 id="加密实例"><a href="#加密实例" class="headerlink" title="加密实例:"></a>加密实例:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">加密</span><br><span class="line">椭圆曲线选取时，模数p应是一个大质数</span><br><span class="line">常用的有几个公开的椭圆曲线，如Secp256k1、Secp256r1等</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">p = 115792089210356248762697446949407573530086143415290314195533631308867097853951</span><br><span class="line">a = 115792089210356248762697446949407573530086143415290314195533631308867097853948</span><br><span class="line">b = 41058363725152142129326129780047268409114441015993725554835256314039467401291</span><br><span class="line">E = EllipticCurve(GF(p),[a,b]) #建立椭圆曲线E</span><br><span class="line">G = E(101981543389703054444906888236965100227902100585263327233246492901054535785571,105947302391877180514060433855403037184838385483621546199124860815209826713886) #选择一点作为基点</span><br><span class="line">n = G.order() #G的阶数</span><br><span class="line">k = 78772200542717449282831156601030024198219944170436309154595818823706214492400</span><br><span class="line">K = k*G</span><br><span class="line">r = 3546765</span><br><span class="line">m = E(80764032034929976879602863302323059647882062252124869895215418422992624743795,4964654783828069942602279691168356721024126126864424301508238062949726916347) #取E上一点m作为明文</span><br><span class="line">c1 = m+r*K</span><br><span class="line">c2 = r*G</span><br><span class="line">print(c1)</span><br><span class="line">print(c2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="解密实例"><a href="#解密实例" class="headerlink" title="解密实例:"></a>解密实例:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;解密&#x27;&#x27;&#x27;</span><br><span class="line">p = 115792089210356248762697446949407573530086143415290314195533631308867097853951</span><br><span class="line">a = 115792089210356248762697446949407573530086143415290314195533631308867097853948</span><br><span class="line">b = 41058363725152142129326129780047268409114441015993725554835256314039467401291</span><br><span class="line">k = 78772200542717449282831156601030024198219944170436309154595818823706214492400</span><br><span class="line">E = EllipticCurve(GF(p),[a,b]) #建立椭圆曲线E</span><br><span class="line">c1 = E(55527726590533087179712343802771216661752045890626636388680526348340802301667,99976146729305231192119179111453136971828647307627310904093286590128902629941)</span><br><span class="line">c2 = E(85460365972589567444123006081329559170090723413178386022601904195400422637884,58249081362527056631776731740177334121295518073095154119886890634279528757192)</span><br><span class="line">m = c1-k*c2</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure>

<h2 id="用Crypto库生成ECC密钥"><a href="#用Crypto库生成ECC密钥" class="headerlink" title="用Crypto库生成ECC密钥"></a>用Crypto库生成ECC密钥</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.PublicKey import ECC</span><br><span class="line"></span><br><span class="line">#生成ECC密钥</span><br><span class="line">key = ECC.generate(curve=&#x27;NIST P-256&#x27;) #使用椭圆曲线NIST P-256</span><br><span class="line"></span><br><span class="line">#输出密钥（包括私钥k，基点G）</span><br><span class="line">print(key)</span><br><span class="line"></span><br><span class="line">#公钥（point_x，point_y是基点G的坐标）</span><br><span class="line">print(key.public_key())</span><br><span class="line"></span><br><span class="line">#椭圆曲线</span><br><span class="line">print(key.curve)</span><br><span class="line"></span><br><span class="line">#私钥k</span><br><span class="line">print(key.d)</span><br><span class="line"></span><br><span class="line">#导出为pem密钥文件</span><br><span class="line">print(key.export_key(format=&#x27;PEM&#x27;))</span><br><span class="line"></span><br><span class="line">#导入密钥文件</span><br><span class="line">key = ECC.import_key(f.read())</span><br></pre></td></tr></table></figure>

<h2 id="几种公开椭圆曲线的参数"><a href="#几种公开椭圆曲线的参数" class="headerlink" title="几种公开椭圆曲线的参数"></a>几种公开椭圆曲线的参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#NIST P-256（Secp256r1）</span><br><span class="line">#p = 2^224(2^32 − 1) + 2^192 + 2^96 − 1</span><br><span class="line">p = 115792089210356248762697446949407573530086143415290314195533631308867097853951</span><br><span class="line">a = 115792089210356248762697446949407573530086143415290314195533631308867097853948</span><br><span class="line">b = 41058363725152142129326129780047268409114441015993725554835256314039467401291</span><br><span class="line"></span><br><span class="line">#Secp256k1（比特币使用）</span><br><span class="line">#p = 2^256 − 2^32 − 2^9 − 2^8 − 2^7 − 2^6 − 2^4 − 1 = 2^256 – 2^32 – 977 </span><br><span class="line">p = 115792089237316195423570985008687907853269984665640564039457584007908834671663</span><br><span class="line">a = 0</span><br><span class="line">b = 7</span><br><span class="line"></span><br><span class="line">#NIST P-384</span><br><span class="line">#p = 2^384 – 2^128 – 2^96 + 2^32 – 1</span><br><span class="line">p = 39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319</span><br><span class="line">a = -3</span><br><span class="line">b = 27580193559959705877849011840389048093056905856361568521428707301988689241309860865136260764883745107765439761230575</span><br><span class="line"></span><br><span class="line">#NIST P-521</span><br><span class="line">p = 6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151</span><br><span class="line">a = -3</span><br><span class="line">b = 1093849038073734274511112390766805569936207598951683748994586394495953116150735016013708737573759623248592132296706313309438452531591012912142327488478985984</span><br></pre></td></tr></table></figure>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="2022巅峰极客——point-power"><a href="#2022巅峰极客——point-power" class="headerlink" title="2022巅峰极客——point-power"></a>2022巅峰极客——point-power</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secrets <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag)==<span class="number">42</span></span><br><span class="line">p=getPrime(<span class="number">600</span>)</span><br><span class="line">a=bytes_to_long(flag)</span><br><span class="line">b=randrange(<span class="number">2</span>,p-<span class="number">1</span>)</span><br><span class="line">E=EllipticCurve(GF(p),[a,b])</span><br><span class="line">G=E.random_element()</span><br><span class="line"></span><br><span class="line">x1,y1,_=G</span><br><span class="line">G=<span class="number">2</span>*G</span><br><span class="line">x2,y2,_=G</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;p = <span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;b = <span class="subst">&#123;b&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;x1 = <span class="subst">&#123;x1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;x2 = <span class="subst">&#123;x2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">p = 3660057339895840489386133099442699911046732928957592389841707990239494988668972633881890332850396642253648817739844121432749159024098337289268574006090698602263783482687565322890623</span></span><br><span class="line"><span class="string">b = 1515231655397326550194746635613443276271228200149130229724363232017068662367771757907474495021697632810542820366098372870766155947779533427141016826904160784021630942035315049381147</span></span><br><span class="line"><span class="string">x1 = 2157670468952062330453195482606118809236127827872293893648601570707609637499023981195730090033076249237356704253400517059411180554022652893726903447990650895219926989469443306189740</span></span><br><span class="line"><span class="string">x2 = 1991876990606943816638852425122739062927245775025232944491452039354255349384430261036766896859410449488871048192397922549895939187691682643754284061389348874990018070631239671589727</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>根据椭圆曲线的加法</p>
<p>易知$x_2 \equiv k^2-2x_1 \mod p$，$k &#x3D; \frac{3x_1^2+a}{2y_1}$，又因为$y_1^2 \equiv x^3 + ax+b \mod p$</p>
<p>于是能得到$x_2 \equiv \frac{9x_1^4+6x_1^2a+a}{4(x_1^3+ax_1+b)}-2x_1 \mod p$</p>
<p>稍微变化一下，令$tmp &#x3D; 4(x_1^3+ax_1+b)$</p>
<p>解这个方程即可$9x_1^4+6x_1^2a+a-(2x_1+x_2)×tmp \equiv 0 \mod p$</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sagemath 9.3</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = </span><br><span class="line">b = </span><br><span class="line">x1 = </span><br><span class="line">x2 = </span><br><span class="line"></span><br><span class="line">R.&lt;a&gt; = PolynomialRing(Zmod(p))</span><br><span class="line"></span><br><span class="line">tmp = <span class="number">4</span>*(x1^<span class="number">3</span> + a*x1 + b)</span><br><span class="line"></span><br><span class="line">f = <span class="number">9</span>*x1^<span class="number">4</span> + <span class="number">6</span>*x1^<span class="number">2</span>*a + a^<span class="number">2</span> - (<span class="number">2</span>*x1+x2)*tmp</span><br><span class="line">f = f.monic()</span><br><span class="line">roots = f.roots()</span><br><span class="line"><span class="comment"># print(roots)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> roots:</span><br><span class="line">    m = i[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br></pre></td></tr></table></figure>





<h2 id="watevrCTF-2019-ECC-RSA"><a href="#watevrCTF-2019-ECC-RSA" class="headerlink" title="[watevrCTF 2019]ECC-RSA"></a>[watevrCTF 2019]ECC-RSA</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastecdsa.curve <span class="keyword">import</span> P521 <span class="keyword">as</span> Curve</span><br><span class="line"><span class="keyword">from</span> fastecdsa.point <span class="keyword">import</span> Point</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, isPrime</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> urandom</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> getrandbits</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_rsa_primes</span>(<span class="params">G</span>):</span><br><span class="line">	urand = bytes_to_long(urandom(<span class="number">521</span>//<span class="number">8</span>))</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		s = getrandbits(<span class="number">521</span>) ^ urand</span><br><span class="line"></span><br><span class="line">		Q = s*G</span><br><span class="line">		<span class="keyword">if</span> isPrime(Q.x) <span class="keyword">and</span> isPrime(Q.y):</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;ECC Private key:&quot;</span>, <span class="built_in">hex</span>(s))</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;RSA primes:&quot;</span>, <span class="built_in">hex</span>(Q.x), <span class="built_in">hex</span>(Q.y))</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;Modulo:&quot;</span>, <span class="built_in">hex</span>(Q.x * Q.y))</span><br><span class="line">			<span class="keyword">return</span> (Q.x, Q.y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = <span class="built_in">int</span>.from_bytes(<span class="built_in">input</span>(), byteorder=<span class="string">&quot;big&quot;</span>)</span><br><span class="line"></span><br><span class="line">ecc_p = Curve.p</span><br><span class="line">a = Curve.a</span><br><span class="line">b = Curve.b</span><br><span class="line"></span><br><span class="line">Gx = Curve.gx</span><br><span class="line">Gy = Curve.gy</span><br><span class="line">G = Point(Gx, Gy, curve=Curve)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">p, q = gen_rsa_primes(G)</span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file_out = <span class="built_in">open</span>(<span class="string">&quot;downloads/ecc-rsa.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">file_out.write(<span class="string">&quot;ECC Curve Prime: &quot;</span> + <span class="built_in">hex</span>(ecc_p) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">file_out.write(<span class="string">&quot;Curve a: &quot;</span> + <span class="built_in">hex</span>(a) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">file_out.write(<span class="string">&quot;Curve b: &quot;</span> + <span class="built_in">hex</span>(b) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">file_out.write(<span class="string">&quot;Gx: &quot;</span> + <span class="built_in">hex</span>(Gx) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">file_out.write(<span class="string">&quot;Gy: &quot;</span> + <span class="built_in">hex</span>(Gy) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">file_out.write(<span class="string">&quot;e: &quot;</span> + <span class="built_in">hex</span>(e) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">file_out.write(<span class="string">&quot;p * q: &quot;</span> + <span class="built_in">hex</span>(n) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">c = <span class="built_in">pow</span>(flag, e, n)</span><br><span class="line">file_out.write(<span class="string">&quot;ciphertext: &quot;</span> + <span class="built_in">hex</span>(c) + <span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>已知椭圆曲线参数$p,a,b$即椭圆曲线方程为$y^2 \equiv x^3 + ax + b \mod p$</p>
<p>$\therefore q^2 \equiv p^3 + ap + b \mod p$ 同乘$p^2$得$n^2 \equiv p^5 + ap^3 + bp^2 \mod p$</p>
<p>解方程求$p$</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">ecc_p = <span class="number">0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line">a = -<span class="number">3</span></span><br><span class="line">b = <span class="number">0x51953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00</span></span><br><span class="line">Gx = <span class="number">0xc6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66</span></span><br><span class="line">Gy = <span class="number">0x11839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">n = <span class="number">0x118aaa1add80bdd0a1788b375e6b04426c50bb3f9cae0b173b382e3723fc858ce7932fb499cd92f5f675d4a2b05d2c575fc685f6cf08a490d6c6a8a6741e8be4572adfcba233da791ccc0aee033677b72788d57004a776909f6d699a0164af514728431b5aed704b289719f09d591f5c1f9d2ed36a58448a9d57567bd232702e9b28f</span></span><br><span class="line">c = <span class="number">0x3862c872480bdd067c0c68cfee4527a063166620c97cca4c99baff6eb0cf5d42421b8f8d8300df5f8c7663adb5d21b47c8cb4ca5aab892006d7d44a1c5b5f5242d88c6e325064adf9b969c7dfc52a034495fe67b5424e1678ca4332d59225855b7a9cb42db2b1db95a90ab6834395397e305078c5baff78c4b7252d7966365afed9e</span></span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(ecc_p))</span><br><span class="line"></span><br><span class="line">f = x^<span class="number">5</span> + a*x^<span class="number">3</span> + b*x^<span class="number">2</span> - n^<span class="number">2</span></span><br><span class="line"></span><br><span class="line">p = f.roots()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> p:</span><br><span class="line">    t = gcd(Integer(i[<span class="number">0</span>]),n)</span><br><span class="line">    <span class="keyword">if</span> t != <span class="number">1</span>:</span><br><span class="line">        p = t</span><br><span class="line">        q = n // p</span><br><span class="line">        d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">        m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(m)))</span><br></pre></td></tr></table></figure>

<p>需要注意的是，一般我们在sagemath中赋值的变量都是<code>sage.rings.integer.Integer</code>的数据类型</p>
<p>而解出来的$p$是<code>sage.rings.finite_rings.integer_mod.IntegerMod_gmp</code></p>
<p>两个数据类型做gcd运算会获得1，所以我们需要先把$p$转成<code>int</code>或者<code>Integer</code></p>
<h2 id="第五空间-2021-ecc"><a href="#第五空间-2021-ecc" class="headerlink" title="[第五空间 2021]ecc"></a>[第五空间 2021]ecc</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print &#x27;Try to solve the 3 ECC&#x27;</span><br><span class="line"></span><br><span class="line">from secret import flag</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">assert(flag[:5]==&#x27;flag&#123;&#x27;)</span><br><span class="line">flag = flag[5:-1]</span><br><span class="line">num1 = bytes_to_long(flag[:7])</span><br><span class="line">num2 = bytes_to_long(flag[7:14])</span><br><span class="line">num3 = bytes_to_long(flag[14:])</span><br><span class="line"></span><br><span class="line">def ECC1(num):</span><br><span class="line">	p = 146808027458411567</span><br><span class="line">	A = 46056180</span><br><span class="line">	B = 2316783294673</span><br><span class="line">	E = EllipticCurve(GF(p),[A,B])</span><br><span class="line">	P = E.random_point() </span><br><span class="line">	Q = num*P</span><br><span class="line">	print E</span><br><span class="line">	print &#x27;P:&#x27;,P</span><br><span class="line">	print &#x27;Q:&#x27;,Q</span><br><span class="line"></span><br><span class="line">def ECC2(num):</span><br><span class="line">	p = 1256438680873352167711863680253958927079458741172412327087203</span><br><span class="line">	#import random</span><br><span class="line">	#A = random.randrange(389718923781273978681723687163812)</span><br><span class="line">	#B = random.randrange(816378675675716537126387613131232121431231)</span><br><span class="line">	A = 377999945830334462584412960368612</span><br><span class="line">	B = 604811648267717218711247799143415167229480</span><br><span class="line">	E = EllipticCurve(GF(p),[A,B])</span><br><span class="line">	P = E.random_point() </span><br><span class="line">	Q = num*P</span><br><span class="line">	print E</span><br><span class="line">	print &#x27;P:&#x27;,P</span><br><span class="line">	print &#x27;Q:&#x27;,Q</span><br><span class="line">	factors, exponents = zip(*factor(E.order()))</span><br><span class="line">	primes = [factors[i] ^ exponents[i] for i in range(len(factors))][:-1]</span><br><span class="line">	print primes</span><br><span class="line">	dlogs = []</span><br><span class="line">	for fac in primes:</span><br><span class="line">		t = int(int(P.order()) / int(fac))</span><br><span class="line">		dlog = discrete_log(t*Q,t*P,operation=&quot;+&quot;)</span><br><span class="line">		dlogs += [dlog]</span><br><span class="line">		print(&quot;factor: &quot;+str(fac)+&quot;, Discrete Log: &quot;+str(dlog)) #calculates discrete logarithm for each prime order</span><br><span class="line">	print num</span><br><span class="line">	print crt(dlogs,primes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def ECC3(num):</span><br><span class="line">	p = 0xd3ceec4c84af8fa5f3e9af91e00cabacaaaecec3da619400e29a25abececfdc9bd678e2708a58acb1bd15370acc39c596807dab6229dca11fd3a217510258d1b</span><br><span class="line">	A = 0x95fc77eb3119991a0022168c83eee7178e6c3eeaf75e0fdf1853b8ef4cb97a9058c271ee193b8b27938a07052f918c35eccb027b0b168b4e2566b247b91dc07</span><br><span class="line">	B = 0x926b0e42376d112ca971569a8d3b3eda12172dfb4929aea13da7f10fb81f3b96bf1e28b4a396a1fcf38d80b463582e45d06a548e0dc0d567fc668bd119c346b2</span><br><span class="line">	E = EllipticCurve(GF(p),[A,B])</span><br><span class="line">	P = E.random_point() </span><br><span class="line">	Q = num*P</span><br><span class="line">	print E</span><br><span class="line">	print &#x27;P:&#x27;,P</span><br><span class="line">	print &#x27;Q:&#x27;,Q</span><br><span class="line"></span><br><span class="line">ECC1(num1)</span><br><span class="line">print &#x27;==============&#x27;</span><br><span class="line">ECC2(num2)</span><br><span class="line">print &#x27;==============&#x27;</span><br><span class="line">ECC3(num3)</span><br></pre></td></tr></table></figure>

<h3 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h3><p>第一部分就是基础解$Q &#x3D; kP$这个式子的k</p>
<h3 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h3><p>第二部分是利用中国剩余定理解离散对数问题，代码已经在附件里面了，需要把<code>/</code>改成<code>//</code>，不然跑不出来</p>
<h3 id="part3"><a href="#part3" class="headerlink" title="part3"></a>part3</h3><p>第三部分考察模数p和曲线的阶相等，用SmartAttack</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="comment">#part1</span></span><br><span class="line">p1 = <span class="number">146808027458411567</span></span><br><span class="line">A1 = <span class="number">46056180</span></span><br><span class="line">B1 = <span class="number">2316783294673</span></span><br><span class="line">E1 = EllipticCurve(GF(p1),[A1,B1])</span><br><span class="line">P1 = E1(<span class="number">119851377153561800</span>,<span class="number">50725039619018388</span>)</span><br><span class="line">Q1 = E1(<span class="number">22306318711744209</span>,<span class="number">111808951703508717</span>)</span><br><span class="line"></span><br><span class="line">m1 = P1.discrete_log(Q1)        <span class="comment"># flag1 = discrete_log(Q1,P1,operation=&#x27;+&#x27;)</span></span><br><span class="line">flag1 = long_to_bytes(<span class="built_in">int</span>(m1))</span><br><span class="line"><span class="built_in">print</span>(flag1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#part2</span></span><br><span class="line">p2 = <span class="number">1256438680873352167711863680253958927079458741172412327087203</span></span><br><span class="line">A2 = <span class="number">377999945830334462584412960368612</span></span><br><span class="line">B2 = <span class="number">604811648267717218711247799143415167229480</span></span><br><span class="line">E2 = EllipticCurve(GF(p2),[A2,B2])</span><br><span class="line">P2 = E2(<span class="number">550637390822762334900354060650869238926454800955557622817950</span>,<span class="number">700751312208881169841494663466728684704743091638451132521079</span>)</span><br><span class="line">Q2 = E2(<span class="number">1152079922659509908913443110457333432642379532625238229329830</span>,<span class="number">819973744403969324837069647827669815566569448190043645544592</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">P,Q,E</span>):</span><br><span class="line">    factors, exponents = <span class="built_in">zip</span>(*factor(E.order()))</span><br><span class="line">    primes = [factors[i] ^ exponents[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(factors))][:-<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(primes)</span><br><span class="line">    dlogs = []</span><br><span class="line">    <span class="keyword">for</span> fac <span class="keyword">in</span> primes:</span><br><span class="line">        t = <span class="built_in">int</span>(<span class="built_in">int</span>(P.order()) // <span class="built_in">int</span>(fac))</span><br><span class="line">        dlog = discrete_log(t*Q,t*P,operation=<span class="string">&quot;+&quot;</span>)</span><br><span class="line">        dlogs += [dlog]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;factor: &quot;</span>+<span class="built_in">str</span>(fac)+<span class="string">&quot;, Discrete Log: &quot;</span>+<span class="built_in">str</span>(dlog)) <span class="comment">#calculates discrete logarithm for each prime order</span></span><br><span class="line">    m = CRT_list(dlogs,primes)</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line">m2 = solve(P2,Q2,E2)</span><br><span class="line">flag2 = long_to_bytes(<span class="built_in">int</span>(m2))</span><br><span class="line"><span class="built_in">print</span>(flag2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#part3</span></span><br><span class="line">p3 = <span class="number">0xd3ceec4c84af8fa5f3e9af91e00cabacaaaecec3da619400e29a25abececfdc9bd678e2708a58acb1bd15370acc39c596807dab6229dca11fd3a217510258d1b</span></span><br><span class="line">A3 = <span class="number">0x95fc77eb3119991a0022168c83eee7178e6c3eeaf75e0fdf1853b8ef4cb97a9058c271ee193b8b27938a07052f918c35eccb027b0b168b4e2566b247b91dc07</span></span><br><span class="line">B3 = <span class="number">0x926b0e42376d112ca971569a8d3b3eda12172dfb4929aea13da7f10fb81f3b96bf1e28b4a396a1fcf38d80b463582e45d06a548e0dc0d567fc668bd119c346b2</span></span><br><span class="line">E3 = EllipticCurve(GF(p3),[A3,B3])</span><br><span class="line">P3 = E3(<span class="number">10121571443191913072732572831490534620810835306892634555532657696255506898960536955568544782337611042739846570602400973952350443413585203452769205144937861</span> ,<span class="number">8425218582467077730409837945083571362745388328043930511865174847436798990397124804357982565055918658197831123970115905304092351218676660067914209199149610</span> )</span><br><span class="line">Q3 = E3(<span class="number">964864009142237137341389653756165935542611153576641370639729304570649749004810980672415306977194223081235401355646820597987366171212332294914445469010927</span> ,<span class="number">5162185780511783278449342529269970453734248460302908455520831950343371147566682530583160574217543701164101226640565768860451999819324219344705421407572537</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(p3 == E3.order())</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SmartAttack</span>(<span class="params">P,Q,p</span>):</span><br><span class="line">    E = P.curve()</span><br><span class="line">    Eqp = EllipticCurve(Qp(p, <span class="number">2</span>), [ ZZ(t) + randint(<span class="number">0</span>,p)*p <span class="keyword">for</span> t <span class="keyword">in</span> E.a_invariants() ])</span><br><span class="line"></span><br><span class="line">    P_Qps = Eqp.lift_x(ZZ(P.xy()[<span class="number">0</span>]), <span class="built_in">all</span>=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> P_Qp <span class="keyword">in</span> P_Qps:</span><br><span class="line">        <span class="keyword">if</span> GF(p)(P_Qp.xy()[<span class="number">1</span>]) == P.xy()[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    Q_Qps = Eqp.lift_x(ZZ(Q.xy()[<span class="number">0</span>]), <span class="built_in">all</span>=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> Q_Qp <span class="keyword">in</span> Q_Qps:</span><br><span class="line">        <span class="keyword">if</span> GF(p)(Q_Qp.xy()[<span class="number">1</span>]) == Q.xy()[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    p_times_P = p*P_Qp</span><br><span class="line">    p_times_Q = p*Q_Qp</span><br><span class="line"></span><br><span class="line">    x_P,y_P = p_times_P.xy()</span><br><span class="line">    x_Q,y_Q = p_times_Q.xy()</span><br><span class="line"></span><br><span class="line">    phi_P = -(x_P/y_P)</span><br><span class="line">    phi_Q = -(x_Q/y_Q)</span><br><span class="line">    k = phi_Q/phi_P</span><br><span class="line">    <span class="keyword">return</span> ZZ(k)</span><br><span class="line"></span><br><span class="line">m3 = SmartAttack(P3,Q3,p3)</span><br><span class="line">flag3 = long_to_bytes(<span class="built_in">int</span>(m3))</span><br><span class="line"><span class="built_in">print</span>(flag3)</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;&#x27;</span> + flag1 + flag2 + flag3 + <span class="string">b&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>





<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p>[ECC椭圆曲线加密算法—加解密（SageMath实现） - lnjoy - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/lnjoy/archive/2020/10/12/ecc.html#:~:text=%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BFEp">https://www.cnblogs.com/lnjoy/archive/2020/10/12/ecc.html#:~:text=椭圆曲线Ep</a> (a%2Cb)（p为模数），基点（生成元）G (x%2Cy)，G点的阶数n，私钥k，公钥K (x%2Cy)，随机整数r，明文为一点m (x%2Cy)，密文为两点 c1 (x%2Cy)和 c2,m %3D c1 -k* c2 （%3D c1 -r*K))</p>
<p>[ECC - CTF Wiki (ctf-wiki.org)](<a href="https://ctf-wiki.org/crypto/asymmetric/discrete-log/ecc/#:~:text=ECC">https://ctf-wiki.org/crypto/asymmetric/discrete-log/ecc/#:~:text=ECC</a> - CTF Wiki ECC 概述,ECC 全称为椭圆曲线加密，EllipseCurve Cryptography，是一种基于椭圆曲线数学的公钥密码。 与传统的基于大质数因子分解困难性的加密方法不同，ECC 依赖于解决椭圆曲线离散对数问题的困难性。 它的优势主要在于相对于其它方法，它可以在使用较短密钥长度的同时保持相同的密码强度。)</p>
<p><a href="https://blog.csdn.net/qq_45198339/article/details/128756070">(10条消息) CTF学习笔记二——ECC加密_ecc加密 代码_457591978的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/sitebus/article/details/82835492">(10条消息) ECC椭圆曲线加解密原理详解(配图)_ecc加解密_NFTDigger的博客-CSDN博客</a></p>
<p><a href="http://www.leonlist.top/2020/09/29/CTF%E5%AF%86%E7%A0%81%E5%AD%A6-ECC/">CTF密码学-ECC | Leonlist’s Blog</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/42629724">ECC椭圆曲线密码学的原理、公式推导、例子、Python实现和应用 - 知乎 (zhihu.com)</a></p>
<p><a href="https://wumansgy.github.io/2018/10/30/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/">椭圆曲线加密算法详解 | Wuman’s Blog (wumansgy.github.io)</a></p>
]]></content>
      <categories>
        <category>现代密码-非对称加密</category>
      </categories>
      <tags>
        <tag>现代密码</tag>
        <tag>非对称加密</tag>
        <tag>ECC</tag>
      </tags>
  </entry>
  <entry>
    <title>OTP(一次一密加密法)</title>
    <url>/2023/07/05/%E6%B5%81%E5%AF%86%E7%A0%81/OTP-%E4%B8%80%E6%AC%A1%E4%B8%80%E5%AF%86-%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>简述一下OPT</strong></p>
<span id="more"></span>



<p><strong>OPT又叫一次一密加密方式</strong></p>
<p>简单了解一下该加密方式：<br>$$<br>密文C &#x3D; 密钥K \oplus 明文M<br>$$<br>显而易见，解密方式即是：<br>$$<br>明文M &#x3D; 密钥K \oplus 密文C<br>$$<br><strong>需要注意的是，密钥是一个和密文等长的二进制字符串</strong></p>
<p>这里给出一道例题，来自LitCTF2023——隐晦的消息记录</p>
<p>题目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">出题人:6c73d5240a948c86981bc294814d</span><br><span class="line">某不知名收件人：收到消息attack at dawn</span><br><span class="line">出题人:xxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">某不知名收件人：收到消息Monday or Thur</span><br><span class="line">已知出题人和收件人手中的密钥相同，请解出出题人第二次发送的密文呢（16进制，字母小写，解得的结果记得要加上LitCTF&#123;&#125;哦。）</span><br></pre></td></tr></table></figure>

<p>根据题目提示，知道这是OPT加密，了解一下原理之后就知道该加密方式是通过异或实现的</p>
<p>只要把密文和密钥进行异或就能得到明文</p>
<p><strong>首先把 <code>attack at dawn</code>转成16进制，再和<code>6c73d5240a948c86981bc294814d</code>进行异或，即可得到密钥，因为两次密钥相同，所以把<code>Monday or Thur</code>和密钥异或，就是我们要的密文</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ciphertext1 = <span class="number">0x6c73d5240a948c86981bc294814d</span>    <span class="comment">#   attack at dawn转16进制后</span></span><br><span class="line">plaintext1 = <span class="number">0x61747461636b206174206461776e</span></span><br><span class="line"></span><br><span class="line">key = ciphertext1 ^ plaintext1</span><br><span class="line"></span><br><span class="line"><span class="comment">#   key = 0xd07a14569fface7ec3ba6f5f623</span></span><br><span class="line"></span><br><span class="line">plaintext2 = <span class="number">0x4d6f6e646179206f722054687572</span>      <span class="comment">#  Monday or Thur转16进制后</span></span><br><span class="line"></span><br><span class="line">ciphertext2 = key ^ plaintext2</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(ciphertext2))</span><br><span class="line"></span><br><span class="line"><span class="comment">#NSSCTF&#123;4068cf2108868c889e1bf29d8351&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>现代密码-流密码</category>
      </categories>
      <tags>
        <tag>现代密码</tag>
        <tag>流密码</tag>
        <tag>OTP</tag>
      </tags>
  </entry>
  <entry>
    <title>MTP-多次加密</title>
    <url>/2023/07/24/%E6%B5%81%E5%AF%86%E7%A0%81/MTP-%E5%A4%9A%E6%AC%A1%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<p>简述多次加密法(MTP)</p>
<span id="more"></span>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><strong>MTP(Many-Time-Pad)，其加密方式和OTP是一样的，都是使用简单的异或操作。</strong></p>
<p><strong>不同之处在于OTP是用不同的</strong><code>key</code><strong>异或不同的</strong><code>明文</code><strong>。而MTP是用同一个</strong><code>key</code><strong>去异或多个</strong><code>明文</code></p>
<p>详细见：<a href="https://www.ruanx.net/many-time-pad/">Many-Time-Pad 攻击 (ruanx.net)</a></p>
<h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><p>先附上脚本:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Crypto.Util.strxor <span class="keyword">as</span> xo</span><br><span class="line"><span class="keyword">import</span> libnum, codecs, numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isChr</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) &lt;= x <span class="keyword">and</span> x &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;z&#x27;</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) &lt;= x <span class="keyword">and</span> x &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;Z&#x27;</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">infer</span>(<span class="params">index, pos</span>):</span><br><span class="line">    <span class="keyword">if</span> msg[index, pos] != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    msg[index, pos] = <span class="built_in">ord</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(c)):</span><br><span class="line">        <span class="keyword">if</span> x != index:</span><br><span class="line">            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ <span class="built_in">ord</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">know</span>(<span class="params">index, pos, ch</span>):</span><br><span class="line">    msg[index, pos] = <span class="built_in">ord</span>(ch)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(c)):</span><br><span class="line">        <span class="keyword">if</span> x != index:</span><br><span class="line">            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ <span class="built_in">ord</span>(ch)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dat = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getSpace</span>():</span><br><span class="line">    <span class="keyword">for</span> index, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(c):</span><br><span class="line">        res = [xo.strxor(x, y) <span class="keyword">for</span> y <span class="keyword">in</span> c <span class="keyword">if</span> x!=y]</span><br><span class="line">        f = <span class="keyword">lambda</span> pos: <span class="built_in">len</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(isChr, [s[pos] <span class="keyword">for</span> s <span class="keyword">in</span> res])))</span><br><span class="line">        cnt = [f(pos) <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x))]</span><br><span class="line">        <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">            dat.append((f(pos), index, pos))</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里传密文</span></span><br><span class="line">c = [codecs.decode(x.strip().encode(), <span class="string">&#x27;hex&#x27;</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;Problem.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).readlines()]</span><br><span class="line"></span><br><span class="line">msg = np.zeros([<span class="built_in">len</span>(c), <span class="built_in">len</span>(c[<span class="number">0</span>])], dtype=<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">getSpace()</span><br><span class="line"></span><br><span class="line">dat = <span class="built_in">sorted</span>(dat)[::-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> w, index, pos <span class="keyword">in</span> dat:</span><br><span class="line">    infer(index, pos)</span><br><span class="line"></span><br><span class="line">know(<span class="number">10</span>, <span class="number">21</span>, <span class="string">&#x27;y&#x27;</span>)	<span class="comment">#如果需要修正， 传入所在被改字母所在行和列，再输入替代的字母,例如alwa s 改为always</span></span><br><span class="line">know(<span class="number">8</span>, <span class="number">14</span>, <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>.join([<span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> x]) <span class="keyword">for</span> x <span class="keyword">in</span> msg]))</span><br><span class="line"></span><br><span class="line">key = xo.strxor(c[<span class="number">0</span>], <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> msg[<span class="number">0</span>]]).encode())</span><br><span class="line"><span class="built_in">print</span>(key)</span><br></pre></td></tr></table></figure>



<h1 id="例题-BUUCTF—AFCTF2018—你听过一次一密吗？"><a href="#例题-BUUCTF—AFCTF2018—你听过一次一密吗？" class="headerlink" title="例题 BUUCTF—AFCTF2018—你听过一次一密吗？"></a>例题 BUUCTF—AFCTF2018—你听过一次一密吗？</h1><p>例题中改动的数据来源于<a href="https://www.ruanx.net/many-time-pad/">Many-Time-Pad 攻击 (ruanx.net)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(原题有bug, 笔者有少量改动)</span><br><span class="line">25030206463d3d393131555f7f1d061d4052111a19544e2e5d54</span><br><span class="line">0f020606150f203f307f5c0a7f24070747130e16545000035d54</span><br><span class="line">1203075429152a7020365c167f390f1013170b1006481e13144e</span><br><span class="line">0f4610170e1e2235787f7853372c0f065752111b15454e0e0901</span><br><span class="line">081543000e1e6f3f3a3348533a270d064a02111a1b5f4e0a1855</span><br><span class="line">0909075412132e247436425332281a1c561f04071d520f0b1158</span><br><span class="line">4116111b101e2170203011113a69001b47520601155205021901</span><br><span class="line">041006064612297020375453342c17545a01451811411a470e44</span><br><span class="line">021311114a5b0335207f7c167f22001b44520c15544801125d40</span><br><span class="line">06140611460c26243c7f5c167f3d015446010053005907145d44</span><br><span class="line">0f05110d160f263f3a7f4210372c03111313090415481d49530f</span><br></pre></td></tr></table></figure>

<p>$$<br>上述的每个字符串C_i都是某个密钥key\oplus 明文M_i得到的。<br>$$</p>
<p>我们的目标是获取这个<code>key</code><br>$$<br>\because C_1 &#x3D; M_1 \oplus key<br>$$<br>$$<br>C_2 &#x3D; M_2 \oplus key<br>$$</p>
<p>$$<br>\therefore C_1 \oplus C_2 &#x3D; (M_1 \oplus key)\oplus (M_2 \oplus key)&#x3D;M_1 \oplus M_2<br>$$</p>
<p>这表明，两个密文的异或，就等于对应明文的异或。这是很危险的性质，高明的攻击者可以通过频率分析，来破译这些密文。</p>
<p>我们来看字符串 <code>C1</code>异或上其他密文会得到什么东西。以下只保留了英文字符，其余字符以 <code>.</code> 代替</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">....S....N.U.....A..M.N...</span><br><span class="line">...Ro..I...I....SE....P.I.</span><br><span class="line">.E..H...IN..H...........TU</span><br><span class="line">..A.H.R.....E....P......E.</span><br><span class="line">...RT...E...M....M....A.L.</span><br><span class="line">d...V..I..DNEt........K.DU</span><br><span class="line">.......I....K..I.ST...TiS.</span><br><span class="line">.....f...N.I........M.O...</span><br><span class="line">.........N.I...I.S.I..I...</span><br><span class="line">....P....N.OH...SA....Sg..</span><br></pre></td></tr></table></figure>

<p>可以观察到，有些列上有大量的英文字符，有些列一个英文字符都没有。这是偶然现象吗？</p>
<h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p><img src="/../../images/MTP/0.png"></p>
<p>对照ASCII码表</p>
<p>因为<code>空格</code>的ASCII码值是<code>32</code>，再观察大写字母和小写字母</p>
<p>我们可以发现小写字母 <code>xor </code>空格，会得到对应的大写字母；大写字母 <code>xor </code>空格，会得到小写字母！</p>
<p>所以，如果<code>x xor y</code> 得到一个英文字母，那么，<code>x,y</code>中某一个很大概率是空格<br>$$<br>回头看上面C_1 \oplus 其他密文——也就等于 M_1 \oplus 其他明文的表<br>$$</p>
<p>$$<br>如果第col列存在大量的英文字母，我们可以猜测M_1[col]是一个空格。<br>$$</p>
<p>$$<br>哪一列英文字母越多，把握越大。<br>$$</p>
<p>$$<br>\color{red}知道M_1的第col位是空格有什么用？<br>$$</p>
<p>$$<br>\because 一个数异或0还是等于本身,即0 &#x3D; a \oplus a<br>$$</p>
<p>$$<br>\therefore 	M_i[col] &#x3D; M_i[col] \oplus 0 &#x3D; M_i[col] \oplus M_1[col] \oplus M_1[col]&#x3D;M_i[col] \oplus M_1[col] \oplus 32<br>$$</p>
<h1 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h1><p><strong>攻击原理还是没理解很明白</strong></p>
<p>攻击过程显而易见：对于每一条密文<code>Ci</code>，拿去异或其他所有密文。然后去数每一列有多少个英文字符，作为“<code>Mi</code></p>
<p>在这一位是空格“的评分。</p>
<p>上面的事情做完时候，依据评分从大到小排序，依次利用 “某个明文的某一位是空格” 这种信息恢复出所有明文的那一列。如果产生冲突，则舍弃掉评分小的。</p>
<p><strong>下面附上大佬写的脚本以及思路</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Crypto.Util.strxor <span class="keyword">as</span> xo</span><br><span class="line"><span class="keyword">import</span> libnum, codecs, numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isChr</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) &lt;= x <span class="keyword">and</span> x &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;z&#x27;</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) &lt;= x <span class="keyword">and</span> x &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;Z&#x27;</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">infer</span>(<span class="params">index, pos</span>):</span><br><span class="line">    <span class="keyword">if</span> msg[index, pos] != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    msg[index, pos] = <span class="built_in">ord</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(c)):</span><br><span class="line">        <span class="keyword">if</span> x != index:</span><br><span class="line">            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ <span class="built_in">ord</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">dat = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getSpace</span>():</span><br><span class="line">    <span class="keyword">for</span> index, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(c):</span><br><span class="line">        res = [xo.strxor(x, y) <span class="keyword">for</span> y <span class="keyword">in</span> c <span class="keyword">if</span> x!=y]</span><br><span class="line">        f = <span class="keyword">lambda</span> pos: <span class="built_in">len</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(isChr, [s[pos] <span class="keyword">for</span> s <span class="keyword">in</span> res])))</span><br><span class="line">        cnt = [f(pos) <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x))]</span><br><span class="line">        <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">            dat.append((f(pos), index, pos))</span><br><span class="line"></span><br><span class="line"><span class="comment">#c = 密文           </span></span><br><span class="line"><span class="comment">#c = [codecs.decode(x.strip().encode(), &#x27;hex&#x27;) for x in open(&#x27;Problem.txt&#x27;, &#x27;r&#x27;).readlines()]</span></span><br><span class="line"></span><br><span class="line">msg = np.zeros([<span class="built_in">len</span>(c), <span class="built_in">len</span>(c[<span class="number">0</span>])], dtype=<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">getSpace()</span><br><span class="line"></span><br><span class="line">dat = <span class="built_in">sorted</span>(dat)[::-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> w, index, pos <span class="keyword">in</span> dat:</span><br><span class="line">    infer(index, pos)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>.join([<span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> x]) <span class="keyword">for</span> x <span class="keyword">in</span> msg]))</span><br></pre></td></tr></table></figure>

<p>执行代码，得到的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dear Friend, T%is tim&lt; I u</span><br><span class="line">nderstood my m$stake 8nd u</span><br><span class="line">sed One time p,d encr ptio</span><br><span class="line">n scheme, I he,rd tha- it </span><br><span class="line">is the only en.ryptio7 met</span><br><span class="line">hod that is ma9hemati:ally</span><br><span class="line"> proven to be #ot cra:ked </span><br><span class="line">ever if the ke4 is ke)t se</span><br><span class="line">cure, Let Me k#ow if  ou a</span><br><span class="line">gree with me t&quot; use t1is e</span><br><span class="line">ncryption sche e alwa s...</span><br></pre></td></tr></table></figure>

<p>显然这不是最终结果，我们得修正几项。把 <code>k#now</code> 修复成 <code>know</code>，把 <code>alwa s</code> 修复成 <code>always</code>. 代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">know</span>(<span class="params">index, pos, ch</span>):</span><br><span class="line">    msg[index, pos] = <span class="built_in">ord</span>(ch)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(c)):</span><br><span class="line">        <span class="keyword">if</span> x != index:</span><br><span class="line">            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ <span class="built_in">ord</span>(ch)</span><br><span class="line"></span><br><span class="line">know(<span class="number">10</span>, <span class="number">21</span>, <span class="string">&#x27;y&#x27;</span>)	<span class="comment">#这里传入需要改的字母所在行和列，例如k#now在第9行第15列</span></span><br><span class="line">know(<span class="number">8</span>, <span class="number">14</span>, <span class="string">&#x27;n&#x27;</span>)	</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>.join([<span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> x]) <span class="keyword">for</span> x <span class="keyword">in</span> msg]))</span><br></pre></td></tr></table></figure>

<p><strong>注意：空格也占位</strong></p>
<p>结果得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dear Friend, This time I u</span><br><span class="line">nderstood my mistake and u</span><br><span class="line">sed One time pad encryptio</span><br><span class="line">n scheme, I heard that it </span><br><span class="line">is the only encryption met</span><br><span class="line">hod that is mathematically</span><br><span class="line"> proven to be not cracked </span><br><span class="line">ever if the key is kept se</span><br><span class="line">cure, Let Me know if you a</span><br><span class="line">gree with me to use this e</span><br><span class="line">ncryption scheme always...</span><br></pre></td></tr></table></figure>



<h1 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> secret, key</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.strxor <span class="keyword">import</span> strxor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ENC</span>(<span class="params">m, k</span>):</span><br><span class="line">    c = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(m) // <span class="built_in">len</span>(k)):</span><br><span class="line">        tmp = m[i * <span class="built_in">len</span>(k):(i + <span class="number">1</span>) * <span class="built_in">len</span>(k)]</span><br><span class="line">        c.append(strxor(tmp, key))</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ENC(secret, key))</span><br><span class="line"><span class="comment"># [b&#x27;sO$\x03T\x10\x02\x10SR\x03\x0c\x11\x08B\x0c\x01\x00\x01\x0cGET\tE\x1dM(L\x08O\x1dF\x1aD\x10\x15\x1d\x17MI\x12H\x04\x02E\x19\x1c\n\x1e\x16\x00\x06\x04\x12\x0bG\x0f\x01\x15G\x01\x1d\x01K&#x27;, b&#x27;CT \tN\nAUf\x1e\x04\nE\x04\x11E&lt;O\x1a0gN\x1b\x1f(:pg\x00=\x00\x1b\x07\x17H\x02\x0f\x15\x00\x00\r\x0fR\x00\x15\x11\x1b\x16\x01N\x07U\x11L\x07\rEF\x1c\x13\t\x01\x07\x07A&#x27;, b&#x27;RMi\x05H\x18\x1c\x10SR\x1c\x02\x10CB&lt;\x1dUM\x11YR\x1aH\x04\tA NHO\x0cR\x00\x00\x17\t\x17ES\x1d\tR\x08V\x04\x16\x13\x1a\x1d\x11SKL&lt;\x13E\x14O\x13\t\x01T\x1cX&#x27;, b&#x27;ERi\x1fO\x0cO\x05L\x13\x1cM\x11\x05\x0b\x16RO\x18\x11\x00\x00\x18\x01\x0e\x0b\x00:O\t\nNH\x19I\r\x0e\x07\x16\x00\r\x07N\x06\x13E\x05\x10\x1b\x06ED\x00\r\x07\r\x00\x0c\x1a\x01\x13E\x16\x16H&#x27;, b&quot;OR,FD\x18\x18\x1b\x0eR2\x05\x1cRB&#x27;\x17C\x0c\x10_ET\x1c\r\x07SiS\x10\x00\x1cJTI\x10\x0fU\x11\x00\x1a\tM\x00\x02\r\x1b\x17\x08N\x11H\x04\x18S\x07L\x03\x18R\x0e\x0bT\x15\\&quot;, b&#x27;OMi\x00A\x0bO\x14W\x13\x1cAE\x1e\r\x08\x17T\x05\x0cBGT\x1c\r\x0fTiH\x05\x1cNI\x1bT\x0b\x08\x1c\x02\x00\x1d\t\x00\x01\x19E\x05\x10\x1b\x06EY\n\x19]Et\x0e\x06\x01G\x16\x00\x1c\\&#x27;, b&#x27;M\x00 \x15\x00\x00\x00\x00\x0eR6\x02\x08\x08\x16\r\x1bN\nEEN\x07\x01\x01\x0b\x00&amp;FD\x16\x01RZ\x000\x0eR\x04L\x05FY\n\x03E\x11\x18\x01N\x01OE\x05\x00EG\x0f\x19\x17G\x0c\x1aSZ&#x27;, b&#x27;O\x00 \x12\x0cY\x1c\x01E\x02E\x1f\x0c\n\n\x11RI\x03\x16ED\x11H\x11\x06EiS\x10\x00\x1cJX\x00\x00\r\x1d\x16I\x07\x01\x00\x1c\x19\x10\x00Y\n\x17\x00SE\r\x1d\x01\x00\x16\x03\x07\x00\x02\x1d\x1dI&#x27;, b&#x27;\x00U9FY\x16\x1a\x07\x00\x17\x04\x1f\x16M\x11\nRT\x05\x00\x0cS\x15\x06\x01ND&amp;E\x17\x01ISTG\x06\x15R\x0cNEFA\x0b\x12E\x05\x18\x03\x05ET\r\x1e\x1c\x10G\x0eO\x1b\x13IT\x00Z&#x27;, b&#x27;EPi\x04YY\x1c\x01E\x02KM1\x05\x07\x17\x17\x07\x1eEBOT\x1b\x10\x00\x00=H\x01\x1d\x0b\x0bTN\x0cA\x1f\nO\x07J\x00\x0b\x19E\x16\x10\x1d\x0b\x06T\x0c\x03\x1dI\x00\x08\x00R\x14\x00\x1a\x00K&#x27;, b&#x27;\x00O/FT\x10\x02\x10\x0eR/\x18\x16\x19B\x03\x1bN\x08E[H\x1d\x1c\x00NS(N\x00O\x1dP\x1dR\x0f\x08\x1c\x02\x00\x1c\x16\x00\x0c\x18\x11\x1dY\x1b\x06\x00\x00\x16\x07\nEL\x0f\x04\x17G\x15\x01\x1fX&#x27;, b&quot;ER \x1cE\x1dO\x17O\x1c\x00\x1eKM6\r\x13TJ\x16\x0cT\x1c\rE\x05I&#x27;DD\x00\x08\x07\x07A\r\x05\x01\x11O\x1b\x0b\x00\x1c\x19\x10R\x17\n\x0b\x01\x00\x11\x03S\x0cM\x07\x08\x1b\t\x00ZSo&quot;, b&#x27;NDi\tN\x1a\nUT\x1a\x00M\x16\x19\r\x17\x1f\x00\x04\x16\x0cO\x02\r\x17B\x000O\x11O\x19H\x1a\x07\x17A\x00\x00M\x0c\x0bB\x00\x04E\x1a\x16\x18N\x1cO\x10L\x1e\x04D\x03O\x1b\x13E\x00\x1b\\&#x27;, b&#x27;OU.\x0e\x0cY\x07\x1aWR\x1c\x02\x10M\x0f\x04\x1cA\n\x00H\x00\x00\x07E\x1dU;V\r\x19\x0b\tTy\x0c\x14R\x12O\x07ATE\x13\x13\x17\x17O\x0c\x00\x00\x16\x19\x01\x00\x0cF\x18\x1a\x02\x11\x1c\x16\\&#x27;, b&#x27;\x00T!\x03\x00\n\x1b\x1aR\x1fE\x04\x16M\x10\x00\x13L\x01\x1c\x0cO\x02\r\x17@\x00\x0bU\x10O\x01I\x11\x00\x17\t\x1b\x0bGI\x0fSE\x15\x00\x00\r\x0e\x07\x0b\x0eE;\x1b\x00NF\x16\x1d\x12E\x17\x1cC&#x27;, b&#x27;E\x00&amp;\x13TY\x00\x13\x00\x06\r\x08E\x1e\x16\n\x00MAEUO\x01H\x12\x01NnTD\r\x0b\x07\x00H\x06A\x01\x04M\x0cFP\x00\x04\x16\x1d\x17O\x19\rOE\x1b\x12\tK\x03\x0bR\x0e\x0bZSz&#x27;]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Crypto.Util.strxor <span class="keyword">as</span> xo</span><br><span class="line"><span class="keyword">import</span> libnum, codecs, numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isChr</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) &lt;= x <span class="keyword">and</span> x &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;z&#x27;</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) &lt;= x <span class="keyword">and</span> x &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;Z&#x27;</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">infer</span>(<span class="params">index, pos</span>):</span><br><span class="line">    <span class="keyword">if</span> msg[index, pos] != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    msg[index, pos] = <span class="built_in">ord</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(c)):</span><br><span class="line">        <span class="keyword">if</span> x != index:</span><br><span class="line">            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ <span class="built_in">ord</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">know</span>(<span class="params">index, pos, ch</span>):</span><br><span class="line">    msg[index, pos] = <span class="built_in">ord</span>(ch)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(c)):</span><br><span class="line">        <span class="keyword">if</span> x != index:</span><br><span class="line">            msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ <span class="built_in">ord</span>(ch)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dat = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getSpace</span>():</span><br><span class="line">    <span class="keyword">for</span> index, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(c):</span><br><span class="line">        res = [xo.strxor(x, y) <span class="keyword">for</span> y <span class="keyword">in</span> c <span class="keyword">if</span> x!=y]</span><br><span class="line">        f = <span class="keyword">lambda</span> pos: <span class="built_in">len</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(isChr, [s[pos] <span class="keyword">for</span> s <span class="keyword">in</span> res])))</span><br><span class="line">        cnt = [f(pos) <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x))]</span><br><span class="line">        <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">            dat.append((f(pos), index, pos))</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里传密文</span></span><br><span class="line"><span class="comment"># c = [codecs.decode(x.strip().encode(), &#x27;hex&#x27;) for x in open(&#x27;Problem.txt&#x27;, &#x27;r&#x27;).readlines()]</span></span><br><span class="line">c = []</span><br><span class="line">msg = np.zeros([<span class="built_in">len</span>(c), <span class="built_in">len</span>(c[<span class="number">0</span>])], dtype=<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">getSpace()</span><br><span class="line"></span><br><span class="line">dat = <span class="built_in">sorted</span>(dat)[::-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> w, index, pos <span class="keyword">in</span> dat:</span><br><span class="line">    infer(index, pos)</span><br><span class="line"></span><br><span class="line"><span class="comment">#know(10, 21, &#x27;y&#x27;)	#如果需要修正， 传入所在被改字母所在行和列，再输入替代的字母,例如alwa s 改为always</span></span><br><span class="line"><span class="comment">#know(8, 14, &#x27;n&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>.join([<span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> x]) <span class="keyword">for</span> x <span class="keyword">in</span> msg]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#key = xo.strxor(c[0], &#x27;&#x27;.join([chr(c) for c in msg[0]]).encode())</span></span><br><span class="line"><span class="comment">#print(key)</span></span><br></pre></td></tr></table></figure>

<p>这里是未修正的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sometimes fate is like a small tand6torm that keeps changing dir1</span><br><span class="line">ctions. Flag is NowUKnowMTP. Yor ch$nge direction but the sandst;</span><br><span class="line">rm chases you. You turn again, eut 1he storm adjusts. Over and o&quot;</span><br><span class="line">er you play this out, like some&#x27;omi+ous dance with death just be2</span><br><span class="line">ore dawn. Why? Because this stoum i6n&#x27;t something that blew in f&amp;</span><br><span class="line">om far away, something that has&#x27;not-ing to do with you. This sto&amp;</span><br><span class="line">m is you. Something inside of yhu. o all you can do is give in  </span><br><span class="line">o it, step right inside the stoum, &amp;losing your eyes and pluggin3</span><br><span class="line"> up your ears so the sand doesn t g t in, and walk through it, s </span><br><span class="line">ep by step. There&#x27;s no sun therb, n* moon, no direction, no sens1</span><br><span class="line"> of time. Just fine white sand twir)ing up into the sky like pul&quot;</span><br><span class="line">erized bones. That&#x27;s the kind oa sa+dstorm you need to imagine. </span><br><span class="line">nd once the storm is over, you pon&#x27;1 remember how you made it th&amp;</span><br><span class="line">ough, how you managed to survivb. Y*u won&#x27;t even be sure, whethe&amp;</span><br><span class="line"> the storm is really over. But hne 1hing is certain. When you co9</span><br><span class="line">e out of the storm, you won&#x27;t bb th  same person who walked in.</span><br></pre></td></tr></table></figure>

<p>修正后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sometimes fate is like a small tandstorm that keeps changing dir1</span><br><span class="line">ctions. Flag is NowUKnowMTP. Yor change direction but the sandst;</span><br><span class="line">rm chases you. You turn again, eut the storm adjusts. Over and o&quot;</span><br><span class="line">er you play this out, like some&#x27;ominous dance with death just be2</span><br><span class="line">ore dawn. Why? Because this stoum isn&#x27;t something that blew in f&amp;</span><br><span class="line">om far away, something that has&#x27;nothing to do with you. This sto&amp;</span><br><span class="line">m is you. Something inside of yhu. So all you can do is give in</span><br><span class="line">o it, step right inside the stoum, closing your eyes and pluggin3</span><br><span class="line"> up your ears so the sand doesn t get in, and walk through it, s</span><br><span class="line">ep by step. There&#x27;s no sun therb, no moon, no direction, no sens1</span><br><span class="line"> of time. Just fine white sand twirling up into the sky like pul&quot;</span><br><span class="line">erized bones. That&#x27;s the kind oa sandstorm you need to imagine. </span><br><span class="line">nd once the storm is over, you pon&#x27;t remember how you made it th&amp;</span><br><span class="line">ough, how you managed to survivb. You won&#x27;t even be sure, whethe&amp;</span><br><span class="line"> the storm is really over. But hne thing is certain. When you co9</span><br><span class="line">e out of the storm, you won&#x27;t bb the same person who walked in.</span><br></pre></td></tr></table></figure>

<p><code>flag&#123;NowUKnowMTP&#125;</code></p>
]]></content>
      <categories>
        <category>现代密码-流密码</category>
      </categories>
      <tags>
        <tag>现代密码</tag>
        <tag>流密码</tag>
        <tag>MTP</tag>
      </tags>
  </entry>
  <entry>
    <title>LCG</title>
    <url>/2023/07/05/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81-LCG/</url>
    <content><![CDATA[<p>江畔何人初见月？江月何年初照人？</p>
<span id="more"></span>

<p><strong>记录笔者学习lcg的过程</strong></p>
<h1 id="lcg-线性同余随机数生成器"><a href="#lcg-线性同余随机数生成器" class="headerlink" title="lcg(线性同余随机数生成器)"></a>lcg(线性同余随机数生成器)</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>很简单，原理就是下面这个公式：</strong><br>$$<br>X_{n+1} \equiv aX_n+b (mod \quad m)<br>$$</p>
<p>$$<br>其中,m表示模数,(m&gt;0)<br>$$</p>
<p>$$<br>a表示系数,(0&lt;a&lt;m)<br>$$</p>
<p>$$<br>b表示增量,(0\le b &lt;m)<br>$$</p>
<p>$$<br>X_0表示原始值，也叫种子,(0 \le X_0 &lt; m)<br>$$</p>
<p><strong>通过原始关系，可以推出以下公式：</strong><br>$$<br>\because X_{n+1} \equiv aX_n+b (mod \quad m)<br>$$</p>
<p>$$<br>\therefore aX_n \equiv X_{n+1}-b (mod \quad  m)<br>$$</p>
<p>$$<br>得到公式①:X_n \equiv a^{-1}(X_{n+1}-b)(mod \quad m)<br>$$</p>
<p><img src="/../../images/lcg/0.png"><br>$$<br>\therefore X_{n+2}-X_{n+1} \equiv a(X_{n+1}-X_n)(mod \quad m)<br>$$</p>
<p>$$<br>得到公式②:a \equiv (X_{n+1}-X_n)^{-1}(X_{n+2}-X_{n+1})(mod \quad m)<br>$$</p>
<p>$$<br>由X_{n+1} \equiv aX_n+b (mod \quad m)<br>$$</p>
<p>$$<br>移项得公式③：b \equiv X_{n+1}-aX_n(mod \quad m)<br>$$</p>
<p><strong>公式4如下</strong><br>$$<br>令t_n &#x3D; X_{n+1}-X_n<br>$$</p>
<p>$$<br>\therefore t_n \equiv a(X_n+b)-a(X_{n-1}+b)(mod \quad m)<br>$$</p>
<p>$$<br>即t_n \equiv a(X_n-X_{n-1})(mod \quad m)<br>$$</p>
<p>$$<br>\therefore t_n \equiv at_{n-1}(mod \quad m)<br>$$</p>
<p>$$<br>又\because t_{n+1}t_{n-1} \equiv a^2t_{n-1}×t_{n-1} \equiv(t_n)^2(mod \quad m)<br>$$</p>
<p>$$<br>\therefore t_{n+1}t_{n-1}-(t_n)^2 \equiv 0 (mod \quad m)<br>$$</p>
<p>$$<br>令T_n &#x3D;t_{n+1}t_{n-1}-(t_n)^2,则T_{n-1}&#x3D;t_nt_{n-2}-(t_{n-1})^2<br>$$</p>
<p>$$<br>\therefore T_n &#x3D; k_1m,T_{n-1} &#x3D; k_2m<br>$$</p>
<p>$$<br>\therefore m &#x3D; gcd(T_n,T_{n-1})<br>$$</p>
<p>其实上式求的还是$km$，只不过这个k很小</p>
<h2 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">flag = b&#x27;Spirit&#123;***********************&#125;&#x27;</span><br><span class="line"></span><br><span class="line">plaintext = bytes_to_long(flag)</span><br><span class="line">length = plaintext.bit_length()</span><br><span class="line"></span><br><span class="line">a = getPrime(length)</span><br><span class="line">b = getPrime(length)</span><br><span class="line">n = getPrime(length)</span><br><span class="line"></span><br><span class="line">seed = 33477128523140105764301644224721378964069</span><br><span class="line">print(&quot;seed = &quot;,seed)</span><br><span class="line">for i in range(10):</span><br><span class="line">    seed = (a*seed+b)%n</span><br><span class="line">ciphertext = seed^plaintext</span><br><span class="line">print(&quot;a = &quot;,a)</span><br><span class="line">print(&quot;b = &quot;,b)</span><br><span class="line">print(&quot;n = &quot;,n)</span><br><span class="line">print(&quot;c = &quot;,ciphertext)</span><br><span class="line"></span><br><span class="line"># seed =  33477128523140105764301644224721378964069</span><br><span class="line"># a =  216636540518719887613942270143367229109002078444183475587474655399326769391</span><br><span class="line"># b =  186914533399403414430047931765983818420963789311681346652500920904075344361</span><br><span class="line"># n =  155908129777160236018105193822448288416284495517789603884888599242193844951</span><br><span class="line"># c =  209481865531297761516458182436122824479565806914713408748457524641378381493</span><br></pre></td></tr></table></figure>

<p><strong>求出循环后的seed，然后和ciphertext异或即可得到flag</strong></p>
<p><strong>这道题已经给出系数a，增量b，模数n，很容易求出最后的seed</strong></p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a =  <span class="number">216636540518719887613942270143367229109002078444183475587474655399326769391</span></span><br><span class="line">b =  <span class="number">186914533399403414430047931765983818420963789311681346652500920904075344361</span></span><br><span class="line">n =  <span class="number">155908129777160236018105193822448288416284495517789603884888599242193844951</span></span><br><span class="line">seed = <span class="number">33477128523140105764301644224721378964069</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    seed = (a*seed + b)%n</span><br><span class="line"></span><br><span class="line">c = <span class="number">209481865531297761516458182436122824479565806914713408748457524641378381493</span></span><br><span class="line">m = c^seed</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Spirit&#123;0ops!___you_know__LCG!!&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="例题2-已知后项求前项"><a href="#例题2-已知后项求前项" class="headerlink" title="例题2(已知后项求前项)"></a>例题2(已知后项求前项)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">flag = b&#x27;Spirit&#123;*****************************&#125;&#x27;</span><br><span class="line"></span><br><span class="line">plaintext = bytes_to_long(flag)</span><br><span class="line">length = plaintext.bit_length()</span><br><span class="line"></span><br><span class="line">a = getPrime(length)</span><br><span class="line">b = getPrime(length)</span><br><span class="line">n = getPrime(length)</span><br><span class="line"></span><br><span class="line">seed = plaintext</span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    seed = (a*seed+b)%n</span><br><span class="line">ciphertext = seed</span><br><span class="line"></span><br><span class="line">print(&quot;a = &quot;,a)</span><br><span class="line">print(&quot;b = &quot;,b)</span><br><span class="line">print(&quot;n = &quot;,n)</span><br><span class="line">print(&quot;c = &quot;,ciphertext)</span><br><span class="line"></span><br><span class="line"># a =  59398519837969938359106832224056187683937568250770488082448642852427682484407513407602969</span><br><span class="line"># b =  32787000674666987602016858366912565306237308217749461581158833948068732710645816477126137</span><br><span class="line"># n =  43520375935212094874930431059580037292338304730539718469760580887565958566208139467751467</span><br><span class="line"># c =  8594514452808046357337682911504074858048299513743867887936794439125949418153561841842276</span><br></pre></td></tr></table></figure>

<p><strong>应用公式①，已知后一项推出前项</strong></p>
<p><strong>这道题我们知道X9，系数，增量，模数，要求X0</strong></p>
<p><strong>首先求a模n的逆元，然后就可以求出前项</strong></p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">a =  <span class="number">59398519837969938359106832224056187683937568250770488082448642852427682484407513407602969</span></span><br><span class="line">b =  <span class="number">32787000674666987602016858366912565306237308217749461581158833948068732710645816477126137</span></span><br><span class="line">n =  <span class="number">43520375935212094874930431059580037292338304730539718469760580887565958566208139467751467</span></span><br><span class="line">c =  <span class="number">8594514452808046357337682911504074858048299513743867887936794439125949418153561841842276</span></span><br><span class="line"></span><br><span class="line">Ani = gmpy2.invert(a,n)</span><br><span class="line">seed = c</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    seed = Ani*(seed-b) % n</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(seed))</span><br><span class="line"><span class="comment"># Spirit&#123;Orzzz__number_the0ry_master!!&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="例题3-求增量b"><a href="#例题3-求增量b" class="headerlink" title="例题3(求增量b)"></a>例题3(求增量b)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">flag = b&#x27;Spirit&#123;*********************&#125;&#x27;</span><br><span class="line">plaintext = bytes_to_long(flag)</span><br><span class="line">length = plaintext.bit_length()</span><br><span class="line"></span><br><span class="line">a = getPrime(length)</span><br><span class="line">seed = getPrime(length)</span><br><span class="line">n = getPrime(length)</span><br><span class="line"></span><br><span class="line">b = plaintext</span><br><span class="line"></span><br><span class="line">output = []</span><br><span class="line">for i in range(10):</span><br><span class="line">    seed = (a*seed+b)%n</span><br><span class="line">    output.append(seed)</span><br><span class="line">ciphertext = seed</span><br><span class="line"></span><br><span class="line">print(&quot;a = &quot;,a)</span><br><span class="line">print(&quot;n = &quot;,n)</span><br><span class="line">print(&quot;output1 = &quot;,output[6])</span><br><span class="line">print(&quot;output2 = &quot;,output[7])</span><br><span class="line"></span><br><span class="line"># a =  3227817955364471534349157142678648291258297398767210469734127072571531</span><br><span class="line"># n =  2731559135349690299261470294200742325021575620377673492747570362484359</span><br><span class="line"># output1 =  56589787378668192618096432693925935599152815634076528548991768641673</span><br><span class="line"># output2 =  2551791066380515596393984193995180671839531603273409907026871637002460</span><br></pre></td></tr></table></figure>

<p><strong>这道题需要我们求增量b</strong></p>
<p>用公式③</p>
<p><img src="/../../images/lcg/4.png"></p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a =  <span class="number">3227817955364471534349157142678648291258297398767210469734127072571531</span></span><br><span class="line">n =  <span class="number">2731559135349690299261470294200742325021575620377673492747570362484359</span></span><br><span class="line">output1 =  <span class="number">56589787378668192618096432693925935599152815634076528548991768641673</span></span><br><span class="line">output2 =  <span class="number">2551791066380515596393984193995180671839531603273409907026871637002460</span></span><br><span class="line"></span><br><span class="line">b = output2 - a*output1 % n</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(b))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Spirit&#123;Y0u_@r3_g00d_at__math&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="例题4-未知a-b求seed"><a href="#例题4-未知a-b求seed" class="headerlink" title="例题4(未知a,b求seed)"></a>例题4(未知a,b求seed)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">flag = b&#x27;Spirit&#123;********************************&#125;&#x27;</span><br><span class="line"></span><br><span class="line">plaintext = bytes_to_long(flag)</span><br><span class="line">length = plaintext.bit_length()</span><br><span class="line"></span><br><span class="line">a = getPrime(length)</span><br><span class="line">b = getPrime(length)</span><br><span class="line">n = getPrime(length)</span><br><span class="line"></span><br><span class="line">seed = plaintext</span><br><span class="line">output = []</span><br><span class="line">for i in range(10):</span><br><span class="line">    seed = (a*seed+b)%n</span><br><span class="line">    output.append(seed)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&quot;n = &quot;,n)</span><br><span class="line">print(&quot;output = &quot;,output)</span><br><span class="line"># n =  714326667532888136341930300469812503108568533171958701229258381897431946521867367344505142446819</span><br><span class="line"># output =  [683884150135567569054700309393082274015273418755015984639210872641629102776137288905334345358223, 285126221039239401347664578761309935673889193236512702131697050766454881029340147180552409870425, 276893085775448203669487661735680485319995668779836512706851431217470824660349740546793492847822, 670041467944152108349892479463033808393249475608933110640580388877206700116661070302382578388629, 122640993538161410588195475312610802051543155060328971488277224112081166784263153107636108815824, 695403107966797625391061914491496301998976621394944936827202540832952594905520247784142392337171, 108297989103402878258100342544600235524390749601427490182149765480916965811652000881230504838949, 3348901603647903020607356217291999644800579775392251732059562193080862524671584235203807354488, 632094372828241320671255647451901056399237760301503199444470380543753167478243100611604222284853, 54758061879225024125896909645034267106973514243188358677311238070832154883782028437203621709276]</span><br></pre></td></tr></table></figure>

<p><strong>这道题需要求初始值，但是题目没给出a和b的值</strong></p>
<p><img src="/../../images/lcg/5.png"></p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">n =  <span class="number">714326667532888136341930300469812503108568533171958701229258381897431946521867367344505142446819</span></span><br><span class="line">output =  [<span class="number">683884150135567569054700309393082274015273418755015984639210872641629102776137288905334345358223</span>, <span class="number">285126221039239401347664578761309935673889193236512702131697050766454881029340147180552409870425</span>, <span class="number">276893085775448203669487661735680485319995668779836512706851431217470824660349740546793492847822</span>, <span class="number">670041467944152108349892479463033808393249475608933110640580388877206700116661070302382578388629</span>, <span class="number">122640993538161410588195475312610802051543155060328971488277224112081166784263153107636108815824</span>, <span class="number">695403107966797625391061914491496301998976621394944936827202540832952594905520247784142392337171</span>, <span class="number">108297989103402878258100342544600235524390749601427490182149765480916965811652000881230504838949</span>, <span class="number">3348901603647903020607356217291999644800579775392251732059562193080862524671584235203807354488</span>, <span class="number">632094372828241320671255647451901056399237760301503199444470380543753167478243100611604222284853</span>, <span class="number">54758061879225024125896909645034267106973514243188358677311238070832154883782028437203621709276</span>]</span><br><span class="line"></span><br><span class="line">p1 = output[<span class="number">9</span>]-output[<span class="number">8</span>]</span><br><span class="line">p2 = output[<span class="number">8</span>]-output[<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">Ani = gmpy2.invert(p2,n)</span><br><span class="line">a = p1 * Ani % n</span><br><span class="line"></span><br><span class="line">b = (output[<span class="number">9</span>] - a*output[<span class="number">8</span>]) % n</span><br><span class="line"></span><br><span class="line">ani = gmpy2.invert(a,n)</span><br><span class="line"></span><br><span class="line">m = ani * (output[<span class="number">0</span>]-b) % n</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Spirit&#123;Gr3at__J0b!_You_can_be___better!&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="例题5-未知a-b-n求seed）"><a href="#例题5-未知a-b-n求seed）" class="headerlink" title="例题5(未知a,b,n求seed）"></a>例题5(未知a,b,n求seed）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">flag = b&#x27;Spirit&#123;****************************************&#125;&#x27;</span><br><span class="line"></span><br><span class="line">plaintext = bytes_to_long(flag)</span><br><span class="line">length = plaintext.bit_length()</span><br><span class="line"></span><br><span class="line">a = getPrime(length)</span><br><span class="line">b = getPrime(length)</span><br><span class="line">n = getPrime(length)</span><br><span class="line"></span><br><span class="line">seed = plaintext</span><br><span class="line">output = []</span><br><span class="line">for i in range(10):</span><br><span class="line">    seed = (a*seed+b)%n</span><br><span class="line">    output.append(seed)</span><br><span class="line"></span><br><span class="line">print(&quot;output = &quot;,output)</span><br><span class="line"># output =  [9997297986272510947766344959498975323136012075787120721424325775003840341552673589487134830298427997676238039214108, 4943092972488023184271739094993470430272327679424224016751930100362045115374960494124801675393555642497051610643836, 6774612894247319645272578624765063875876643849415903973872536662648051668240882405640569448229188596797636795502471, 9334780454901460926052785252362305555845335155501888087843525321238695716687151256717815518958670595053951084051571, 2615136943375677027346821049033296095071476608523371102901038444464314877549948107134114941301290458464611872942706, 11755491858586722647182265446253701221615594136571038555321378377363341368427070357031882725576677912630050307145062, 7752070270905673490804344757589080653234375679657568428025599872155387643476306575613147681330227562712490805492345, 8402957532602451691327737154745340793606649602871190615837661809359377788072256203797817090151599031273142680590748, 2802440081918604590502596146113670094262600952020687184659605307695151120589816943051322503094363578916773414004662, 5627226318035765837286789021891141596394835871645925685252241680021740265826179768429792645576780380635014113687982]</span><br></pre></td></tr></table></figure>

<p><strong>这道题连模数都没给</strong></p>
<p><strong>首先求出模，然后求a，再求b</strong></p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">output =  [<span class="number">9997297986272510947766344959498975323136012075787120721424325775003840341552673589487134830298427997676238039214108</span>, <span class="number">4943092972488023184271739094993470430272327679424224016751930100362045115374960494124801675393555642497051610643836</span>, <span class="number">6774612894247319645272578624765063875876643849415903973872536662648051668240882405640569448229188596797636795502471</span>, <span class="number">9334780454901460926052785252362305555845335155501888087843525321238695716687151256717815518958670595053951084051571</span>, <span class="number">2615136943375677027346821049033296095071476608523371102901038444464314877549948107134114941301290458464611872942706</span>, <span class="number">11755491858586722647182265446253701221615594136571038555321378377363341368427070357031882725576677912630050307145062</span>, <span class="number">7752070270905673490804344757589080653234375679657568428025599872155387643476306575613147681330227562712490805492345</span>, <span class="number">8402957532602451691327737154745340793606649602871190615837661809359377788072256203797817090151599031273142680590748</span>, <span class="number">2802440081918604590502596146113670094262600952020687184659605307695151120589816943051322503094363578916773414004662</span>, <span class="number">5627226318035765837286789021891141596394835871645925685252241680021740265826179768429792645576780380635014113687982</span>]</span><br><span class="line"></span><br><span class="line">t = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(output)):</span><br><span class="line">    t.append(output[i]-output[i-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">T = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(t)-<span class="number">1</span>):</span><br><span class="line">    T.append(t[i+<span class="number">1</span>]*t[i-<span class="number">1</span>] - t[i]**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">m = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(T)-<span class="number">1</span>):</span><br><span class="line">    mm = gmpy2.gcd(T[i],T[i+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> isPrime(mm):</span><br><span class="line">        m.append(<span class="built_in">int</span>(mm))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line">            <span class="keyword">if</span> isPrime(mm // i):</span><br><span class="line">                mm = mm // i</span><br><span class="line">                m.append(<span class="built_in">int</span>(mm))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"><span class="comment">#print(m)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">    <span class="keyword">if</span> isPrime(i):</span><br><span class="line">        a = gmpy2.invert(t[<span class="number">0</span>],i) * t[<span class="number">1</span>] % i</span><br><span class="line">        b = output[<span class="number">1</span>] - a*output[<span class="number">0</span>] % i</span><br><span class="line">        a_ = gmpy2.invert(a,i)</span><br><span class="line"></span><br><span class="line">        seed = a_ * (output[<span class="number">0</span>]-b) % i</span><br><span class="line">        flag = long_to_bytes(seed)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;Spirit&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<p>对于同一个lcg，其$a,b$是一样的，通过哪两组数据都能求出$a,b$</p>
<p>官方wp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">a,b</span>): </span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>): </span><br><span class="line">        <span class="keyword">return</span> a </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="keyword">return</span> gcd(b,a%b) </span><br><span class="line">s =  [<span class="number">9997297986272510947766344959498975323136012075787120721424325775003840341552673589487134830298427997676238039214108</span>, <span class="number">4943092972488023184271739094993470430272327679424224016751930100362045115374960494124801675393555642497051610643836</span>, <span class="number">6774612894247319645272578624765063875876643849415903973872536662648051668240882405640569448229188596797636795502471</span>, <span class="number">9334780454901460926052785252362305555845335155501888087843525321238695716687151256717815518958670595053951084051571</span>, <span class="number">2615136943375677027346821049033296095071476608523371102901038444464314877549948107134114941301290458464611872942706</span>, <span class="number">11755491858586722647182265446253701221615594136571038555321378377363341368427070357031882725576677912630050307145062</span>, <span class="number">7752070270905673490804344757589080653234375679657568428025599872155387643476306575613147681330227562712490805492345</span>, <span class="number">8402957532602451691327737154745340793606649602871190615837661809359377788072256203797817090151599031273142680590748</span>, <span class="number">2802440081918604590502596146113670094262600952020687184659605307695151120589816943051322503094363578916773414004662</span>, <span class="number">5627226318035765837286789021891141596394835871645925685252241680021740265826179768429792645576780380635014113687982</span>]</span><br><span class="line">t = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    t.append(s[i]-s[i-<span class="number">1</span>]) </span><br><span class="line">all_n = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    all_n.append(gcd((t[i+<span class="number">1</span>]*t[i-<span class="number">1</span>]-t[i]*t[i]), (t[i+<span class="number">2</span>]*t[i]-t[i+<span class="number">1</span>]*t[i+<span class="number">1</span>]))) </span><br><span class="line"></span><br><span class="line">MMI = <span class="keyword">lambda</span> A, n,s=<span class="number">1</span>,t=<span class="number">0</span>,N=<span class="number">0</span>: (n &lt; <span class="number">2</span> <span class="keyword">and</span> t%N <span class="keyword">or</span> MMI(n, A%n, t, s-A//n*t, N <span class="keyword">or</span> n),-<span class="number">1</span>)[n&lt;<span class="number">1</span>] <span class="comment">#逆元计算</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> all_n:</span><br><span class="line">    n=<span class="built_in">abs</span>(n)</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    a=(s[<span class="number">2</span>]-s[<span class="number">1</span>])*MMI((s[<span class="number">1</span>]-s[<span class="number">0</span>]),n)%n</span><br><span class="line">    ani=MMI(a,n)</span><br><span class="line">    b=(s[<span class="number">1</span>]-a*s[<span class="number">0</span>])%n</span><br><span class="line">    seed = (ani*(s[<span class="number">0</span>]-b))%n</span><br><span class="line">    plaintext=seed</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(plaintext))</span><br></pre></td></tr></table></figure>



<h2 id="例题6-求出的是k倍模数"><a href="#例题6-求出的是k倍模数" class="headerlink" title="例题6(求出的是k倍模数)"></a>例题6(求出的是k倍模数)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LCG</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, seed, a, b, m</span>):</span><br><span class="line">        self.seed = seed  <span class="comment"># 初始种子</span></span><br><span class="line">        self.a = a  <span class="comment"># 乘数</span></span><br><span class="line">        self.b = b  <span class="comment"># 增量</span></span><br><span class="line">        self.m = m  <span class="comment"># 模数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self</span>):</span><br><span class="line">        self.seed = self.a * (self.seed - self.b) % self.m</span><br><span class="line">        <span class="keyword">return</span> self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(<span class="number">256</span>), getPrime(<span class="number">256</span>), getPrime(<span class="number">256</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(getPrime(<span class="number">16</span>)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lcg.generate())</span><br><span class="line"><span class="built_in">print</span>(lcg.generate())</span><br><span class="line"><span class="built_in">print</span>(lcg.generate())</span><br><span class="line"><span class="built_in">print</span>(lcg.generate())</span><br><span class="line"><span class="built_in">print</span>(lcg.generate())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">57648351648792284446777383544515312078150027665462203747924668509833442797796</span></span><br><span class="line"><span class="string">90378879763416486117626477831653213918315023665514305359005153448529276829825</span></span><br><span class="line"><span class="string">21826576702665114807208181233864324586557058567478767825970403161758214940301</span></span><br><span class="line"><span class="string">47594460970742467761038407996122637655856234121180714918606854365482948918701</span></span><br><span class="line"><span class="string">11871076497267630136796123094001159466754095580273018347962555675375123133730</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">output = [<span class="number">57648351648792284446777383544515312078150027665462203747924668509833442797796</span>,</span><br><span class="line"><span class="number">90378879763416486117626477831653213918315023665514305359005153448529276829825</span>,</span><br><span class="line"><span class="number">21826576702665114807208181233864324586557058567478767825970403161758214940301</span>,</span><br><span class="line"><span class="number">47594460970742467761038407996122637655856234121180714918606854365482948918701</span>,</span><br><span class="line"><span class="number">11871076497267630136796123094001159466754095580273018347962555675375123133730</span>]</span><br><span class="line"></span><br><span class="line">t = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(output)):</span><br><span class="line">    t.append(output[i]-output[i-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">T = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(t)-<span class="number">1</span>):</span><br><span class="line">    T.append(t[i+<span class="number">1</span>]*t[i-<span class="number">1</span>] - t[i]**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">m = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(T)-<span class="number">1</span>):</span><br><span class="line">    mm = gmpy2.gcd(T[i],T[i+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> isPrime(mm):</span><br><span class="line">        m.append(<span class="built_in">int</span>(mm))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line">            <span class="keyword">if</span> isPrime(mm // i):</span><br><span class="line">                mm = mm // i</span><br><span class="line">                m.append(<span class="built_in">int</span>(mm))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">    a = gmpy2.invert(t[<span class="number">0</span>],i) * t[<span class="number">1</span>] % i</span><br><span class="line">    b = output[<span class="number">1</span>] - a*output[<span class="number">0</span>] % i</span><br><span class="line">    a_ = gmpy2.invert(a,i)</span><br><span class="line"></span><br><span class="line">    seed = a_ * (output[<span class="number">0</span>]-b) % i</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">16</span>):</span><br><span class="line">        seed = a_ * (seed - b) % i</span><br><span class="line">        flag = long_to_bytes(seed)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;NSSCTF&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>



<h2 id="例题7-输出X0，X2，X4，X6，X8"><a href="#例题7-输出X0，X2，X4，X6，X8" class="headerlink" title="例题7(输出X0，X2，X4，X6，X8)"></a>例题7(输出X0，X2，X4，X6，X8)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LCG</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, seed, a, b, m</span>):</span><br><span class="line">        self.seed = seed  <span class="comment"># 初始种子</span></span><br><span class="line">        self.a = a  <span class="comment"># 乘数</span></span><br><span class="line">        self.b = b  <span class="comment"># 增量</span></span><br><span class="line">        self.m = m  <span class="comment"># 模数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self</span>):</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        self.seed = (self.a * self.seed + self.b) % self.m</span><br><span class="line">        <span class="keyword">return</span> self.seed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lcg = LCG(bytes_to_long(flag), getPrime(<span class="number">255</span>), getPrime(<span class="number">255</span>), getPrime(<span class="number">256</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(getPrime(<span class="number">16</span>)):</span><br><span class="line">    lcg.generate()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lcg.generate())</span><br><span class="line"><span class="built_in">print</span>(lcg.generate())</span><br><span class="line"><span class="built_in">print</span>(lcg.generate())</span><br><span class="line"><span class="built_in">print</span>(lcg.generate())</span><br><span class="line"><span class="built_in">print</span>(lcg.generate())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">25445927935559969212648839062255651208014967526951331344342413906051118248013</span></span><br><span class="line"><span class="string">81572970970116732975667604095930675262596098540738447440566868976253289440293</span></span><br><span class="line"><span class="string">6956793925625110803779114150160476498676179542815207353218944386232051429289</span></span><br><span class="line"><span class="string">88042506866508011592456777776490262927213783361334741921985316105965255450508</span></span><br><span class="line"><span class="string">5652832125321707726481846809536180176877263519327268361130605456255558285092</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这题给出的数据是$X_1,X_3,X_5,X_7,X_9$隔位输出的</p>
<p>$\because X_{n+1} \equiv aX_n + b \mod m$，$\therefore X_{n+2} \equiv a^2X_n+(a+1)b \mod m$</p>
<p>可以把他当作另外一个系数$a’ &#x3D; a^2,b’&#x3D;(a+1)b$的lcg</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">output = [<span class="number">25445927935559969212648839062255651208014967526951331344342413906051118248013</span>,</span><br><span class="line"><span class="number">81572970970116732975667604095930675262596098540738447440566868976253289440293</span>,</span><br><span class="line"><span class="number">6956793925625110803779114150160476498676179542815207353218944386232051429289</span>,</span><br><span class="line"><span class="number">88042506866508011592456777776490262927213783361334741921985316105965255450508</span>,</span><br><span class="line"><span class="number">5652832125321707726481846809536180176877263519327268361130605456255558285092</span>]</span><br><span class="line">t = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(output)):</span><br><span class="line">    t.append(output[i]-output[i-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">T = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(t)-<span class="number">1</span>):</span><br><span class="line">    T.append(t[i+<span class="number">1</span>]*t[i-<span class="number">1</span>] - t[i]**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">m = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(T)-<span class="number">1</span>):</span><br><span class="line">    mm = gmpy2.gcd(T[i],T[i+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> isPrime(mm):</span><br><span class="line">        m.append(<span class="built_in">int</span>(mm))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line">            <span class="keyword">if</span> isPrime(mm // i):</span><br><span class="line">                mm = mm // i</span><br><span class="line">                m.append(<span class="built_in">int</span>(mm))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">    a = gmpy2.invert(t[<span class="number">0</span>],i) * t[<span class="number">1</span>] % i</span><br><span class="line">    b = output[<span class="number">1</span>] - a*output[<span class="number">0</span>] % i</span><br><span class="line">    a_ = gmpy2.invert(a,i)</span><br><span class="line"></span><br><span class="line">    seed = a_ * (output[<span class="number">0</span>]-b) % i</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">16</span>):</span><br><span class="line">        seed = a_ * (seed - b) % i</span><br><span class="line">        flag = long_to_bytes(seed)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;NSSCTF&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<h2 id="例题8"><a href="#例题8" class="headerlink" title="例题8"></a>例题8</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">flag = b&#x27;Spirit&#123;*****************&#125;&#x27;</span><br><span class="line"></span><br><span class="line">plaintext = bytes_to_long(flag)</span><br><span class="line">length = plaintext.bit_length()</span><br><span class="line"></span><br><span class="line">a = getPrime(length)</span><br><span class="line">b = getPrime(length)</span><br><span class="line">n = getPrime(length)</span><br><span class="line"></span><br><span class="line">seed = plaintext</span><br><span class="line"></span><br><span class="line">output = []</span><br><span class="line">for i in range(10):</span><br><span class="line">    seed = (seed*a+b)%n</span><br><span class="line">    output.append(seed&gt;&gt;64)</span><br><span class="line">print(&quot;a = &quot;,a)</span><br><span class="line">print(&quot;b = &quot;,b)</span><br><span class="line">print(&quot;n = &quot;,n)</span><br><span class="line">print(&quot;output = &quot;,output)</span><br><span class="line"># a =  731111971045863129770849213414583830513204814328949766909151</span><br><span class="line"># b =  456671883153709362919394459405008275757410555181682705944711</span><br><span class="line"># n =  666147691257100304060287710111266554526660232037647662561651</span><br><span class="line"># output =  [16985619148410545083429542035273917746612, 32633736473029292963326093326932585135645, 20531875000321097472853248514822638673918, 37524613187648387324374487657224279011, 21531154020699900519763323600774720747179, 1785016578450326289280053428455439687732, 15859114177482712954359285501450873939895, 10077571899928395052806024133320973530689, 30199391683019296398254401666338410561714, 21303634014034358798100587236618579995634]</span><br></pre></td></tr></table></figure>

<p>已知$X_{n+1} \equiv aX_n + b \mod m$</p>
<p>把$X_n$拆为高位和低位之和，即$X_n &#x3D; H_n+L_n$</p>
<p>于是有$H_{n+1}+L_{n+1} \equiv a(H_n+L_n) + b \mod m$</p>
<p>$\therefore L_{n+1} \equiv aL_n+(aH_n+b-H_{n+1})\mod m$</p>
<p>因为$L_2 \equiv aL_1 + (aH_1+b-H_2) \mod m$</p>
<p>$L_3 \equiv a(aL_1 + aH_1+b-H_2)+aH_2+b-H_3 \mod m$，即$L_3 \equiv a^2L_1+(aH_2+b-H_3+a^2H_1+b-H_2)$</p>
<p>于是能得到$L_i$与$L_1$的关系</p>
<p>则有$L_{i} \equiv A_iL_1 +B_i \mod m$，即$L_{i+1} &#x3D; A_iL_1 + B_i + k_{i}m$</p>
<h1 id="构造格-begin-pmatrix-k-1-k-2-cdots-k-9-L-1-1-end-pmatrix-begin-pmatrix-m-0-cdots-0-0-0-0-m-cdots-0-0-0-vdots-vdots-ddots-vdots-vdots-vdots-0-0-cdots-m-0-0-A-1-A-2-cdots-A-9-1-0-B-1-B-2-cdots-B-9-0-2-64-end-pmatrix"><a href="#构造格-begin-pmatrix-k-1-k-2-cdots-k-9-L-1-1-end-pmatrix-begin-pmatrix-m-0-cdots-0-0-0-0-m-cdots-0-0-0-vdots-vdots-ddots-vdots-vdots-vdots-0-0-cdots-m-0-0-A-1-A-2-cdots-A-9-1-0-B-1-B-2-cdots-B-9-0-2-64-end-pmatrix" class="headerlink" title="构造格$$\begin{pmatrix}k_1 &amp; k_2 &amp;\cdots &amp; k_{9} &amp;L_1 &amp; 1\end{pmatrix}\begin{pmatrix}m &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0\0 &amp; m &amp; \cdots &amp; 0 &amp; 0 &amp; 0\\vdots &amp;\vdots &amp; \ddots &amp; \vdots &amp;\vdots &amp; \vdots\0 &amp; 0 &amp; \cdots &amp;m &amp;0 &amp; 0\A_1 &amp; A_2 &amp;\cdots &amp;A_{9} &amp; 1 &amp; 0\B_1 &amp; B_2 &amp; \cdots &amp;B_{9} &amp;0 &amp; 2^{64}\end{pmatrix}"></a>构造格<br>$$<br>\begin{pmatrix}<br>k_1 &amp; k_2 &amp;\cdots &amp; k_{9} &amp;L_1 &amp; 1<br>\end{pmatrix}<br>\begin{pmatrix}<br>m &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0\<br>0 &amp; m &amp; \cdots &amp; 0 &amp; 0 &amp; 0\<br>\vdots &amp;\vdots &amp; \ddots &amp; \vdots &amp;\vdots &amp; \vdots\<br>0 &amp; 0 &amp; \cdots &amp;m &amp;0 &amp; 0\<br>A_1 &amp; A_2 &amp;\cdots &amp;A_{9} &amp; 1 &amp; 0\<br>B_1 &amp; B_2 &amp; \cdots &amp;B_{9} &amp;0 &amp; 2^{64}<br>\end{pmatrix}</h1><p>\begin{pmatrix}<br>L_2 &amp; L_3 &amp; \cdots &amp;L_{10} &amp; L_1 &amp;2^{64}<br>\end{pmatrix}<br>$$<br>因为$L_i &#x3D; 64bit$，所以最后调一个$2^{64}$</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a =  <span class="number">731111971045863129770849213414583830513204814328949766909151</span></span><br><span class="line">b =  <span class="number">456671883153709362919394459405008275757410555181682705944711</span></span><br><span class="line">m =  <span class="number">666147691257100304060287710111266554526660232037647662561651</span></span><br><span class="line">c =  [<span class="number">0</span>,<span class="number">16985619148410545083429542035273917746612</span>, <span class="number">32633736473029292963326093326932585135645</span>, <span class="number">20531875000321097472853248514822638673918</span>, <span class="number">37524613187648387324374487657224279011</span>, <span class="number">21531154020699900519763323600774720747179</span>, <span class="number">1785016578450326289280053428455439687732</span>, <span class="number">15859114177482712954359285501450873939895</span>, <span class="number">10077571899928395052806024133320973530689</span>, <span class="number">30199391683019296398254401666338410561714</span>, <span class="number">21303634014034358798100587236618579995634</span>]</span><br><span class="line"><span class="comment">#0是seed的高位</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(c)):</span><br><span class="line">    c[i] = c[i] &lt;&lt; <span class="number">64</span></span><br><span class="line"></span><br><span class="line">A = [<span class="number">1</span>]</span><br><span class="line">B = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(c)-<span class="number">1</span>):</span><br><span class="line">    Ai = a*A[i-<span class="number">1</span>] % m</span><br><span class="line">    Bi = (a*B[i-<span class="number">1</span>] + a*c[i]+b-c[i+<span class="number">1</span>]) % m</span><br><span class="line">    A.append(Ai)</span><br><span class="line">    B.append(Bi)</span><br><span class="line"></span><br><span class="line">A = A[<span class="number">1</span>:]</span><br><span class="line">B = B[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">M = Matrix(<span class="number">11</span>,<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    M[i,i] = m</span><br><span class="line">    M[-<span class="number">1</span>,i] = B[i]</span><br><span class="line">    M[-<span class="number">2</span>,i] = A[i]</span><br><span class="line">M[-<span class="number">1</span>,-<span class="number">1</span>] = <span class="number">2</span>^<span class="number">64</span></span><br><span class="line">M[-<span class="number">2</span>,-<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> M.LLL():</span><br><span class="line">    <span class="keyword">if</span> i[-<span class="number">1</span>] == <span class="number">2</span>^<span class="number">64</span>:</span><br><span class="line">        L1 = i[-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">seed1 = c[<span class="number">1</span>] + L1</span><br><span class="line"></span><br><span class="line">inv = gmpy2.invert(a,m)</span><br><span class="line">seed = inv * (seed1 - b) % m</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(seed)))</span><br></pre></td></tr></table></figure>





















]]></content>
      <categories>
        <category>现代密码-流密码</category>
      </categories>
      <tags>
        <tag>现代密码</tag>
        <tag>流密码</tag>
        <tag>LCG</tag>
      </tags>
  </entry>
  <entry>
    <title>LFSR</title>
    <url>/2023/07/12/%E6%B5%81%E5%AF%86%E7%A0%81/%E6%B5%81%E5%AF%86%E7%A0%81-LFSR/</url>
    <content><![CDATA[<p>浅浅学习一下LFSR(线性反馈寄存器)</p>
<p>一分耕耘，一分收获</p>
<span id="more"></span>

<p><strong>记录笔者学习LFSR过程</strong></p>
<p>首先了解一下流密码</p>
<h1 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h1><p>流密码它是以最小单位<strong>比特</strong>作为一次加密、解密的操作元素，利用加密算法进行加密与解密</p>
<ul>
<li>流密码的密钥派生自一个较短的密钥，派生算法通常为一个伪随机数生成算法。</li>
<li>流密码的密钥长度会与明文的长度相同。</li>
</ul>
<p>需要注意的是，流加密目前来说都是对称加密。</p>
<p>伪随机数生成算法生成的序列的随机性越强，明文中的统计特征被覆盖的更好。</p>
<p>流密码加解密非常简单，在已知明文的情况下，可以非常容易地获取密钥流。</p>
<p>流密码的关键在于设计好的<strong>伪随机数生成器</strong>。一般来说，伪随机数生成器的基本构造模块为反馈移位寄存器(LFSR)。</p>
<h1 id="伪随机数生成器"><a href="#伪随机数生成器" class="headerlink" title="伪随机数生成器"></a>伪随机数生成器</h1><p>伪随机数生成器（pseudorandom number generator，PRNG），又称为确定性随机位生成器（deterministic random bit generator，DRBG），是用来生成<strong>接近于绝对随机数序列的数字序列</strong>的算法。一般来说，PRNG 会依赖于一个初始值，也称为种子，来生成对应的伪随机数序列。<strong>只要种子确定了，PRNG 所生成的随机数就是完全确定的，因此其生成的随机数序列并不是真正随机的。</strong></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>目前主要的伪随机数生成器有：</p>
<p>目前通用的伪随机数生成器主要有</p>
<ul>
<li>线性同余生成器，LCG</li>
<li>线性回归发生器</li>
<li><a href="https://en.wikipedia.org/wiki/Mersenne_Twister">Mersenne Twister</a></li>
<li><a href="https://en.wikipedia.org/wiki/Xorshift">xorshift</a> generators</li>
<li><a href="https://en.wikipedia.org/wiki/Well_Equidistributed_Long-period_Linear">WELL</a> family of generators</li>
<li>Linear feedback shift register，LFSR，线性反馈移位寄存器</li>
</ul>
<p>这里学习一下LFSR</p>
<p>以下学习都是建立在他人博客的基础上</p>
<p><a href="https://blog.csdn.net/xiao__1bai/article/details/120392307">(9条消息) CTF中的LFSR考点(一)_lfsr ctf_沐一 · 林的博客-CSDN博客</a></p>
<h1 id="LFSR-线性反馈寄存器"><a href="#LFSR-线性反馈寄存器" class="headerlink" title="LFSR(线性反馈寄存器)"></a>LFSR(线性反馈寄存器)</h1><p><strong>在学习LFSR之前，先了解一下FSR(反馈寄存器)，LFSR是FSR其中一种，另外一种是NFSR(非线性反馈寄存器)</strong></p>
<p>FSR是<strong>流密码</strong>产生<strong>密钥流</strong>的一个重要组成部分，在<strong>GF(2)<strong>上的一个</strong>n级FSR</strong>通常由<strong>n个二元存储器</strong>和<strong>一个反馈函数</strong>组成。</p>
<p><strong>GF(2)指的是有限域2，所以在GF(2)的元素只有0和1</strong></p>
<p>FSR如下图所示：</p>
<p><img src="/../../images/LFSR/0.png"></p>
<p>**如果这里的反馈函数是线性的，就称它为LFSR(线性反馈寄存器)**，此时反馈函数可以表示为<br>$$<br>f(a_1,a_2,a_3,a_4,a_5) &#x3D; c_na_1 \oplus c_{n-1}a_2 \oplus…\oplus c_1a_n\\<br>$$<br>$$<br>其中，c_i表示0或1，\oplus表示异或<br>$$</p>
<p>eg:<br>$$<br>假设一个5级的LFSR，其初始状态(即a_1,a_2,a_3,a_4,a_5这五个单元格里面的值)为<br>$$<br>$$<br>(a_1,a_2,a_3,a_4,a_5)&#x3D;(1,0,0,1,1)<br>$$</p>
<p>$$<br>其反馈函数为：<br>$$</p>
<p>$$<br>f(a_1,a_2,a_3,a_4,a_5) &#x3D; a_4 \oplus a_1<br>$$</p>
<p><strong>整个过程可表示为下面的形式：</strong></p>
<p><img src="/../../images/LFSR/1.png"></p>
<p><strong>之后，会将反馈函数计算的值作为a6放到a5后面，并且把a1输出</strong>，如图：</p>
<p><img src="/../../images/LFSR/0.jpg"><br>$$<br>而a_6 &#x3D; a_4 \oplus a_1 &#x3D; 1 \oplus 1 &#x3D; 0<br>$$</p>
<p>$$<br>由反馈函数我们可以推出<br>$$</p>
<p>$$<br>a_n &#x3D; a_{n-2} \oplus a_{n-5}(n&gt;5)<br>$$</p>
<p>$$<br>通过该函数，我们可以推出剩下的值<br>$$</p>
<p>$$<br>经过计算，发现从32位起，之后的数据和前面数据成周期性变化<br>$$</p>
<p>$$<br>发现5级LFSR的最大周期为2^5-1<br>$$</p>
<p>$$<br>\therefore n级LFSR的最大周期为2^n -1<br>$$</p>
<p><strong>以下例题是建立在理解别人博客的基础上写的：</strong></p>
<p>原：<a href="https://www.anquanke.com/post/id/181811#h2-5">深入分析CTF中的LFSR类题目（一）-安全客 - 安全资讯平台 (anquanke.com)</a></p>
<h1 id="例题1-CISCN2018-oldstreamgame"><a href="#例题1-CISCN2018-oldstreamgame" class="headerlink" title="例题1 CISCN2018 oldstreamgame"></a>例题1 CISCN2018 oldstreamgame</h1><p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag = &quot;flag&#123;xxxxxxxxxxxxxxxx&#125;&quot;</span><br><span class="line">assert flag.startswith(&quot;flag&#123;&quot;)</span><br><span class="line">assert flag.endswith(&quot;&#125;&quot;)</span><br><span class="line">assert len(flag)==14</span><br><span class="line"></span><br><span class="line">def lfsr(R,mask):</span><br><span class="line">    output = (R &lt;&lt; 1) &amp; 0xffffffff</span><br><span class="line">    i=(R&amp;mask)&amp;0xffffffff</span><br><span class="line">    lastbit=0</span><br><span class="line">    while i!=0:</span><br><span class="line">        lastbit^=(i&amp;1)</span><br><span class="line">        i=i&gt;&gt;1</span><br><span class="line">    output^=lastbit </span><br><span class="line">    return (output,lastbit)</span><br><span class="line"></span><br><span class="line">R=int(flag[5:-1],16)</span><br><span class="line">mask = 0b10100100000010000000100010010100</span><br><span class="line"></span><br><span class="line">f=open(&quot;key&quot;,&quot;w&quot;)</span><br><span class="line">for i in range(100):</span><br><span class="line">    tmp=0</span><br><span class="line">    for j in range(8):</span><br><span class="line">        (R,out)=lfsr(R,mask)</span><br><span class="line">        tmp=(tmp &lt;&lt; 1)^out</span><br><span class="line">    f.write(chr(tmp))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h3 id="分析已知条件"><a href="#分析已知条件" class="headerlink" title="分析已知条件"></a>分析已知条件</h3><ol>
<li><strong>flag包裹的内容为8个16进制数字，就是我们需要求的初始状态的值</strong></li>
<li><strong>反馈函数已知，需要从代码的形式理解为“数学”表达式</strong></li>
<li><strong>已知输出</strong></li>
<li><strong>已知mask</strong></li>
</ol>
<h3 id="分析代码："><a href="#分析代码：" class="headerlink" title="分析代码："></a>分析代码：</h3><ol>
<li><code>output = (R &lt;&lt; 1) &amp; 0xffffffff</code><strong>先把R左移，然后和0xffffffff进行与操作，其作用是把R的最高位抹去并在最低位补0，并保留低32位，再把该值赋值给output</strong></li>
</ol>
<p>假设$R$的值为$\color{red}0\color{black}1101010\quad 11101010\quad 10010001\quad 1011101\color{red}1$</p>
<p>在这串代码作用下首先变成$\color{red}0\color{black}\quad11010101\quad 11010101\quad 00100011\quad 0111011\color{red}0$</p>
<ol start="2">
<li><p><code>i=(R&amp;mask)&amp;0xffffffff</code><strong>将R和mask进行与操作，并保留低32位，再把该值赋值给i，这里mask已知</strong></p>
</li>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lastbit=<span class="number">0</span></span><br><span class="line">   <span class="keyword">while</span> i!=<span class="number">0</span>:</span><br><span class="line">       lastbit ^= (i&amp;<span class="number">1</span>)</span><br><span class="line">       i=i&gt;&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>先看<code>lastbit ^= (i &amp; 1)</code>，和<code>i = i &gt;&gt; 1</code><strong>两串代码作用是把i的每位和1进行与操作，再和lastbit异或</strong></p>
<p>这里假设$i&#x3D;1001$，取短一点也能看出规律</p>
<p>$i和1$进行<code>&amp;</code>操作：$1001$<code> &amp;</code>$0001$</p>
<p>得到：$0001$即$1$，再和$lastbit$异或</p>
<p>还要把$i$右移，变成$0100$</p>
<p>再和1进行与操作：$0100$ <code>&amp;</code>$0001$</p>
<p>得到：$0000$即$0$，再和$lastbit$异或</p>
<p>其实就是从i的最低位向i的最高位依次和1进行与操作(不影响值)，再和lastbit做异或运算，</p>
</li>
<li><p><code>output ^= lastbit</code><strong>将output变量的值和lastbit的值异或，再赋值给output</strong></p>
</li>
<li><pre><code class="python">f=open(&quot;key&quot;,&quot;w&quot;)
for i in range(100):
    tmp=0
    for j in range(8):
        (R,out)=lfsr(R,mask)
        tmp=(tmp &lt;&lt; 1)^out
    f.write(chr(tmp))
f.close()
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">​			最后对flag做了100个循环，每次输出一个字符，这样key中有100个16进制数字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 找寻规律</span><br><span class="line"></span><br><span class="line">1. **因为mask中只有第3，5，8，12，20，27，30，32位是1，其余都是0**</span><br><span class="line">2. **mask与R做按位与运算得到i，当且仅当R的第3、5、8、12、20、27、30、32这几位中也出现1时，i中才可能出现1，否则i中将全为0。**</span><br><span class="line">3. **因为lastbit是i从低位到高位依次和lastbit异或得到的(i中的0可以忽略不计，因为0和任何数做异或运算，得到的结果还是原来的数)，且lastbit的初值为0。当i中有奇数个1的时候lastbit的值为1，当i中有偶数个1的时候lastbit的值为0**</span><br><span class="line"></span><br><span class="line">4. **又因为i是由R和mask进行与操作得到的，所以当R中第3，5，8，12，20，27，30，32有奇数个1的时候lastbit为1，有偶数个1的时候lastbit为0**</span><br><span class="line"></span><br><span class="line">5. **因此我们可以得出结论，lastbit的值取决于R中第3，5，8，12，20，27，30，32依次异或的结果**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 得到结论</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">lastbit = R_3\oplus R_5\oplus R_8\oplus R_&#123;12&#125;\oplus R_&#123;20&#125;\oplus R_&#123;27&#125;\oplus R_&#123;30&#125;\oplus R_&#123;32&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这样就得到了反馈函数的&quot;数学&quot;表达式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
0b100000111111011110111011111000101001001100100111110100000010000011111100110011000111011010100000100011100010101110010111101101000010000011110111110000110010110000111001111010100000110011010101010110100101100011010001011101111101000100110101111100000110000110110000011111010001011001101111001110000100110101111100011101101101101100011101100111011101011101010111011100101110101011011110100111100000111110010010001010001000000011110000011001110010100010010111000010001011110110000010101110011000101011001101111101111010001110010000000101011110001110001110100111011110000111111010110100001010010111001100001101100101011100100111100001100101000100001010001000111010110011111000101110011101000111110110000010000101101010010001111000010101010000011110100001001101111011010000010011110011010110100100001100
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**因为这里除去0b只有798位，所以把前面两位换成0即是800位二进制数据，也许是这样理解的吧**</span><br><span class="line"></span><br><span class="line">**当即将输出第32位lastbit时，此时R已经左移了31位，所以此时第32位就是原来的第1位**</span><br><span class="line"></span><br><span class="line">$last_1 = R_&#123;1,3&#125; \otimes R_&#123;1,5&#125;$</span><br><span class="line"></span><br><span class="line">![](../../images/LFSR/2.png)</span><br><span class="line"></span><br><span class="line">**这样我们就可以求出R的第1位，**</span><br><span class="line">$$</span><br><span class="line">如果求第一位，应该先是这样:\quad </span><br><span class="line">?0010000011111101111011101111100</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">再变成key=00100000111111011110111011111000</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">根据lastbit = R_3\oplus R_5\oplus R_8\oplus R_&#123;12&#125;\oplus R_&#123;20&#125;\oplus R_&#123;27&#125;\oplus R_&#123;30&#125;\oplus R_&#123;32&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">\therefore</span><br><span class="line">R_&#123;32&#125; = R_3\oplus R_5\oplus R_8\oplus R_&#123;12&#125;\oplus R_&#123;20&#125;\oplus R_&#123;27&#125;\oplus R_&#123;30&#125;\oplus lastbit</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">即</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">? = R_3\oplus R_5\oplus R_8\oplus R_&#123;12&#125;\oplus R_&#123;20&#125;\oplus R_&#123;27&#125;\oplus R_&#123;30&#125;\oplus lastbit</span><br><span class="line">对这里求解?0010000011111101111011101111100</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">所以R_1 = 1 \oplus 1 \oplus 0 \oplus 0 \oplus 1 \oplus 0 \oplus 0 \oplus 0=1</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**同样的方法，先右移，我们可以求出R的第2位**</span><br><span class="line"></span><br><span class="line">![](../../images/LFSR/3.png)</span><br><span class="line"></span><br><span class="line">**exp:**</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">key = &quot;00100000111111011110111011111000&quot;</span><br><span class="line">mask = &quot;10100100000010000000100010010100&quot;</span><br><span class="line"></span><br><span class="line">R = &quot;&quot;</span><br><span class="line">tmp = key</span><br><span class="line"></span><br><span class="line">for i in range(32):</span><br><span class="line">    newkey = &#x27;?&#x27;+key[:31]</span><br><span class="line">    m = int(newkey[-3])^int(newkey[-5])^int(newkey[-8])^int(newkey[-12])^int(newkey[-20])^int(newkey[-27])^int(newkey[-30])^int(tmp[-1-i]) #这个tmp[-1-i]是求第i位对应当时lastbit的值</span><br><span class="line">    R += str(m)</span><br><span class="line">    key = str(m) + key[:31]  #这里得到了第1位，求第二位就需要更新key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = &quot;flag&#123;&quot;+ hex(int(R[::-1],2)) + &quot;&#125;&quot;	#逆序回去</span><br><span class="line">print(flag)</span><br><span class="line"></span><br><span class="line">#flag&#123;0x926201d7&#125;</span><br><span class="line">#把0x删了</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p><strong>总之，理解还没有很清楚</strong></p>
<h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><h1 id="例题2-强网杯2018-StreamGame1"><a href="#例题2-强网杯2018-StreamGame1" class="headerlink" title="例题2 强网杯2018 StreamGame1"></a>例题2 强网杯2018 StreamGame1</h1><p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flag import flag</span><br><span class="line">assert flag.startswith(&quot;flag&#123;&quot;)</span><br><span class="line">assert flag.endswith(&quot;&#125;&quot;)</span><br><span class="line">assert len(flag)==25</span><br><span class="line"></span><br><span class="line">def lfsr(R,mask):</span><br><span class="line">    output = (R &lt;&lt; 1) &amp; 0xffffff</span><br><span class="line">    i=(R&amp;mask)&amp;0xffffff</span><br><span class="line">    lastbit=0</span><br><span class="line">    while i!=0:</span><br><span class="line">        lastbit^=(i&amp;1)</span><br><span class="line">        i=i&gt;&gt;1</span><br><span class="line">    output^=lastbit</span><br><span class="line">    return (output,lastbit)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R=int(flag[5:-1],2)</span><br><span class="line">mask    =   0b1010011000100011100</span><br><span class="line"></span><br><span class="line">f=open(&quot;key&quot;,&quot;ab&quot;)</span><br><span class="line">for i in range(12):</span><br><span class="line">    tmp=0</span><br><span class="line">    for j in range(8):</span><br><span class="line">        (R,out)=lfsr(R,mask)</span><br><span class="line">        tmp=(tmp &lt;&lt; 1)^out</span><br><span class="line">    f.write(chr(tmp))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>关于这个key的获取，有点疑惑，从<code>bytes_to_long</code>输出之后除了0b是95位，自己手动在最前面添了0</p>
<p>然后根据题目要求的只有19位，所以取前19位</p>
<p>这个lsfr函数和前面CISCN的一样</p>
<p>再根据mask1的位置，写出反馈函数<br>$$<br>lastbit &#x3D; R_3\oplus R_4\oplus  R_5\oplus R_9\oplus R_{13}\oplus R_{14}\oplus R_{17}\oplus R_{19}<br>$$<br>然后求解就行了</p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key = <span class="string">&quot;0101010100111000111&quot;</span></span><br><span class="line">mask = <span class="string">&quot;1010011000100011100&quot;</span></span><br><span class="line"></span><br><span class="line">R = <span class="string">&quot;&quot;</span></span><br><span class="line">tmp = key</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">19</span>):</span><br><span class="line">    newkey = <span class="string">&#x27;?&#x27;</span>+key[:<span class="number">18</span>]</span><br><span class="line">    m = <span class="built_in">int</span>(newkey[-<span class="number">3</span>])^<span class="built_in">int</span>(newkey[-<span class="number">4</span>])^<span class="built_in">int</span>(newkey[-<span class="number">5</span>])^<span class="built_in">int</span>(newkey[-<span class="number">9</span>])^<span class="built_in">int</span>(newkey[-<span class="number">13</span>])^<span class="built_in">int</span>(newkey[-<span class="number">14</span>])^<span class="built_in">int</span>(newkey[-<span class="number">17</span>])^<span class="built_in">int</span>(tmp[-<span class="number">1</span>-i])</span><br><span class="line">    R += <span class="built_in">str</span>(m)</span><br><span class="line">    key = <span class="built_in">str</span>(m) + key[:<span class="number">18</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;flag&#123;&quot;</span>+ <span class="built_in">str</span>(<span class="built_in">int</span>(R[::-<span class="number">1</span>])) + <span class="string">&quot;&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"><span class="comment">#flag&#123;1110101100001101011&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>还有一种爆破的方法：</strong></p>
<p>用010打开key文件，提取每个值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lfsr</span>(<span class="params">R,mask</span>):</span><br><span class="line">    output = (R &lt;&lt; <span class="number">1</span>) &amp;<span class="number">0xffffff</span></span><br><span class="line">    i=(R&amp;mask)&amp;<span class="number">0xffffff</span></span><br><span class="line">    lastbit=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i!=<span class="number">0</span>:</span><br><span class="line">        lastbit^=(i&amp;<span class="number">1</span>)</span><br><span class="line">        i=i&gt;&gt;<span class="number">1</span></span><br><span class="line">    output^=lastbit</span><br><span class="line">    <span class="keyword">return</span> (output,lastbit)</span><br><span class="line"> </span><br><span class="line">key = [<span class="number">0x55</span>,<span class="number">0x38</span>,<span class="number">0xF7</span>,<span class="number">0x42</span>,<span class="number">0xC1</span>,<span class="number">0x0D</span>,<span class="number">0xB2</span>,<span class="number">0xC7</span>,<span class="number">0xED</span>,<span class="number">0xE0</span>,<span class="number">0x24</span>,<span class="number">0x3A</span>]</span><br><span class="line">mask=<span class="number">0b1010011000100011100</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> trange(<span class="number">2</span>**<span class="number">19</span>):</span><br><span class="line">    R=k</span><br><span class="line">    a=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    judge=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            (k, out) = lfsr(k, mask)</span><br><span class="line">            tmp = (tmp &lt;&lt; <span class="number">1</span>) ^ out</span><br><span class="line">        <span class="keyword">if</span>(key[i]!=tmp):</span><br><span class="line">           judge=<span class="number">0</span></span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span>(judge==<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;flag&#123;&#x27;</span>+<span class="built_in">bin</span>(R)[<span class="number">2</span>:]+<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>



<h1 id="例题3-强网杯2018-StreamGame2"><a href="#例题3-强网杯2018-StreamGame2" class="headerlink" title="例题3 强网杯2018 StreamGame2"></a>例题3 强网杯2018 StreamGame2</h1><p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flag import flag</span><br><span class="line">assert flag.startswith(&quot;flag&#123;&quot;)</span><br><span class="line">assert flag.endswith(&quot;&#125;&quot;)</span><br><span class="line">assert len(flag)==27</span><br><span class="line"></span><br><span class="line">def lfsr(R,mask):</span><br><span class="line">    output = (R &lt;&lt; 1) &amp; 0xffffff</span><br><span class="line">    i=(R&amp;mask)&amp;0xffffff</span><br><span class="line">    lastbit=0</span><br><span class="line">    while i!=0:</span><br><span class="line">        lastbit^=(i&amp;1)</span><br><span class="line">        i=i&gt;&gt;1</span><br><span class="line">    output^=lastbit</span><br><span class="line">    return (output,lastbit)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R=int(flag[5:-1],2)</span><br><span class="line">mask=0x100002</span><br><span class="line"></span><br><span class="line">f=open(&quot;key&quot;,&quot;ab&quot;)</span><br><span class="line">for i in range(12):</span><br><span class="line">    tmp=0</span><br><span class="line">    for j in range(8):</span><br><span class="line">        (R,out)=lfsr(R,mask)</span><br><span class="line">        tmp=(tmp &lt;&lt; 1)^out</span><br><span class="line">    f.write(chr(tmp))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>和StreamGame1类似，换了flag的长度，并且以16进制的形式给出mask</p>
<p><strong>先求mask</strong>,mask &#x3D; <code>100000000000000000010</code></p>
<p><strong>因为mask变了，所以反馈函数变了</strong><br>$$<br>lastbit &#x3D; R_2 \oplus R_{21}<br>$$<br><strong>输出key之后，除了0b就是96位，所以直接取前21位</strong></p>
<p><strong>exp1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key = <span class="string">&quot;101100101110100100001&quot;</span></span><br><span class="line">mask = <span class="string">&quot;100000000000000000010&quot;</span></span><br><span class="line"></span><br><span class="line">R = <span class="string">&quot;&quot;</span></span><br><span class="line">tmp = key</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">21</span>):</span><br><span class="line">    newkey = <span class="string">&#x27;?&#x27;</span>+key[:<span class="number">20</span>]</span><br><span class="line">    m = <span class="built_in">int</span>(newkey[-<span class="number">2</span>])^<span class="built_in">int</span>(tmp[-<span class="number">1</span>-i])</span><br><span class="line">    R += <span class="built_in">str</span>(m)</span><br><span class="line">    key = <span class="built_in">str</span>(m) + key[:<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;flag&#123;&quot;</span>+ <span class="built_in">str</span>(<span class="built_in">int</span>(R[::-<span class="number">1</span>])) + <span class="string">&quot;&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"><span class="comment">#flag&#123;110111100101001101001&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>exp2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lfsr</span>(<span class="params">R,mask</span>):</span><br><span class="line">    output = (R &lt;&lt; <span class="number">1</span>) &amp;<span class="number">0xffffff</span></span><br><span class="line">    i=(R&amp;mask)&amp;<span class="number">0xffffff</span></span><br><span class="line">    lastbit=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i!=<span class="number">0</span>:</span><br><span class="line">        lastbit^=(i&amp;<span class="number">1</span>)</span><br><span class="line">        i=i&gt;&gt;<span class="number">1</span></span><br><span class="line">    output^=lastbit</span><br><span class="line">    <span class="keyword">return</span> (output,lastbit)</span><br><span class="line"> </span><br><span class="line">key = [<span class="number">0xB2</span>,<span class="number">0xE9</span>,<span class="number">0x0E</span>,<span class="number">0x13</span>,<span class="number">0xA0</span>,<span class="number">0x6A</span>,<span class="number">0x1B</span>,<span class="number">0xFC</span>,<span class="number">0x40</span>,<span class="number">0xE6</span>,<span class="number">0x7D</span>,<span class="number">0x53</span>]</span><br><span class="line">mask=<span class="number">0b100000000000000000010</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> trange(<span class="number">2</span>**<span class="number">21</span>):</span><br><span class="line">    R=k</span><br><span class="line">    a=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    judge=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            (k, out) = lfsr(k, mask)</span><br><span class="line">            tmp = (tmp &lt;&lt; <span class="number">1</span>) ^ out</span><br><span class="line">        <span class="keyword">if</span>(key[i]!=tmp):</span><br><span class="line">           judge=<span class="number">0</span></span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span>(judge==<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;flag&#123;&#x27;</span>+<span class="built_in">bin</span>(R)[<span class="number">2</span>:]+<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>



<h1 id="例题4-2018HITB-XCTF"><a href="#例题4-2018HITB-XCTF" class="headerlink" title="例题4 2018HITB-XCTF"></a>例题4 2018HITB-XCTF</h1><p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flag import flag</span><br><span class="line">assert flag.startswith(&quot;flag&#123;&quot;)</span><br><span class="line">assert flag.endswith(&quot;&#125;&quot;)</span><br><span class="line">assert len(flag)==47</span><br><span class="line"> </span><br><span class="line">def lfsr(R,mask):</span><br><span class="line">    output = (R &lt;&lt; 1) &amp; 0xffffff</span><br><span class="line">    i=(R&amp;mask)&amp;0xffffff</span><br><span class="line">    lastbit=0</span><br><span class="line">    while i!=0:</span><br><span class="line">        lastbit^=(i&amp;1)</span><br><span class="line">        i=i&gt;&gt;1</span><br><span class="line">    output^=lastbit</span><br><span class="line">    return (output,lastbit)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">R=int(flag[5:-1],2)</span><br><span class="line">mask    =   0b10110110110011010111001101011010101011011</span><br><span class="line"> </span><br><span class="line">f=open(&quot;key&quot;,&quot;ab&quot;)</span><br><span class="line">for i in range(64):</span><br><span class="line">    tmp=0</span><br><span class="line">    for j in range(8):</span><br><span class="line">        (R,out)=lfsr(R,mask)</span><br><span class="line">        tmp=(tmp &lt;&lt; 1)^out</span><br><span class="line">    f.write(chr(tmp))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p><strong>lfsr还是没变化，变的是flag的长度和mask</strong></p>
<p>根据mask求出反馈函数<br>$$<br>lastbit &#x3D;R_1\oplus R_2\oplus R_4\oplus R_5\oplus R_7\oplus R_9\oplus R_{11}\oplus R_{13}\oplus R_{14}\oplus R_{16}\oplus R_{18}\oplus R_{19}\oplus R_{22}\oplus R_{23}\oplus R_{24}\oplus R_{26}\oplus R_{28}\oplus R_{29}\oplus R_{32}\oplus R_{33}\oplus R_{35}\oplus R_{36}\oplus R_{38}\oplus R_{39}\oplus R_{41}<br>$$<br><strong>呜呜呜有题目没附件</strong></p>
<h1 id="例题5-强网杯2018-StreamGame4"><a href="#例题5-强网杯2018-StreamGame4" class="headerlink" title="例题5 强网杯2018 StreamGame4"></a>例题5 强网杯2018 StreamGame4</h1><p>题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flag import flag</span><br><span class="line">assert flag.startswith(&quot;flag&#123;&quot;)</span><br><span class="line">assert flag.endswith(&quot;&#125;&quot;)</span><br><span class="line">assert len(flag)==27</span><br><span class="line"> </span><br><span class="line">def nlfsr(R,mask):</span><br><span class="line">    output = (R &lt;&lt; 1) &amp; 0xffffff</span><br><span class="line">    i=(R&amp;mask)&amp;0xffffff</span><br><span class="line">    lastbit=0</span><br><span class="line">    changesign=True</span><br><span class="line">    while i!=0:</span><br><span class="line">        if changesign:</span><br><span class="line">            lastbit &amp;= (i &amp; 1)</span><br><span class="line">            changesign=False</span><br><span class="line">        else:</span><br><span class="line">            lastbit^=(i&amp;1)</span><br><span class="line">        i=i&gt;&gt;1</span><br><span class="line">    output^=lastbit</span><br><span class="line">    return (output,lastbit)</span><br><span class="line"> </span><br><span class="line">R=int(flag[5:-1],2)</span><br><span class="line">mask=0b110110011011001101110</span><br><span class="line"> </span><br><span class="line">f=open(&quot;key&quot;,&quot;ab&quot;)</span><br><span class="line">for i in range(1024*1024):</span><br><span class="line">    tmp=0</span><br><span class="line">    for j in range(8):</span><br><span class="line">        (R,out)=nlfsr(R,mask)</span><br><span class="line">        tmp=(tmp &lt;&lt; 1)^out</span><br><span class="line">    f.write(chr(tmp))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p><strong>不同之处在于反馈函数不一样了</strong></p>
<p><strong>我的理解是第一个lastbit一定为0</strong></p>
]]></content>
      <categories>
        <category>现代密码-流密码</category>
      </categories>
      <tags>
        <tag>现代密码</tag>
        <tag>流密码</tag>
        <tag>LFSR</tag>
      </tags>
  </entry>
</search>
